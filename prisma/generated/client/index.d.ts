
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model VerificationCode
 * 
 */
export type VerificationCode = $Result.DefaultSelection<Prisma.$VerificationCodePayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model RolePermission
 * 
 */
export type RolePermission = $Result.DefaultSelection<Prisma.$RolePermissionPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model IndividualProfessional
 * 
 */
export type IndividualProfessional = $Result.DefaultSelection<Prisma.$IndividualProfessionalPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model SecurityCompany
 * 
 */
export type SecurityCompany = $Result.DefaultSelection<Prisma.$SecurityCompanyPayload>
/**
 * Model CourseProvider
 * 
 */
export type CourseProvider = $Result.DefaultSelection<Prisma.$CourseProviderPayload>
/**
 * Model CorporateClient
 * 
 */
export type CorporateClient = $Result.DefaultSelection<Prisma.$CorporateClientPayload>
/**
 * Model CorporateAd
 * 
 */
export type CorporateAd = $Result.DefaultSelection<Prisma.$CorporateAdPayload>
/**
 * Model CourseAd
 * 
 */
export type CourseAd = $Result.DefaultSelection<Prisma.$CourseAdPayload>
/**
 * Model ServiceAd
 * 
 */
export type ServiceAd = $Result.DefaultSelection<Prisma.$ServiceAdPayload>
/**
 * Model ClientAd
 * 
 */
export type ClientAd = $Result.DefaultSelection<Prisma.$ClientAdPayload>
/**
 * Model RoleUser
 * 
 */
export type RoleUser = $Result.DefaultSelection<Prisma.$RoleUserPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Permissions
 * const permissions = await prisma.permission.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Permissions
   * const permissions = await prisma.permission.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationCode`: Exposes CRUD operations for the **VerificationCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationCodes
    * const verificationCodes = await prisma.verificationCode.findMany()
    * ```
    */
  get verificationCode(): Prisma.VerificationCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rolePermission`: Exposes CRUD operations for the **RolePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermission.findMany()
    * ```
    */
  get rolePermission(): Prisma.RolePermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.individualProfessional`: Exposes CRUD operations for the **IndividualProfessional** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IndividualProfessionals
    * const individualProfessionals = await prisma.individualProfessional.findMany()
    * ```
    */
  get individualProfessional(): Prisma.IndividualProfessionalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.securityCompany`: Exposes CRUD operations for the **SecurityCompany** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SecurityCompanies
    * const securityCompanies = await prisma.securityCompany.findMany()
    * ```
    */
  get securityCompany(): Prisma.SecurityCompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseProvider`: Exposes CRUD operations for the **CourseProvider** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseProviders
    * const courseProviders = await prisma.courseProvider.findMany()
    * ```
    */
  get courseProvider(): Prisma.CourseProviderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.corporateClient`: Exposes CRUD operations for the **CorporateClient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CorporateClients
    * const corporateClients = await prisma.corporateClient.findMany()
    * ```
    */
  get corporateClient(): Prisma.CorporateClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.corporateAd`: Exposes CRUD operations for the **CorporateAd** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CorporateAds
    * const corporateAds = await prisma.corporateAd.findMany()
    * ```
    */
  get corporateAd(): Prisma.CorporateAdDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseAd`: Exposes CRUD operations for the **CourseAd** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseAds
    * const courseAds = await prisma.courseAd.findMany()
    * ```
    */
  get courseAd(): Prisma.CourseAdDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceAd`: Exposes CRUD operations for the **ServiceAd** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceAds
    * const serviceAds = await prisma.serviceAd.findMany()
    * ```
    */
  get serviceAd(): Prisma.ServiceAdDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientAd`: Exposes CRUD operations for the **ClientAd** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientAds
    * const clientAds = await prisma.clientAd.findMany()
    * ```
    */
  get clientAd(): Prisma.ClientAdDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roleUser`: Exposes CRUD operations for the **RoleUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoleUsers
    * const roleUsers = await prisma.roleUser.findMany()
    * ```
    */
  get roleUser(): Prisma.RoleUserDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Permission: 'Permission',
    VerificationCode: 'VerificationCode',
    Role: 'Role',
    RolePermission: 'RolePermission',
    User: 'User',
    IndividualProfessional: 'IndividualProfessional',
    Client: 'Client',
    SecurityCompany: 'SecurityCompany',
    CourseProvider: 'CourseProvider',
    CorporateClient: 'CorporateClient',
    CorporateAd: 'CorporateAd',
    CourseAd: 'CourseAd',
    ServiceAd: 'ServiceAd',
    ClientAd: 'ClientAd',
    RoleUser: 'RoleUser'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "permission" | "verificationCode" | "role" | "rolePermission" | "user" | "individualProfessional" | "client" | "securityCompany" | "courseProvider" | "corporateClient" | "corporateAd" | "courseAd" | "serviceAd" | "clientAd" | "roleUser"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      VerificationCode: {
        payload: Prisma.$VerificationCodePayload<ExtArgs>
        fields: Prisma.VerificationCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>
          }
          findFirst: {
            args: Prisma.VerificationCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>
          }
          findMany: {
            args: Prisma.VerificationCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>[]
          }
          create: {
            args: Prisma.VerificationCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>
          }
          createMany: {
            args: Prisma.VerificationCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>[]
          }
          delete: {
            args: Prisma.VerificationCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>
          }
          update: {
            args: Prisma.VerificationCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>
          }
          deleteMany: {
            args: Prisma.VerificationCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationCodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>[]
          }
          upsert: {
            args: Prisma.VerificationCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>
          }
          aggregate: {
            args: Prisma.VerificationCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationCode>
          }
          groupBy: {
            args: Prisma.VerificationCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCodeCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCodeCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      RolePermission: {
        payload: Prisma.$RolePermissionPayload<ExtArgs>
        fields: Prisma.RolePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findFirst: {
            args: Prisma.RolePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findMany: {
            args: Prisma.RolePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          create: {
            args: Prisma.RolePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          createMany: {
            args: Prisma.RolePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolePermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          delete: {
            args: Prisma.RolePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          update: {
            args: Prisma.RolePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          deleteMany: {
            args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RolePermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          upsert: {
            args: Prisma.RolePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          aggregate: {
            args: Prisma.RolePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePermission>
          }
          groupBy: {
            args: Prisma.RolePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      IndividualProfessional: {
        payload: Prisma.$IndividualProfessionalPayload<ExtArgs>
        fields: Prisma.IndividualProfessionalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IndividualProfessionalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndividualProfessionalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IndividualProfessionalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndividualProfessionalPayload>
          }
          findFirst: {
            args: Prisma.IndividualProfessionalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndividualProfessionalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IndividualProfessionalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndividualProfessionalPayload>
          }
          findMany: {
            args: Prisma.IndividualProfessionalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndividualProfessionalPayload>[]
          }
          create: {
            args: Prisma.IndividualProfessionalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndividualProfessionalPayload>
          }
          createMany: {
            args: Prisma.IndividualProfessionalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IndividualProfessionalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndividualProfessionalPayload>[]
          }
          delete: {
            args: Prisma.IndividualProfessionalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndividualProfessionalPayload>
          }
          update: {
            args: Prisma.IndividualProfessionalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndividualProfessionalPayload>
          }
          deleteMany: {
            args: Prisma.IndividualProfessionalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IndividualProfessionalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IndividualProfessionalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndividualProfessionalPayload>[]
          }
          upsert: {
            args: Prisma.IndividualProfessionalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndividualProfessionalPayload>
          }
          aggregate: {
            args: Prisma.IndividualProfessionalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIndividualProfessional>
          }
          groupBy: {
            args: Prisma.IndividualProfessionalGroupByArgs<ExtArgs>
            result: $Utils.Optional<IndividualProfessionalGroupByOutputType>[]
          }
          count: {
            args: Prisma.IndividualProfessionalCountArgs<ExtArgs>
            result: $Utils.Optional<IndividualProfessionalCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      SecurityCompany: {
        payload: Prisma.$SecurityCompanyPayload<ExtArgs>
        fields: Prisma.SecurityCompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SecurityCompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityCompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SecurityCompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityCompanyPayload>
          }
          findFirst: {
            args: Prisma.SecurityCompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityCompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SecurityCompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityCompanyPayload>
          }
          findMany: {
            args: Prisma.SecurityCompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityCompanyPayload>[]
          }
          create: {
            args: Prisma.SecurityCompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityCompanyPayload>
          }
          createMany: {
            args: Prisma.SecurityCompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SecurityCompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityCompanyPayload>[]
          }
          delete: {
            args: Prisma.SecurityCompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityCompanyPayload>
          }
          update: {
            args: Prisma.SecurityCompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityCompanyPayload>
          }
          deleteMany: {
            args: Prisma.SecurityCompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SecurityCompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SecurityCompanyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityCompanyPayload>[]
          }
          upsert: {
            args: Prisma.SecurityCompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityCompanyPayload>
          }
          aggregate: {
            args: Prisma.SecurityCompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSecurityCompany>
          }
          groupBy: {
            args: Prisma.SecurityCompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<SecurityCompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.SecurityCompanyCountArgs<ExtArgs>
            result: $Utils.Optional<SecurityCompanyCountAggregateOutputType> | number
          }
        }
      }
      CourseProvider: {
        payload: Prisma.$CourseProviderPayload<ExtArgs>
        fields: Prisma.CourseProviderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseProviderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseProviderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseProviderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseProviderPayload>
          }
          findFirst: {
            args: Prisma.CourseProviderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseProviderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseProviderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseProviderPayload>
          }
          findMany: {
            args: Prisma.CourseProviderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseProviderPayload>[]
          }
          create: {
            args: Prisma.CourseProviderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseProviderPayload>
          }
          createMany: {
            args: Prisma.CourseProviderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseProviderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseProviderPayload>[]
          }
          delete: {
            args: Prisma.CourseProviderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseProviderPayload>
          }
          update: {
            args: Prisma.CourseProviderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseProviderPayload>
          }
          deleteMany: {
            args: Prisma.CourseProviderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseProviderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseProviderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseProviderPayload>[]
          }
          upsert: {
            args: Prisma.CourseProviderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseProviderPayload>
          }
          aggregate: {
            args: Prisma.CourseProviderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseProvider>
          }
          groupBy: {
            args: Prisma.CourseProviderGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseProviderGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseProviderCountArgs<ExtArgs>
            result: $Utils.Optional<CourseProviderCountAggregateOutputType> | number
          }
        }
      }
      CorporateClient: {
        payload: Prisma.$CorporateClientPayload<ExtArgs>
        fields: Prisma.CorporateClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CorporateClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CorporateClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateClientPayload>
          }
          findFirst: {
            args: Prisma.CorporateClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CorporateClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateClientPayload>
          }
          findMany: {
            args: Prisma.CorporateClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateClientPayload>[]
          }
          create: {
            args: Prisma.CorporateClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateClientPayload>
          }
          createMany: {
            args: Prisma.CorporateClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CorporateClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateClientPayload>[]
          }
          delete: {
            args: Prisma.CorporateClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateClientPayload>
          }
          update: {
            args: Prisma.CorporateClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateClientPayload>
          }
          deleteMany: {
            args: Prisma.CorporateClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CorporateClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CorporateClientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateClientPayload>[]
          }
          upsert: {
            args: Prisma.CorporateClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateClientPayload>
          }
          aggregate: {
            args: Prisma.CorporateClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCorporateClient>
          }
          groupBy: {
            args: Prisma.CorporateClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<CorporateClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.CorporateClientCountArgs<ExtArgs>
            result: $Utils.Optional<CorporateClientCountAggregateOutputType> | number
          }
        }
      }
      CorporateAd: {
        payload: Prisma.$CorporateAdPayload<ExtArgs>
        fields: Prisma.CorporateAdFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CorporateAdFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateAdPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CorporateAdFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateAdPayload>
          }
          findFirst: {
            args: Prisma.CorporateAdFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateAdPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CorporateAdFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateAdPayload>
          }
          findMany: {
            args: Prisma.CorporateAdFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateAdPayload>[]
          }
          create: {
            args: Prisma.CorporateAdCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateAdPayload>
          }
          createMany: {
            args: Prisma.CorporateAdCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CorporateAdCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateAdPayload>[]
          }
          delete: {
            args: Prisma.CorporateAdDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateAdPayload>
          }
          update: {
            args: Prisma.CorporateAdUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateAdPayload>
          }
          deleteMany: {
            args: Prisma.CorporateAdDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CorporateAdUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CorporateAdUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateAdPayload>[]
          }
          upsert: {
            args: Prisma.CorporateAdUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateAdPayload>
          }
          aggregate: {
            args: Prisma.CorporateAdAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCorporateAd>
          }
          groupBy: {
            args: Prisma.CorporateAdGroupByArgs<ExtArgs>
            result: $Utils.Optional<CorporateAdGroupByOutputType>[]
          }
          count: {
            args: Prisma.CorporateAdCountArgs<ExtArgs>
            result: $Utils.Optional<CorporateAdCountAggregateOutputType> | number
          }
        }
      }
      CourseAd: {
        payload: Prisma.$CourseAdPayload<ExtArgs>
        fields: Prisma.CourseAdFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseAdFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseAdPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseAdFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseAdPayload>
          }
          findFirst: {
            args: Prisma.CourseAdFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseAdPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseAdFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseAdPayload>
          }
          findMany: {
            args: Prisma.CourseAdFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseAdPayload>[]
          }
          create: {
            args: Prisma.CourseAdCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseAdPayload>
          }
          createMany: {
            args: Prisma.CourseAdCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseAdCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseAdPayload>[]
          }
          delete: {
            args: Prisma.CourseAdDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseAdPayload>
          }
          update: {
            args: Prisma.CourseAdUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseAdPayload>
          }
          deleteMany: {
            args: Prisma.CourseAdDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseAdUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseAdUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseAdPayload>[]
          }
          upsert: {
            args: Prisma.CourseAdUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseAdPayload>
          }
          aggregate: {
            args: Prisma.CourseAdAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseAd>
          }
          groupBy: {
            args: Prisma.CourseAdGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseAdGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseAdCountArgs<ExtArgs>
            result: $Utils.Optional<CourseAdCountAggregateOutputType> | number
          }
        }
      }
      ServiceAd: {
        payload: Prisma.$ServiceAdPayload<ExtArgs>
        fields: Prisma.ServiceAdFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceAdFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAdPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceAdFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAdPayload>
          }
          findFirst: {
            args: Prisma.ServiceAdFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAdPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceAdFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAdPayload>
          }
          findMany: {
            args: Prisma.ServiceAdFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAdPayload>[]
          }
          create: {
            args: Prisma.ServiceAdCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAdPayload>
          }
          createMany: {
            args: Prisma.ServiceAdCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceAdCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAdPayload>[]
          }
          delete: {
            args: Prisma.ServiceAdDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAdPayload>
          }
          update: {
            args: Prisma.ServiceAdUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAdPayload>
          }
          deleteMany: {
            args: Prisma.ServiceAdDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceAdUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceAdUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAdPayload>[]
          }
          upsert: {
            args: Prisma.ServiceAdUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAdPayload>
          }
          aggregate: {
            args: Prisma.ServiceAdAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceAd>
          }
          groupBy: {
            args: Prisma.ServiceAdGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceAdGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceAdCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceAdCountAggregateOutputType> | number
          }
        }
      }
      ClientAd: {
        payload: Prisma.$ClientAdPayload<ExtArgs>
        fields: Prisma.ClientAdFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientAdFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAdPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientAdFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAdPayload>
          }
          findFirst: {
            args: Prisma.ClientAdFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAdPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientAdFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAdPayload>
          }
          findMany: {
            args: Prisma.ClientAdFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAdPayload>[]
          }
          create: {
            args: Prisma.ClientAdCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAdPayload>
          }
          createMany: {
            args: Prisma.ClientAdCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientAdCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAdPayload>[]
          }
          delete: {
            args: Prisma.ClientAdDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAdPayload>
          }
          update: {
            args: Prisma.ClientAdUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAdPayload>
          }
          deleteMany: {
            args: Prisma.ClientAdDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientAdUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientAdUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAdPayload>[]
          }
          upsert: {
            args: Prisma.ClientAdUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAdPayload>
          }
          aggregate: {
            args: Prisma.ClientAdAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientAd>
          }
          groupBy: {
            args: Prisma.ClientAdGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientAdGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientAdCountArgs<ExtArgs>
            result: $Utils.Optional<ClientAdCountAggregateOutputType> | number
          }
        }
      }
      RoleUser: {
        payload: Prisma.$RoleUserPayload<ExtArgs>
        fields: Prisma.RoleUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleUserPayload>
          }
          findFirst: {
            args: Prisma.RoleUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleUserPayload>
          }
          findMany: {
            args: Prisma.RoleUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleUserPayload>[]
          }
          create: {
            args: Prisma.RoleUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleUserPayload>
          }
          createMany: {
            args: Prisma.RoleUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleUserPayload>[]
          }
          delete: {
            args: Prisma.RoleUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleUserPayload>
          }
          update: {
            args: Prisma.RoleUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleUserPayload>
          }
          deleteMany: {
            args: Prisma.RoleUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleUserPayload>[]
          }
          upsert: {
            args: Prisma.RoleUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleUserPayload>
          }
          aggregate: {
            args: Prisma.RoleUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoleUser>
          }
          groupBy: {
            args: Prisma.RoleUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleUserCountArgs<ExtArgs>
            result: $Utils.Optional<RoleUserCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    permission?: PermissionOmit
    verificationCode?: VerificationCodeOmit
    role?: RoleOmit
    rolePermission?: RolePermissionOmit
    user?: UserOmit
    individualProfessional?: IndividualProfessionalOmit
    client?: ClientOmit
    securityCompany?: SecurityCompanyOmit
    courseProvider?: CourseProviderOmit
    corporateClient?: CorporateClientOmit
    corporateAd?: CorporateAdOmit
    courseAd?: CourseAdOmit
    serviceAd?: ServiceAdOmit
    clientAd?: ClientAdOmit
    roleUser?: RoleUserOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    roles: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | PermissionCountOutputTypeCountRolesArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    permissions: number
    users: number
    roleUsers: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | RoleCountOutputTypeCountPermissionsArgs
    users?: boolean | RoleCountOutputTypeCountUsersArgs
    roleUsers?: boolean | RoleCountOutputTypeCountRoleUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountRoleUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleUserWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    roleUsers: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roleUsers?: boolean | UserCountOutputTypeCountRoleUsersArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRoleUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleUserWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    ads: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ads?: boolean | ClientCountOutputTypeCountAdsArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountAdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientAdWhereInput
  }


  /**
   * Count Type SecurityCompanyCountOutputType
   */

  export type SecurityCompanyCountOutputType = {
    serviceAds: number
  }

  export type SecurityCompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceAds?: boolean | SecurityCompanyCountOutputTypeCountServiceAdsArgs
  }

  // Custom InputTypes
  /**
   * SecurityCompanyCountOutputType without action
   */
  export type SecurityCompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityCompanyCountOutputType
     */
    select?: SecurityCompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SecurityCompanyCountOutputType without action
   */
  export type SecurityCompanyCountOutputTypeCountServiceAdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceAdWhereInput
  }


  /**
   * Count Type CourseProviderCountOutputType
   */

  export type CourseProviderCountOutputType = {
    courseAds: number
  }

  export type CourseProviderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courseAds?: boolean | CourseProviderCountOutputTypeCountCourseAdsArgs
  }

  // Custom InputTypes
  /**
   * CourseProviderCountOutputType without action
   */
  export type CourseProviderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProviderCountOutputType
     */
    select?: CourseProviderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseProviderCountOutputType without action
   */
  export type CourseProviderCountOutputTypeCountCourseAdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseAdWhereInput
  }


  /**
   * Count Type CorporateClientCountOutputType
   */

  export type CorporateClientCountOutputType = {
    corporateAds: number
  }

  export type CorporateClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    corporateAds?: boolean | CorporateClientCountOutputTypeCountCorporateAdsArgs
  }

  // Custom InputTypes
  /**
   * CorporateClientCountOutputType without action
   */
  export type CorporateClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateClientCountOutputType
     */
    select?: CorporateClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CorporateClientCountOutputType without action
   */
  export type CorporateClientCountOutputTypeCountCorporateAdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CorporateAdWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionAvgAggregateOutputType = {
    id: number | null
  }

  export type PermissionSumAggregateOutputType = {
    id: number | null
  }

  export type PermissionMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PermissionAvgAggregateInputType = {
    id?: true
  }

  export type PermissionSumAggregateInputType = {
    id?: true
  }

  export type PermissionMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _avg?: PermissionAvgAggregateInputType
    _sum?: PermissionSumAggregateInputType
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roles?: boolean | Permission$rolesArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["permission"]>
  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | Permission$rolesArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      roles: Prisma.$RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions and returns the data updated in the database.
     * @param {PermissionUpdateManyAndReturnArgs} args - Arguments to update many Permissions.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, PermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends Permission$rolesArgs<ExtArgs> = {}>(args?: Subset<T, Permission$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'Int'>
    readonly name: FieldRef<"Permission", 'String'>
    readonly createdAt: FieldRef<"Permission", 'DateTime'>
    readonly updatedAt: FieldRef<"Permission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission createManyAndReturn
   */
  export type PermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission updateManyAndReturn
   */
  export type PermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to delete.
     */
    limit?: number
  }

  /**
   * Permission.roles
   */
  export type Permission$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationCode
   */

  export type AggregateVerificationCode = {
    _count: VerificationCodeCountAggregateOutputType | null
    _avg: VerificationCodeAvgAggregateOutputType | null
    _sum: VerificationCodeSumAggregateOutputType | null
    _min: VerificationCodeMinAggregateOutputType | null
    _max: VerificationCodeMaxAggregateOutputType | null
  }

  export type VerificationCodeAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type VerificationCodeSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type VerificationCodeMinAggregateOutputType = {
    id: number | null
    userId: number | null
    code: string | null
    expiresAt: Date | null
  }

  export type VerificationCodeMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    code: string | null
    expiresAt: Date | null
  }

  export type VerificationCodeCountAggregateOutputType = {
    id: number
    userId: number
    code: number
    expiresAt: number
    _all: number
  }


  export type VerificationCodeAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type VerificationCodeSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type VerificationCodeMinAggregateInputType = {
    id?: true
    userId?: true
    code?: true
    expiresAt?: true
  }

  export type VerificationCodeMaxAggregateInputType = {
    id?: true
    userId?: true
    code?: true
    expiresAt?: true
  }

  export type VerificationCodeCountAggregateInputType = {
    id?: true
    userId?: true
    code?: true
    expiresAt?: true
    _all?: true
  }

  export type VerificationCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationCode to aggregate.
     */
    where?: VerificationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationCodes to fetch.
     */
    orderBy?: VerificationCodeOrderByWithRelationInput | VerificationCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationCodes
    **/
    _count?: true | VerificationCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VerificationCodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VerificationCodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationCodeMaxAggregateInputType
  }

  export type GetVerificationCodeAggregateType<T extends VerificationCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationCode[P]>
      : GetScalarType<T[P], AggregateVerificationCode[P]>
  }




  export type VerificationCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationCodeWhereInput
    orderBy?: VerificationCodeOrderByWithAggregationInput | VerificationCodeOrderByWithAggregationInput[]
    by: VerificationCodeScalarFieldEnum[] | VerificationCodeScalarFieldEnum
    having?: VerificationCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCodeCountAggregateInputType | true
    _avg?: VerificationCodeAvgAggregateInputType
    _sum?: VerificationCodeSumAggregateInputType
    _min?: VerificationCodeMinAggregateInputType
    _max?: VerificationCodeMaxAggregateInputType
  }

  export type VerificationCodeGroupByOutputType = {
    id: number
    userId: number
    code: string
    expiresAt: Date
    _count: VerificationCodeCountAggregateOutputType | null
    _avg: VerificationCodeAvgAggregateOutputType | null
    _sum: VerificationCodeSumAggregateOutputType | null
    _min: VerificationCodeMinAggregateOutputType | null
    _max: VerificationCodeMaxAggregateOutputType | null
  }

  type GetVerificationCodeGroupByPayload<T extends VerificationCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationCodeGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationCodeGroupByOutputType[P]>
        }
      >
    >


  export type VerificationCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    code?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verificationCode"]>

  export type VerificationCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    code?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verificationCode"]>

  export type VerificationCodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    code?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verificationCode"]>

  export type VerificationCodeSelectScalar = {
    id?: boolean
    userId?: boolean
    code?: boolean
    expiresAt?: boolean
  }

  export type VerificationCodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "code" | "expiresAt", ExtArgs["result"]["verificationCode"]>
  export type VerificationCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VerificationCodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VerificationCodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VerificationCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationCode"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      code: string
      expiresAt: Date
    }, ExtArgs["result"]["verificationCode"]>
    composites: {}
  }

  type VerificationCodeGetPayload<S extends boolean | null | undefined | VerificationCodeDefaultArgs> = $Result.GetResult<Prisma.$VerificationCodePayload, S>

  type VerificationCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationCodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCodeCountAggregateInputType | true
    }

  export interface VerificationCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationCode'], meta: { name: 'VerificationCode' } }
    /**
     * Find zero or one VerificationCode that matches the filter.
     * @param {VerificationCodeFindUniqueArgs} args - Arguments to find a VerificationCode
     * @example
     * // Get one VerificationCode
     * const verificationCode = await prisma.verificationCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationCodeFindUniqueArgs>(args: SelectSubset<T, VerificationCodeFindUniqueArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationCodeFindUniqueOrThrowArgs} args - Arguments to find a VerificationCode
     * @example
     * // Get one VerificationCode
     * const verificationCode = await prisma.verificationCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeFindFirstArgs} args - Arguments to find a VerificationCode
     * @example
     * // Get one VerificationCode
     * const verificationCode = await prisma.verificationCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationCodeFindFirstArgs>(args?: SelectSubset<T, VerificationCodeFindFirstArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeFindFirstOrThrowArgs} args - Arguments to find a VerificationCode
     * @example
     * // Get one VerificationCode
     * const verificationCode = await prisma.verificationCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationCodes
     * const verificationCodes = await prisma.verificationCode.findMany()
     * 
     * // Get first 10 VerificationCodes
     * const verificationCodes = await prisma.verificationCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationCodeWithIdOnly = await prisma.verificationCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationCodeFindManyArgs>(args?: SelectSubset<T, VerificationCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationCode.
     * @param {VerificationCodeCreateArgs} args - Arguments to create a VerificationCode.
     * @example
     * // Create one VerificationCode
     * const VerificationCode = await prisma.verificationCode.create({
     *   data: {
     *     // ... data to create a VerificationCode
     *   }
     * })
     * 
     */
    create<T extends VerificationCodeCreateArgs>(args: SelectSubset<T, VerificationCodeCreateArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationCodes.
     * @param {VerificationCodeCreateManyArgs} args - Arguments to create many VerificationCodes.
     * @example
     * // Create many VerificationCodes
     * const verificationCode = await prisma.verificationCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCodeCreateManyArgs>(args?: SelectSubset<T, VerificationCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationCodes and returns the data saved in the database.
     * @param {VerificationCodeCreateManyAndReturnArgs} args - Arguments to create many VerificationCodes.
     * @example
     * // Create many VerificationCodes
     * const verificationCode = await prisma.verificationCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationCodes and only return the `id`
     * const verificationCodeWithIdOnly = await prisma.verificationCode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationCode.
     * @param {VerificationCodeDeleteArgs} args - Arguments to delete one VerificationCode.
     * @example
     * // Delete one VerificationCode
     * const VerificationCode = await prisma.verificationCode.delete({
     *   where: {
     *     // ... filter to delete one VerificationCode
     *   }
     * })
     * 
     */
    delete<T extends VerificationCodeDeleteArgs>(args: SelectSubset<T, VerificationCodeDeleteArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationCode.
     * @param {VerificationCodeUpdateArgs} args - Arguments to update one VerificationCode.
     * @example
     * // Update one VerificationCode
     * const verificationCode = await prisma.verificationCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationCodeUpdateArgs>(args: SelectSubset<T, VerificationCodeUpdateArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationCodes.
     * @param {VerificationCodeDeleteManyArgs} args - Arguments to filter VerificationCodes to delete.
     * @example
     * // Delete a few VerificationCodes
     * const { count } = await prisma.verificationCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationCodeDeleteManyArgs>(args?: SelectSubset<T, VerificationCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationCodes
     * const verificationCode = await prisma.verificationCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationCodeUpdateManyArgs>(args: SelectSubset<T, VerificationCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationCodes and returns the data updated in the database.
     * @param {VerificationCodeUpdateManyAndReturnArgs} args - Arguments to update many VerificationCodes.
     * @example
     * // Update many VerificationCodes
     * const verificationCode = await prisma.verificationCode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationCodes and only return the `id`
     * const verificationCodeWithIdOnly = await prisma.verificationCode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationCodeUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationCodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationCode.
     * @param {VerificationCodeUpsertArgs} args - Arguments to update or create a VerificationCode.
     * @example
     * // Update or create a VerificationCode
     * const verificationCode = await prisma.verificationCode.upsert({
     *   create: {
     *     // ... data to create a VerificationCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationCode we want to update
     *   }
     * })
     */
    upsert<T extends VerificationCodeUpsertArgs>(args: SelectSubset<T, VerificationCodeUpsertArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeCountArgs} args - Arguments to filter VerificationCodes to count.
     * @example
     * // Count the number of VerificationCodes
     * const count = await prisma.verificationCode.count({
     *   where: {
     *     // ... the filter for the VerificationCodes we want to count
     *   }
     * })
    **/
    count<T extends VerificationCodeCountArgs>(
      args?: Subset<T, VerificationCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationCodeAggregateArgs>(args: Subset<T, VerificationCodeAggregateArgs>): Prisma.PrismaPromise<GetVerificationCodeAggregateType<T>>

    /**
     * Group by VerificationCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationCodeGroupByArgs['orderBy'] }
        : { orderBy?: VerificationCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationCode model
   */
  readonly fields: VerificationCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationCode model
   */
  interface VerificationCodeFieldRefs {
    readonly id: FieldRef<"VerificationCode", 'Int'>
    readonly userId: FieldRef<"VerificationCode", 'Int'>
    readonly code: FieldRef<"VerificationCode", 'String'>
    readonly expiresAt: FieldRef<"VerificationCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationCode findUnique
   */
  export type VerificationCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeInclude<ExtArgs> | null
    /**
     * Filter, which VerificationCode to fetch.
     */
    where: VerificationCodeWhereUniqueInput
  }

  /**
   * VerificationCode findUniqueOrThrow
   */
  export type VerificationCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeInclude<ExtArgs> | null
    /**
     * Filter, which VerificationCode to fetch.
     */
    where: VerificationCodeWhereUniqueInput
  }

  /**
   * VerificationCode findFirst
   */
  export type VerificationCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeInclude<ExtArgs> | null
    /**
     * Filter, which VerificationCode to fetch.
     */
    where?: VerificationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationCodes to fetch.
     */
    orderBy?: VerificationCodeOrderByWithRelationInput | VerificationCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationCodes.
     */
    cursor?: VerificationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationCodes.
     */
    distinct?: VerificationCodeScalarFieldEnum | VerificationCodeScalarFieldEnum[]
  }

  /**
   * VerificationCode findFirstOrThrow
   */
  export type VerificationCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeInclude<ExtArgs> | null
    /**
     * Filter, which VerificationCode to fetch.
     */
    where?: VerificationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationCodes to fetch.
     */
    orderBy?: VerificationCodeOrderByWithRelationInput | VerificationCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationCodes.
     */
    cursor?: VerificationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationCodes.
     */
    distinct?: VerificationCodeScalarFieldEnum | VerificationCodeScalarFieldEnum[]
  }

  /**
   * VerificationCode findMany
   */
  export type VerificationCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeInclude<ExtArgs> | null
    /**
     * Filter, which VerificationCodes to fetch.
     */
    where?: VerificationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationCodes to fetch.
     */
    orderBy?: VerificationCodeOrderByWithRelationInput | VerificationCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationCodes.
     */
    cursor?: VerificationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationCodes.
     */
    skip?: number
    distinct?: VerificationCodeScalarFieldEnum | VerificationCodeScalarFieldEnum[]
  }

  /**
   * VerificationCode create
   */
  export type VerificationCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a VerificationCode.
     */
    data: XOR<VerificationCodeCreateInput, VerificationCodeUncheckedCreateInput>
  }

  /**
   * VerificationCode createMany
   */
  export type VerificationCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationCodes.
     */
    data: VerificationCodeCreateManyInput | VerificationCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationCode createManyAndReturn
   */
  export type VerificationCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationCodes.
     */
    data: VerificationCodeCreateManyInput | VerificationCodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerificationCode update
   */
  export type VerificationCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a VerificationCode.
     */
    data: XOR<VerificationCodeUpdateInput, VerificationCodeUncheckedUpdateInput>
    /**
     * Choose, which VerificationCode to update.
     */
    where: VerificationCodeWhereUniqueInput
  }

  /**
   * VerificationCode updateMany
   */
  export type VerificationCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationCodes.
     */
    data: XOR<VerificationCodeUpdateManyMutationInput, VerificationCodeUncheckedUpdateManyInput>
    /**
     * Filter which VerificationCodes to update
     */
    where?: VerificationCodeWhereInput
    /**
     * Limit how many VerificationCodes to update.
     */
    limit?: number
  }

  /**
   * VerificationCode updateManyAndReturn
   */
  export type VerificationCodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * The data used to update VerificationCodes.
     */
    data: XOR<VerificationCodeUpdateManyMutationInput, VerificationCodeUncheckedUpdateManyInput>
    /**
     * Filter which VerificationCodes to update
     */
    where?: VerificationCodeWhereInput
    /**
     * Limit how many VerificationCodes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerificationCode upsert
   */
  export type VerificationCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the VerificationCode to update in case it exists.
     */
    where: VerificationCodeWhereUniqueInput
    /**
     * In case the VerificationCode found by the `where` argument doesn't exist, create a new VerificationCode with this data.
     */
    create: XOR<VerificationCodeCreateInput, VerificationCodeUncheckedCreateInput>
    /**
     * In case the VerificationCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationCodeUpdateInput, VerificationCodeUncheckedUpdateInput>
  }

  /**
   * VerificationCode delete
   */
  export type VerificationCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeInclude<ExtArgs> | null
    /**
     * Filter which VerificationCode to delete.
     */
    where: VerificationCodeWhereUniqueInput
  }

  /**
   * VerificationCode deleteMany
   */
  export type VerificationCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationCodes to delete
     */
    where?: VerificationCodeWhereInput
    /**
     * Limit how many VerificationCodes to delete.
     */
    limit?: number
  }

  /**
   * VerificationCode without action
   */
  export type VerificationCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number | null
  }

  export type RoleSumAggregateOutputType = {
    id: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    permissions?: boolean | Role$permissionsArgs<ExtArgs>
    users?: boolean | Role$usersArgs<ExtArgs>
    roleUsers?: boolean | Role$roleUsersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | Role$permissionsArgs<ExtArgs>
    users?: boolean | Role$usersArgs<ExtArgs>
    roleUsers?: boolean | Role$roleUsersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      permissions: Prisma.$RolePermissionPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      roleUsers: Prisma.$RoleUserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permissions<T extends Role$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, Role$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roleUsers<T extends Role$roleUsersArgs<ExtArgs> = {}>(args?: Subset<T, Role$roleUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'Int'>
    readonly name: FieldRef<"Role", 'String'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.permissions
   */
  export type Role$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Role.roleUsers
   */
  export type Role$roleUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleUser
     */
    select?: RoleUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleUser
     */
    omit?: RoleUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleUserInclude<ExtArgs> | null
    where?: RoleUserWhereInput
    orderBy?: RoleUserOrderByWithRelationInput | RoleUserOrderByWithRelationInput[]
    cursor?: RoleUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleUserScalarFieldEnum | RoleUserScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model RolePermission
   */

  export type AggregateRolePermission = {
    _count: RolePermissionCountAggregateOutputType | null
    _avg: RolePermissionAvgAggregateOutputType | null
    _sum: RolePermissionSumAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  export type RolePermissionAvgAggregateOutputType = {
    id: number | null
    roleId: number | null
    permissionId: number | null
  }

  export type RolePermissionSumAggregateOutputType = {
    id: number | null
    roleId: number | null
    permissionId: number | null
  }

  export type RolePermissionMinAggregateOutputType = {
    id: number | null
    roleId: number | null
    permissionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RolePermissionMaxAggregateOutputType = {
    id: number | null
    roleId: number | null
    permissionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RolePermissionCountAggregateOutputType = {
    id: number
    roleId: number
    permissionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RolePermissionAvgAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
  }

  export type RolePermissionSumAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
  }

  export type RolePermissionMinAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RolePermissionMaxAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RolePermissionCountAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RolePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermission to aggregate.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolePermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolePermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionMaxAggregateInputType
  }

  export type GetRolePermissionAggregateType<T extends RolePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermission[P]>
      : GetScalarType<T[P], AggregateRolePermission[P]>
  }




  export type RolePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithAggregationInput | RolePermissionOrderByWithAggregationInput[]
    by: RolePermissionScalarFieldEnum[] | RolePermissionScalarFieldEnum
    having?: RolePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionCountAggregateInputType | true
    _avg?: RolePermissionAvgAggregateInputType
    _sum?: RolePermissionSumAggregateInputType
    _min?: RolePermissionMinAggregateInputType
    _max?: RolePermissionMaxAggregateInputType
  }

  export type RolePermissionGroupByOutputType = {
    id: number
    roleId: number
    permissionId: number
    createdAt: Date
    updatedAt: Date
    _count: RolePermissionCountAggregateOutputType | null
    _avg: RolePermissionAvgAggregateOutputType | null
    _sum: RolePermissionSumAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  type GetRolePermissionGroupByPayload<T extends RolePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectScalar = {
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RolePermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roleId" | "permissionId" | "createdAt" | "updatedAt", ExtArgs["result"]["rolePermission"]>
  export type RolePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }
  export type RolePermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }
  export type RolePermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }

  export type $RolePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePermission"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      permission: Prisma.$PermissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      roleId: number
      permissionId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rolePermission"]>
    composites: {}
  }

  type RolePermissionGetPayload<S extends boolean | null | undefined | RolePermissionDefaultArgs> = $Result.GetResult<Prisma.$RolePermissionPayload, S>

  type RolePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolePermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolePermissionCountAggregateInputType | true
    }

  export interface RolePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePermission'], meta: { name: 'RolePermission' } }
    /**
     * Find zero or one RolePermission that matches the filter.
     * @param {RolePermissionFindUniqueArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePermissionFindUniqueArgs>(args: SelectSubset<T, RolePermissionFindUniqueArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RolePermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolePermissionFindUniqueOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePermissionFindFirstArgs>(args?: SelectSubset<T, RolePermissionFindFirstArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolePermissionFindManyArgs>(args?: SelectSubset<T, RolePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RolePermission.
     * @param {RolePermissionCreateArgs} args - Arguments to create a RolePermission.
     * @example
     * // Create one RolePermission
     * const RolePermission = await prisma.rolePermission.create({
     *   data: {
     *     // ... data to create a RolePermission
     *   }
     * })
     * 
     */
    create<T extends RolePermissionCreateArgs>(args: SelectSubset<T, RolePermissionCreateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RolePermissions.
     * @param {RolePermissionCreateManyArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePermissionCreateManyArgs>(args?: SelectSubset<T, RolePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RolePermissions and returns the data saved in the database.
     * @param {RolePermissionCreateManyAndReturnArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RolePermissions and only return the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolePermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, RolePermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RolePermission.
     * @param {RolePermissionDeleteArgs} args - Arguments to delete one RolePermission.
     * @example
     * // Delete one RolePermission
     * const RolePermission = await prisma.rolePermission.delete({
     *   where: {
     *     // ... filter to delete one RolePermission
     *   }
     * })
     * 
     */
    delete<T extends RolePermissionDeleteArgs>(args: SelectSubset<T, RolePermissionDeleteArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RolePermission.
     * @param {RolePermissionUpdateArgs} args - Arguments to update one RolePermission.
     * @example
     * // Update one RolePermission
     * const rolePermission = await prisma.rolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePermissionUpdateArgs>(args: SelectSubset<T, RolePermissionUpdateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePermissionDeleteManyArgs>(args?: SelectSubset<T, RolePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePermissionUpdateManyArgs>(args: SelectSubset<T, RolePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions and returns the data updated in the database.
     * @param {RolePermissionUpdateManyAndReturnArgs} args - Arguments to update many RolePermissions.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RolePermissions and only return the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RolePermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, RolePermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RolePermission.
     * @param {RolePermissionUpsertArgs} args - Arguments to update or create a RolePermission.
     * @example
     * // Update or create a RolePermission
     * const rolePermission = await prisma.rolePermission.upsert({
     *   create: {
     *     // ... data to create a RolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermission we want to update
     *   }
     * })
     */
    upsert<T extends RolePermissionUpsertArgs>(args: SelectSubset<T, RolePermissionUpsertArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermission.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionCountArgs>(
      args?: Subset<T, RolePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionAggregateArgs>(args: Subset<T, RolePermissionAggregateArgs>): Prisma.PrismaPromise<GetRolePermissionAggregateType<T>>

    /**
     * Group by RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePermission model
   */
  readonly fields: RolePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    permission<T extends PermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermissionDefaultArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePermission model
   */
  interface RolePermissionFieldRefs {
    readonly id: FieldRef<"RolePermission", 'Int'>
    readonly roleId: FieldRef<"RolePermission", 'Int'>
    readonly permissionId: FieldRef<"RolePermission", 'Int'>
    readonly createdAt: FieldRef<"RolePermission", 'DateTime'>
    readonly updatedAt: FieldRef<"RolePermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RolePermission findUnique
   */
  export type RolePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findUniqueOrThrow
   */
  export type RolePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findFirst
   */
  export type RolePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findFirstOrThrow
   */
  export type RolePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findMany
   */
  export type RolePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission create
   */
  export type RolePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a RolePermission.
     */
    data: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
  }

  /**
   * RolePermission createMany
   */
  export type RolePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolePermission createManyAndReturn
   */
  export type RolePermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePermission update
   */
  export type RolePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a RolePermission.
     */
    data: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
    /**
     * Choose, which RolePermission to update.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission updateMany
   */
  export type RolePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to update.
     */
    limit?: number
  }

  /**
   * RolePermission updateManyAndReturn
   */
  export type RolePermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePermission upsert
   */
  export type RolePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the RolePermission to update in case it exists.
     */
    where: RolePermissionWhereUniqueInput
    /**
     * In case the RolePermission found by the `where` argument doesn't exist, create a new RolePermission with this data.
     */
    create: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
    /**
     * In case the RolePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
  }

  /**
   * RolePermission delete
   */
  export type RolePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter which RolePermission to delete.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission deleteMany
   */
  export type RolePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissions to delete
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to delete.
     */
    limit?: number
  }

  /**
   * RolePermission without action
   */
  export type RolePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    roleId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    roleId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    screenName: string | null
    phoneNumber: string | null
    dateOfBirth: string | null
    address: string | null
    roleId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    screenName: string | null
    phoneNumber: string | null
    dateOfBirth: string | null
    address: string | null
    roleId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    firstName: number
    lastName: number
    screenName: number
    phoneNumber: number
    dateOfBirth: number
    address: number
    roleId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    roleId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    roleId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    screenName?: true
    phoneNumber?: true
    dateOfBirth?: true
    address?: true
    roleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    screenName?: true
    phoneNumber?: true
    dateOfBirth?: true
    address?: true
    roleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    screenName?: true
    phoneNumber?: true
    dateOfBirth?: true
    address?: true
    roleId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    firstName: string
    lastName: string
    screenName: string | null
    phoneNumber: string
    dateOfBirth: string | null
    address: string | null
    roleId: number
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    screenName?: boolean
    phoneNumber?: boolean
    dateOfBirth?: boolean
    address?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    roleUsers?: boolean | User$roleUsersArgs<ExtArgs>
    individualProfessional?: boolean | User$individualProfessionalArgs<ExtArgs>
    client?: boolean | User$clientArgs<ExtArgs>
    securityCompany?: boolean | User$securityCompanyArgs<ExtArgs>
    courseProvider?: boolean | User$courseProviderArgs<ExtArgs>
    corporateClient?: boolean | User$corporateClientArgs<ExtArgs>
    VerificationCode?: boolean | User$VerificationCodeArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    screenName?: boolean
    phoneNumber?: boolean
    dateOfBirth?: boolean
    address?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    screenName?: boolean
    phoneNumber?: boolean
    dateOfBirth?: boolean
    address?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    screenName?: boolean
    phoneNumber?: boolean
    dateOfBirth?: boolean
    address?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "firstName" | "lastName" | "screenName" | "phoneNumber" | "dateOfBirth" | "address" | "roleId" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    roleUsers?: boolean | User$roleUsersArgs<ExtArgs>
    individualProfessional?: boolean | User$individualProfessionalArgs<ExtArgs>
    client?: boolean | User$clientArgs<ExtArgs>
    securityCompany?: boolean | User$securityCompanyArgs<ExtArgs>
    courseProvider?: boolean | User$courseProviderArgs<ExtArgs>
    corporateClient?: boolean | User$corporateClientArgs<ExtArgs>
    VerificationCode?: boolean | User$VerificationCodeArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      roleUsers: Prisma.$RoleUserPayload<ExtArgs>[]
      individualProfessional: Prisma.$IndividualProfessionalPayload<ExtArgs> | null
      client: Prisma.$ClientPayload<ExtArgs> | null
      securityCompany: Prisma.$SecurityCompanyPayload<ExtArgs> | null
      courseProvider: Prisma.$CourseProviderPayload<ExtArgs> | null
      corporateClient: Prisma.$CorporateClientPayload<ExtArgs> | null
      VerificationCode: Prisma.$VerificationCodePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      firstName: string
      lastName: string
      screenName: string | null
      phoneNumber: string
      dateOfBirth: string | null
      address: string | null
      roleId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    roleUsers<T extends User$roleUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$roleUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    individualProfessional<T extends User$individualProfessionalArgs<ExtArgs> = {}>(args?: Subset<T, User$individualProfessionalArgs<ExtArgs>>): Prisma__IndividualProfessionalClient<$Result.GetResult<Prisma.$IndividualProfessionalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    client<T extends User$clientArgs<ExtArgs> = {}>(args?: Subset<T, User$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    securityCompany<T extends User$securityCompanyArgs<ExtArgs> = {}>(args?: Subset<T, User$securityCompanyArgs<ExtArgs>>): Prisma__SecurityCompanyClient<$Result.GetResult<Prisma.$SecurityCompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    courseProvider<T extends User$courseProviderArgs<ExtArgs> = {}>(args?: Subset<T, User$courseProviderArgs<ExtArgs>>): Prisma__CourseProviderClient<$Result.GetResult<Prisma.$CourseProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    corporateClient<T extends User$corporateClientArgs<ExtArgs> = {}>(args?: Subset<T, User$corporateClientArgs<ExtArgs>>): Prisma__CorporateClientClient<$Result.GetResult<Prisma.$CorporateClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    VerificationCode<T extends User$VerificationCodeArgs<ExtArgs> = {}>(args?: Subset<T, User$VerificationCodeArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly screenName: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly dateOfBirth: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly roleId: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.roleUsers
   */
  export type User$roleUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleUser
     */
    select?: RoleUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleUser
     */
    omit?: RoleUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleUserInclude<ExtArgs> | null
    where?: RoleUserWhereInput
    orderBy?: RoleUserOrderByWithRelationInput | RoleUserOrderByWithRelationInput[]
    cursor?: RoleUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleUserScalarFieldEnum | RoleUserScalarFieldEnum[]
  }

  /**
   * User.individualProfessional
   */
  export type User$individualProfessionalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndividualProfessional
     */
    select?: IndividualProfessionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndividualProfessional
     */
    omit?: IndividualProfessionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualProfessionalInclude<ExtArgs> | null
    where?: IndividualProfessionalWhereInput
  }

  /**
   * User.client
   */
  export type User$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * User.securityCompany
   */
  export type User$securityCompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityCompany
     */
    select?: SecurityCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityCompany
     */
    omit?: SecurityCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityCompanyInclude<ExtArgs> | null
    where?: SecurityCompanyWhereInput
  }

  /**
   * User.courseProvider
   */
  export type User$courseProviderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProvider
     */
    select?: CourseProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseProvider
     */
    omit?: CourseProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProviderInclude<ExtArgs> | null
    where?: CourseProviderWhereInput
  }

  /**
   * User.corporateClient
   */
  export type User$corporateClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateClient
     */
    select?: CorporateClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorporateClient
     */
    omit?: CorporateClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateClientInclude<ExtArgs> | null
    where?: CorporateClientWhereInput
  }

  /**
   * User.VerificationCode
   */
  export type User$VerificationCodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeInclude<ExtArgs> | null
    where?: VerificationCodeWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model IndividualProfessional
   */

  export type AggregateIndividualProfessional = {
    _count: IndividualProfessionalCountAggregateOutputType | null
    _avg: IndividualProfessionalAvgAggregateOutputType | null
    _sum: IndividualProfessionalSumAggregateOutputType | null
    _min: IndividualProfessionalMinAggregateOutputType | null
    _max: IndividualProfessionalMaxAggregateOutputType | null
  }

  export type IndividualProfessionalAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type IndividualProfessionalSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type IndividualProfessionalMinAggregateOutputType = {
    id: number | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IndividualProfessionalMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IndividualProfessionalCountAggregateOutputType = {
    id: number
    userId: number
    profileData: number
    permissions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IndividualProfessionalAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type IndividualProfessionalSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type IndividualProfessionalMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IndividualProfessionalMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IndividualProfessionalCountAggregateInputType = {
    id?: true
    userId?: true
    profileData?: true
    permissions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IndividualProfessionalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IndividualProfessional to aggregate.
     */
    where?: IndividualProfessionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndividualProfessionals to fetch.
     */
    orderBy?: IndividualProfessionalOrderByWithRelationInput | IndividualProfessionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IndividualProfessionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndividualProfessionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndividualProfessionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IndividualProfessionals
    **/
    _count?: true | IndividualProfessionalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IndividualProfessionalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IndividualProfessionalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IndividualProfessionalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IndividualProfessionalMaxAggregateInputType
  }

  export type GetIndividualProfessionalAggregateType<T extends IndividualProfessionalAggregateArgs> = {
        [P in keyof T & keyof AggregateIndividualProfessional]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndividualProfessional[P]>
      : GetScalarType<T[P], AggregateIndividualProfessional[P]>
  }




  export type IndividualProfessionalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndividualProfessionalWhereInput
    orderBy?: IndividualProfessionalOrderByWithAggregationInput | IndividualProfessionalOrderByWithAggregationInput[]
    by: IndividualProfessionalScalarFieldEnum[] | IndividualProfessionalScalarFieldEnum
    having?: IndividualProfessionalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IndividualProfessionalCountAggregateInputType | true
    _avg?: IndividualProfessionalAvgAggregateInputType
    _sum?: IndividualProfessionalSumAggregateInputType
    _min?: IndividualProfessionalMinAggregateInputType
    _max?: IndividualProfessionalMaxAggregateInputType
  }

  export type IndividualProfessionalGroupByOutputType = {
    id: number
    userId: number
    profileData: JsonValue
    permissions: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: IndividualProfessionalCountAggregateOutputType | null
    _avg: IndividualProfessionalAvgAggregateOutputType | null
    _sum: IndividualProfessionalSumAggregateOutputType | null
    _min: IndividualProfessionalMinAggregateOutputType | null
    _max: IndividualProfessionalMaxAggregateOutputType | null
  }

  type GetIndividualProfessionalGroupByPayload<T extends IndividualProfessionalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IndividualProfessionalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IndividualProfessionalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IndividualProfessionalGroupByOutputType[P]>
            : GetScalarType<T[P], IndividualProfessionalGroupByOutputType[P]>
        }
      >
    >


  export type IndividualProfessionalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    profileData?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["individualProfessional"]>

  export type IndividualProfessionalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    profileData?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["individualProfessional"]>

  export type IndividualProfessionalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    profileData?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["individualProfessional"]>

  export type IndividualProfessionalSelectScalar = {
    id?: boolean
    userId?: boolean
    profileData?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IndividualProfessionalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "profileData" | "permissions" | "createdAt" | "updatedAt", ExtArgs["result"]["individualProfessional"]>
  export type IndividualProfessionalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type IndividualProfessionalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type IndividualProfessionalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $IndividualProfessionalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IndividualProfessional"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      profileData: Prisma.JsonValue
      permissions: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["individualProfessional"]>
    composites: {}
  }

  type IndividualProfessionalGetPayload<S extends boolean | null | undefined | IndividualProfessionalDefaultArgs> = $Result.GetResult<Prisma.$IndividualProfessionalPayload, S>

  type IndividualProfessionalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IndividualProfessionalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IndividualProfessionalCountAggregateInputType | true
    }

  export interface IndividualProfessionalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IndividualProfessional'], meta: { name: 'IndividualProfessional' } }
    /**
     * Find zero or one IndividualProfessional that matches the filter.
     * @param {IndividualProfessionalFindUniqueArgs} args - Arguments to find a IndividualProfessional
     * @example
     * // Get one IndividualProfessional
     * const individualProfessional = await prisma.individualProfessional.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IndividualProfessionalFindUniqueArgs>(args: SelectSubset<T, IndividualProfessionalFindUniqueArgs<ExtArgs>>): Prisma__IndividualProfessionalClient<$Result.GetResult<Prisma.$IndividualProfessionalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IndividualProfessional that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IndividualProfessionalFindUniqueOrThrowArgs} args - Arguments to find a IndividualProfessional
     * @example
     * // Get one IndividualProfessional
     * const individualProfessional = await prisma.individualProfessional.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IndividualProfessionalFindUniqueOrThrowArgs>(args: SelectSubset<T, IndividualProfessionalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IndividualProfessionalClient<$Result.GetResult<Prisma.$IndividualProfessionalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IndividualProfessional that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualProfessionalFindFirstArgs} args - Arguments to find a IndividualProfessional
     * @example
     * // Get one IndividualProfessional
     * const individualProfessional = await prisma.individualProfessional.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IndividualProfessionalFindFirstArgs>(args?: SelectSubset<T, IndividualProfessionalFindFirstArgs<ExtArgs>>): Prisma__IndividualProfessionalClient<$Result.GetResult<Prisma.$IndividualProfessionalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IndividualProfessional that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualProfessionalFindFirstOrThrowArgs} args - Arguments to find a IndividualProfessional
     * @example
     * // Get one IndividualProfessional
     * const individualProfessional = await prisma.individualProfessional.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IndividualProfessionalFindFirstOrThrowArgs>(args?: SelectSubset<T, IndividualProfessionalFindFirstOrThrowArgs<ExtArgs>>): Prisma__IndividualProfessionalClient<$Result.GetResult<Prisma.$IndividualProfessionalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IndividualProfessionals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualProfessionalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IndividualProfessionals
     * const individualProfessionals = await prisma.individualProfessional.findMany()
     * 
     * // Get first 10 IndividualProfessionals
     * const individualProfessionals = await prisma.individualProfessional.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const individualProfessionalWithIdOnly = await prisma.individualProfessional.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IndividualProfessionalFindManyArgs>(args?: SelectSubset<T, IndividualProfessionalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndividualProfessionalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IndividualProfessional.
     * @param {IndividualProfessionalCreateArgs} args - Arguments to create a IndividualProfessional.
     * @example
     * // Create one IndividualProfessional
     * const IndividualProfessional = await prisma.individualProfessional.create({
     *   data: {
     *     // ... data to create a IndividualProfessional
     *   }
     * })
     * 
     */
    create<T extends IndividualProfessionalCreateArgs>(args: SelectSubset<T, IndividualProfessionalCreateArgs<ExtArgs>>): Prisma__IndividualProfessionalClient<$Result.GetResult<Prisma.$IndividualProfessionalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IndividualProfessionals.
     * @param {IndividualProfessionalCreateManyArgs} args - Arguments to create many IndividualProfessionals.
     * @example
     * // Create many IndividualProfessionals
     * const individualProfessional = await prisma.individualProfessional.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IndividualProfessionalCreateManyArgs>(args?: SelectSubset<T, IndividualProfessionalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IndividualProfessionals and returns the data saved in the database.
     * @param {IndividualProfessionalCreateManyAndReturnArgs} args - Arguments to create many IndividualProfessionals.
     * @example
     * // Create many IndividualProfessionals
     * const individualProfessional = await prisma.individualProfessional.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IndividualProfessionals and only return the `id`
     * const individualProfessionalWithIdOnly = await prisma.individualProfessional.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IndividualProfessionalCreateManyAndReturnArgs>(args?: SelectSubset<T, IndividualProfessionalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndividualProfessionalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IndividualProfessional.
     * @param {IndividualProfessionalDeleteArgs} args - Arguments to delete one IndividualProfessional.
     * @example
     * // Delete one IndividualProfessional
     * const IndividualProfessional = await prisma.individualProfessional.delete({
     *   where: {
     *     // ... filter to delete one IndividualProfessional
     *   }
     * })
     * 
     */
    delete<T extends IndividualProfessionalDeleteArgs>(args: SelectSubset<T, IndividualProfessionalDeleteArgs<ExtArgs>>): Prisma__IndividualProfessionalClient<$Result.GetResult<Prisma.$IndividualProfessionalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IndividualProfessional.
     * @param {IndividualProfessionalUpdateArgs} args - Arguments to update one IndividualProfessional.
     * @example
     * // Update one IndividualProfessional
     * const individualProfessional = await prisma.individualProfessional.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IndividualProfessionalUpdateArgs>(args: SelectSubset<T, IndividualProfessionalUpdateArgs<ExtArgs>>): Prisma__IndividualProfessionalClient<$Result.GetResult<Prisma.$IndividualProfessionalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IndividualProfessionals.
     * @param {IndividualProfessionalDeleteManyArgs} args - Arguments to filter IndividualProfessionals to delete.
     * @example
     * // Delete a few IndividualProfessionals
     * const { count } = await prisma.individualProfessional.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IndividualProfessionalDeleteManyArgs>(args?: SelectSubset<T, IndividualProfessionalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IndividualProfessionals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualProfessionalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IndividualProfessionals
     * const individualProfessional = await prisma.individualProfessional.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IndividualProfessionalUpdateManyArgs>(args: SelectSubset<T, IndividualProfessionalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IndividualProfessionals and returns the data updated in the database.
     * @param {IndividualProfessionalUpdateManyAndReturnArgs} args - Arguments to update many IndividualProfessionals.
     * @example
     * // Update many IndividualProfessionals
     * const individualProfessional = await prisma.individualProfessional.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IndividualProfessionals and only return the `id`
     * const individualProfessionalWithIdOnly = await prisma.individualProfessional.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IndividualProfessionalUpdateManyAndReturnArgs>(args: SelectSubset<T, IndividualProfessionalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndividualProfessionalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IndividualProfessional.
     * @param {IndividualProfessionalUpsertArgs} args - Arguments to update or create a IndividualProfessional.
     * @example
     * // Update or create a IndividualProfessional
     * const individualProfessional = await prisma.individualProfessional.upsert({
     *   create: {
     *     // ... data to create a IndividualProfessional
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IndividualProfessional we want to update
     *   }
     * })
     */
    upsert<T extends IndividualProfessionalUpsertArgs>(args: SelectSubset<T, IndividualProfessionalUpsertArgs<ExtArgs>>): Prisma__IndividualProfessionalClient<$Result.GetResult<Prisma.$IndividualProfessionalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IndividualProfessionals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualProfessionalCountArgs} args - Arguments to filter IndividualProfessionals to count.
     * @example
     * // Count the number of IndividualProfessionals
     * const count = await prisma.individualProfessional.count({
     *   where: {
     *     // ... the filter for the IndividualProfessionals we want to count
     *   }
     * })
    **/
    count<T extends IndividualProfessionalCountArgs>(
      args?: Subset<T, IndividualProfessionalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IndividualProfessionalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IndividualProfessional.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualProfessionalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IndividualProfessionalAggregateArgs>(args: Subset<T, IndividualProfessionalAggregateArgs>): Prisma.PrismaPromise<GetIndividualProfessionalAggregateType<T>>

    /**
     * Group by IndividualProfessional.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualProfessionalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IndividualProfessionalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IndividualProfessionalGroupByArgs['orderBy'] }
        : { orderBy?: IndividualProfessionalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IndividualProfessionalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIndividualProfessionalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IndividualProfessional model
   */
  readonly fields: IndividualProfessionalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IndividualProfessional.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IndividualProfessionalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IndividualProfessional model
   */
  interface IndividualProfessionalFieldRefs {
    readonly id: FieldRef<"IndividualProfessional", 'Int'>
    readonly userId: FieldRef<"IndividualProfessional", 'Int'>
    readonly profileData: FieldRef<"IndividualProfessional", 'Json'>
    readonly permissions: FieldRef<"IndividualProfessional", 'Json'>
    readonly createdAt: FieldRef<"IndividualProfessional", 'DateTime'>
    readonly updatedAt: FieldRef<"IndividualProfessional", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IndividualProfessional findUnique
   */
  export type IndividualProfessionalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndividualProfessional
     */
    select?: IndividualProfessionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndividualProfessional
     */
    omit?: IndividualProfessionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualProfessionalInclude<ExtArgs> | null
    /**
     * Filter, which IndividualProfessional to fetch.
     */
    where: IndividualProfessionalWhereUniqueInput
  }

  /**
   * IndividualProfessional findUniqueOrThrow
   */
  export type IndividualProfessionalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndividualProfessional
     */
    select?: IndividualProfessionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndividualProfessional
     */
    omit?: IndividualProfessionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualProfessionalInclude<ExtArgs> | null
    /**
     * Filter, which IndividualProfessional to fetch.
     */
    where: IndividualProfessionalWhereUniqueInput
  }

  /**
   * IndividualProfessional findFirst
   */
  export type IndividualProfessionalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndividualProfessional
     */
    select?: IndividualProfessionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndividualProfessional
     */
    omit?: IndividualProfessionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualProfessionalInclude<ExtArgs> | null
    /**
     * Filter, which IndividualProfessional to fetch.
     */
    where?: IndividualProfessionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndividualProfessionals to fetch.
     */
    orderBy?: IndividualProfessionalOrderByWithRelationInput | IndividualProfessionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IndividualProfessionals.
     */
    cursor?: IndividualProfessionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndividualProfessionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndividualProfessionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IndividualProfessionals.
     */
    distinct?: IndividualProfessionalScalarFieldEnum | IndividualProfessionalScalarFieldEnum[]
  }

  /**
   * IndividualProfessional findFirstOrThrow
   */
  export type IndividualProfessionalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndividualProfessional
     */
    select?: IndividualProfessionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndividualProfessional
     */
    omit?: IndividualProfessionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualProfessionalInclude<ExtArgs> | null
    /**
     * Filter, which IndividualProfessional to fetch.
     */
    where?: IndividualProfessionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndividualProfessionals to fetch.
     */
    orderBy?: IndividualProfessionalOrderByWithRelationInput | IndividualProfessionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IndividualProfessionals.
     */
    cursor?: IndividualProfessionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndividualProfessionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndividualProfessionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IndividualProfessionals.
     */
    distinct?: IndividualProfessionalScalarFieldEnum | IndividualProfessionalScalarFieldEnum[]
  }

  /**
   * IndividualProfessional findMany
   */
  export type IndividualProfessionalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndividualProfessional
     */
    select?: IndividualProfessionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndividualProfessional
     */
    omit?: IndividualProfessionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualProfessionalInclude<ExtArgs> | null
    /**
     * Filter, which IndividualProfessionals to fetch.
     */
    where?: IndividualProfessionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndividualProfessionals to fetch.
     */
    orderBy?: IndividualProfessionalOrderByWithRelationInput | IndividualProfessionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IndividualProfessionals.
     */
    cursor?: IndividualProfessionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndividualProfessionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndividualProfessionals.
     */
    skip?: number
    distinct?: IndividualProfessionalScalarFieldEnum | IndividualProfessionalScalarFieldEnum[]
  }

  /**
   * IndividualProfessional create
   */
  export type IndividualProfessionalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndividualProfessional
     */
    select?: IndividualProfessionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndividualProfessional
     */
    omit?: IndividualProfessionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualProfessionalInclude<ExtArgs> | null
    /**
     * The data needed to create a IndividualProfessional.
     */
    data: XOR<IndividualProfessionalCreateInput, IndividualProfessionalUncheckedCreateInput>
  }

  /**
   * IndividualProfessional createMany
   */
  export type IndividualProfessionalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IndividualProfessionals.
     */
    data: IndividualProfessionalCreateManyInput | IndividualProfessionalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IndividualProfessional createManyAndReturn
   */
  export type IndividualProfessionalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndividualProfessional
     */
    select?: IndividualProfessionalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IndividualProfessional
     */
    omit?: IndividualProfessionalOmit<ExtArgs> | null
    /**
     * The data used to create many IndividualProfessionals.
     */
    data: IndividualProfessionalCreateManyInput | IndividualProfessionalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualProfessionalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IndividualProfessional update
   */
  export type IndividualProfessionalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndividualProfessional
     */
    select?: IndividualProfessionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndividualProfessional
     */
    omit?: IndividualProfessionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualProfessionalInclude<ExtArgs> | null
    /**
     * The data needed to update a IndividualProfessional.
     */
    data: XOR<IndividualProfessionalUpdateInput, IndividualProfessionalUncheckedUpdateInput>
    /**
     * Choose, which IndividualProfessional to update.
     */
    where: IndividualProfessionalWhereUniqueInput
  }

  /**
   * IndividualProfessional updateMany
   */
  export type IndividualProfessionalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IndividualProfessionals.
     */
    data: XOR<IndividualProfessionalUpdateManyMutationInput, IndividualProfessionalUncheckedUpdateManyInput>
    /**
     * Filter which IndividualProfessionals to update
     */
    where?: IndividualProfessionalWhereInput
    /**
     * Limit how many IndividualProfessionals to update.
     */
    limit?: number
  }

  /**
   * IndividualProfessional updateManyAndReturn
   */
  export type IndividualProfessionalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndividualProfessional
     */
    select?: IndividualProfessionalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IndividualProfessional
     */
    omit?: IndividualProfessionalOmit<ExtArgs> | null
    /**
     * The data used to update IndividualProfessionals.
     */
    data: XOR<IndividualProfessionalUpdateManyMutationInput, IndividualProfessionalUncheckedUpdateManyInput>
    /**
     * Filter which IndividualProfessionals to update
     */
    where?: IndividualProfessionalWhereInput
    /**
     * Limit how many IndividualProfessionals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualProfessionalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * IndividualProfessional upsert
   */
  export type IndividualProfessionalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndividualProfessional
     */
    select?: IndividualProfessionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndividualProfessional
     */
    omit?: IndividualProfessionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualProfessionalInclude<ExtArgs> | null
    /**
     * The filter to search for the IndividualProfessional to update in case it exists.
     */
    where: IndividualProfessionalWhereUniqueInput
    /**
     * In case the IndividualProfessional found by the `where` argument doesn't exist, create a new IndividualProfessional with this data.
     */
    create: XOR<IndividualProfessionalCreateInput, IndividualProfessionalUncheckedCreateInput>
    /**
     * In case the IndividualProfessional was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IndividualProfessionalUpdateInput, IndividualProfessionalUncheckedUpdateInput>
  }

  /**
   * IndividualProfessional delete
   */
  export type IndividualProfessionalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndividualProfessional
     */
    select?: IndividualProfessionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndividualProfessional
     */
    omit?: IndividualProfessionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualProfessionalInclude<ExtArgs> | null
    /**
     * Filter which IndividualProfessional to delete.
     */
    where: IndividualProfessionalWhereUniqueInput
  }

  /**
   * IndividualProfessional deleteMany
   */
  export type IndividualProfessionalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IndividualProfessionals to delete
     */
    where?: IndividualProfessionalWhereInput
    /**
     * Limit how many IndividualProfessionals to delete.
     */
    limit?: number
  }

  /**
   * IndividualProfessional without action
   */
  export type IndividualProfessionalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndividualProfessional
     */
    select?: IndividualProfessionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndividualProfessional
     */
    omit?: IndividualProfessionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualProfessionalInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ClientSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ClientMinAggregateOutputType = {
    id: number | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    userId: number
    permissions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ClientSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ClientMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    userId?: true
    permissions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _avg?: ClientAvgAggregateInputType
    _sum?: ClientSumAggregateInputType
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: number
    userId: number
    permissions: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    ads?: boolean | Client$adsArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    userId?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "permissions" | "createdAt" | "updatedAt", ExtArgs["result"]["client"]>
  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    ads?: boolean | Client$adsArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      ads: Prisma.$ClientAdPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      permissions: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {ClientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients and returns the data updated in the database.
     * @param {ClientUpdateManyAndReturnArgs} args - Arguments to update many Clients.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ads<T extends Client$adsArgs<ExtArgs> = {}>(args?: Subset<T, Client$adsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientAdPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'Int'>
    readonly userId: FieldRef<"Client", 'Int'>
    readonly permissions: FieldRef<"Client", 'Json'>
    readonly createdAt: FieldRef<"Client", 'DateTime'>
    readonly updatedAt: FieldRef<"Client", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client createManyAndReturn
   */
  export type ClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client updateManyAndReturn
   */
  export type ClientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to delete.
     */
    limit?: number
  }

  /**
   * Client.ads
   */
  export type Client$adsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAd
     */
    select?: ClientAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAd
     */
    omit?: ClientAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAdInclude<ExtArgs> | null
    where?: ClientAdWhereInput
    orderBy?: ClientAdOrderByWithRelationInput | ClientAdOrderByWithRelationInput[]
    cursor?: ClientAdWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientAdScalarFieldEnum | ClientAdScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model SecurityCompany
   */

  export type AggregateSecurityCompany = {
    _count: SecurityCompanyCountAggregateOutputType | null
    _avg: SecurityCompanyAvgAggregateOutputType | null
    _sum: SecurityCompanySumAggregateOutputType | null
    _min: SecurityCompanyMinAggregateOutputType | null
    _max: SecurityCompanyMaxAggregateOutputType | null
  }

  export type SecurityCompanyAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SecurityCompanySumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SecurityCompanyMinAggregateOutputType = {
    id: number | null
    userId: number | null
    companyName: string | null
    registrationNumber: string | null
    address: string | null
    postCode: string | null
    contactPerson: string | null
    jobTitle: string | null
    phoneNumber: string | null
    website: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SecurityCompanyMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    companyName: string | null
    registrationNumber: string | null
    address: string | null
    postCode: string | null
    contactPerson: string | null
    jobTitle: string | null
    phoneNumber: string | null
    website: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SecurityCompanyCountAggregateOutputType = {
    id: number
    userId: number
    companyName: number
    registrationNumber: number
    address: number
    postCode: number
    contactPerson: number
    jobTitle: number
    phoneNumber: number
    website: number
    servicesRequirements: number
    securityServicesOfferings: number
    permissions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SecurityCompanyAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SecurityCompanySumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SecurityCompanyMinAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    registrationNumber?: true
    address?: true
    postCode?: true
    contactPerson?: true
    jobTitle?: true
    phoneNumber?: true
    website?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SecurityCompanyMaxAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    registrationNumber?: true
    address?: true
    postCode?: true
    contactPerson?: true
    jobTitle?: true
    phoneNumber?: true
    website?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SecurityCompanyCountAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    registrationNumber?: true
    address?: true
    postCode?: true
    contactPerson?: true
    jobTitle?: true
    phoneNumber?: true
    website?: true
    servicesRequirements?: true
    securityServicesOfferings?: true
    permissions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SecurityCompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityCompany to aggregate.
     */
    where?: SecurityCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityCompanies to fetch.
     */
    orderBy?: SecurityCompanyOrderByWithRelationInput | SecurityCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SecurityCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SecurityCompanies
    **/
    _count?: true | SecurityCompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SecurityCompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SecurityCompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecurityCompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecurityCompanyMaxAggregateInputType
  }

  export type GetSecurityCompanyAggregateType<T extends SecurityCompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateSecurityCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecurityCompany[P]>
      : GetScalarType<T[P], AggregateSecurityCompany[P]>
  }




  export type SecurityCompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecurityCompanyWhereInput
    orderBy?: SecurityCompanyOrderByWithAggregationInput | SecurityCompanyOrderByWithAggregationInput[]
    by: SecurityCompanyScalarFieldEnum[] | SecurityCompanyScalarFieldEnum
    having?: SecurityCompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecurityCompanyCountAggregateInputType | true
    _avg?: SecurityCompanyAvgAggregateInputType
    _sum?: SecurityCompanySumAggregateInputType
    _min?: SecurityCompanyMinAggregateInputType
    _max?: SecurityCompanyMaxAggregateInputType
  }

  export type SecurityCompanyGroupByOutputType = {
    id: number
    userId: number
    companyName: string
    registrationNumber: string
    address: string
    postCode: string
    contactPerson: string
    jobTitle: string
    phoneNumber: string
    website: string | null
    servicesRequirements: JsonValue | null
    securityServicesOfferings: JsonValue | null
    permissions: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: SecurityCompanyCountAggregateOutputType | null
    _avg: SecurityCompanyAvgAggregateOutputType | null
    _sum: SecurityCompanySumAggregateOutputType | null
    _min: SecurityCompanyMinAggregateOutputType | null
    _max: SecurityCompanyMaxAggregateOutputType | null
  }

  type GetSecurityCompanyGroupByPayload<T extends SecurityCompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SecurityCompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecurityCompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecurityCompanyGroupByOutputType[P]>
            : GetScalarType<T[P], SecurityCompanyGroupByOutputType[P]>
        }
      >
    >


  export type SecurityCompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    registrationNumber?: boolean
    address?: boolean
    postCode?: boolean
    contactPerson?: boolean
    jobTitle?: boolean
    phoneNumber?: boolean
    website?: boolean
    servicesRequirements?: boolean
    securityServicesOfferings?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    serviceAds?: boolean | SecurityCompany$serviceAdsArgs<ExtArgs>
    _count?: boolean | SecurityCompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["securityCompany"]>

  export type SecurityCompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    registrationNumber?: boolean
    address?: boolean
    postCode?: boolean
    contactPerson?: boolean
    jobTitle?: boolean
    phoneNumber?: boolean
    website?: boolean
    servicesRequirements?: boolean
    securityServicesOfferings?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["securityCompany"]>

  export type SecurityCompanySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    registrationNumber?: boolean
    address?: boolean
    postCode?: boolean
    contactPerson?: boolean
    jobTitle?: boolean
    phoneNumber?: boolean
    website?: boolean
    servicesRequirements?: boolean
    securityServicesOfferings?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["securityCompany"]>

  export type SecurityCompanySelectScalar = {
    id?: boolean
    userId?: boolean
    companyName?: boolean
    registrationNumber?: boolean
    address?: boolean
    postCode?: boolean
    contactPerson?: boolean
    jobTitle?: boolean
    phoneNumber?: boolean
    website?: boolean
    servicesRequirements?: boolean
    securityServicesOfferings?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SecurityCompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "companyName" | "registrationNumber" | "address" | "postCode" | "contactPerson" | "jobTitle" | "phoneNumber" | "website" | "servicesRequirements" | "securityServicesOfferings" | "permissions" | "createdAt" | "updatedAt", ExtArgs["result"]["securityCompany"]>
  export type SecurityCompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    serviceAds?: boolean | SecurityCompany$serviceAdsArgs<ExtArgs>
    _count?: boolean | SecurityCompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SecurityCompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SecurityCompanyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SecurityCompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SecurityCompany"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      serviceAds: Prisma.$ServiceAdPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      companyName: string
      registrationNumber: string
      address: string
      postCode: string
      contactPerson: string
      jobTitle: string
      phoneNumber: string
      website: string | null
      servicesRequirements: Prisma.JsonValue | null
      securityServicesOfferings: Prisma.JsonValue | null
      permissions: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["securityCompany"]>
    composites: {}
  }

  type SecurityCompanyGetPayload<S extends boolean | null | undefined | SecurityCompanyDefaultArgs> = $Result.GetResult<Prisma.$SecurityCompanyPayload, S>

  type SecurityCompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SecurityCompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SecurityCompanyCountAggregateInputType | true
    }

  export interface SecurityCompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SecurityCompany'], meta: { name: 'SecurityCompany' } }
    /**
     * Find zero or one SecurityCompany that matches the filter.
     * @param {SecurityCompanyFindUniqueArgs} args - Arguments to find a SecurityCompany
     * @example
     * // Get one SecurityCompany
     * const securityCompany = await prisma.securityCompany.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SecurityCompanyFindUniqueArgs>(args: SelectSubset<T, SecurityCompanyFindUniqueArgs<ExtArgs>>): Prisma__SecurityCompanyClient<$Result.GetResult<Prisma.$SecurityCompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SecurityCompany that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SecurityCompanyFindUniqueOrThrowArgs} args - Arguments to find a SecurityCompany
     * @example
     * // Get one SecurityCompany
     * const securityCompany = await prisma.securityCompany.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SecurityCompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, SecurityCompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SecurityCompanyClient<$Result.GetResult<Prisma.$SecurityCompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SecurityCompany that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityCompanyFindFirstArgs} args - Arguments to find a SecurityCompany
     * @example
     * // Get one SecurityCompany
     * const securityCompany = await prisma.securityCompany.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SecurityCompanyFindFirstArgs>(args?: SelectSubset<T, SecurityCompanyFindFirstArgs<ExtArgs>>): Prisma__SecurityCompanyClient<$Result.GetResult<Prisma.$SecurityCompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SecurityCompany that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityCompanyFindFirstOrThrowArgs} args - Arguments to find a SecurityCompany
     * @example
     * // Get one SecurityCompany
     * const securityCompany = await prisma.securityCompany.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SecurityCompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, SecurityCompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__SecurityCompanyClient<$Result.GetResult<Prisma.$SecurityCompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SecurityCompanies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityCompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SecurityCompanies
     * const securityCompanies = await prisma.securityCompany.findMany()
     * 
     * // Get first 10 SecurityCompanies
     * const securityCompanies = await prisma.securityCompany.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const securityCompanyWithIdOnly = await prisma.securityCompany.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SecurityCompanyFindManyArgs>(args?: SelectSubset<T, SecurityCompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityCompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SecurityCompany.
     * @param {SecurityCompanyCreateArgs} args - Arguments to create a SecurityCompany.
     * @example
     * // Create one SecurityCompany
     * const SecurityCompany = await prisma.securityCompany.create({
     *   data: {
     *     // ... data to create a SecurityCompany
     *   }
     * })
     * 
     */
    create<T extends SecurityCompanyCreateArgs>(args: SelectSubset<T, SecurityCompanyCreateArgs<ExtArgs>>): Prisma__SecurityCompanyClient<$Result.GetResult<Prisma.$SecurityCompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SecurityCompanies.
     * @param {SecurityCompanyCreateManyArgs} args - Arguments to create many SecurityCompanies.
     * @example
     * // Create many SecurityCompanies
     * const securityCompany = await prisma.securityCompany.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SecurityCompanyCreateManyArgs>(args?: SelectSubset<T, SecurityCompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SecurityCompanies and returns the data saved in the database.
     * @param {SecurityCompanyCreateManyAndReturnArgs} args - Arguments to create many SecurityCompanies.
     * @example
     * // Create many SecurityCompanies
     * const securityCompany = await prisma.securityCompany.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SecurityCompanies and only return the `id`
     * const securityCompanyWithIdOnly = await prisma.securityCompany.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SecurityCompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, SecurityCompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityCompanyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SecurityCompany.
     * @param {SecurityCompanyDeleteArgs} args - Arguments to delete one SecurityCompany.
     * @example
     * // Delete one SecurityCompany
     * const SecurityCompany = await prisma.securityCompany.delete({
     *   where: {
     *     // ... filter to delete one SecurityCompany
     *   }
     * })
     * 
     */
    delete<T extends SecurityCompanyDeleteArgs>(args: SelectSubset<T, SecurityCompanyDeleteArgs<ExtArgs>>): Prisma__SecurityCompanyClient<$Result.GetResult<Prisma.$SecurityCompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SecurityCompany.
     * @param {SecurityCompanyUpdateArgs} args - Arguments to update one SecurityCompany.
     * @example
     * // Update one SecurityCompany
     * const securityCompany = await prisma.securityCompany.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SecurityCompanyUpdateArgs>(args: SelectSubset<T, SecurityCompanyUpdateArgs<ExtArgs>>): Prisma__SecurityCompanyClient<$Result.GetResult<Prisma.$SecurityCompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SecurityCompanies.
     * @param {SecurityCompanyDeleteManyArgs} args - Arguments to filter SecurityCompanies to delete.
     * @example
     * // Delete a few SecurityCompanies
     * const { count } = await prisma.securityCompany.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SecurityCompanyDeleteManyArgs>(args?: SelectSubset<T, SecurityCompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityCompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SecurityCompanies
     * const securityCompany = await prisma.securityCompany.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SecurityCompanyUpdateManyArgs>(args: SelectSubset<T, SecurityCompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityCompanies and returns the data updated in the database.
     * @param {SecurityCompanyUpdateManyAndReturnArgs} args - Arguments to update many SecurityCompanies.
     * @example
     * // Update many SecurityCompanies
     * const securityCompany = await prisma.securityCompany.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SecurityCompanies and only return the `id`
     * const securityCompanyWithIdOnly = await prisma.securityCompany.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SecurityCompanyUpdateManyAndReturnArgs>(args: SelectSubset<T, SecurityCompanyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityCompanyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SecurityCompany.
     * @param {SecurityCompanyUpsertArgs} args - Arguments to update or create a SecurityCompany.
     * @example
     * // Update or create a SecurityCompany
     * const securityCompany = await prisma.securityCompany.upsert({
     *   create: {
     *     // ... data to create a SecurityCompany
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SecurityCompany we want to update
     *   }
     * })
     */
    upsert<T extends SecurityCompanyUpsertArgs>(args: SelectSubset<T, SecurityCompanyUpsertArgs<ExtArgs>>): Prisma__SecurityCompanyClient<$Result.GetResult<Prisma.$SecurityCompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SecurityCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityCompanyCountArgs} args - Arguments to filter SecurityCompanies to count.
     * @example
     * // Count the number of SecurityCompanies
     * const count = await prisma.securityCompany.count({
     *   where: {
     *     // ... the filter for the SecurityCompanies we want to count
     *   }
     * })
    **/
    count<T extends SecurityCompanyCountArgs>(
      args?: Subset<T, SecurityCompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecurityCompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SecurityCompany.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityCompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecurityCompanyAggregateArgs>(args: Subset<T, SecurityCompanyAggregateArgs>): Prisma.PrismaPromise<GetSecurityCompanyAggregateType<T>>

    /**
     * Group by SecurityCompany.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityCompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SecurityCompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecurityCompanyGroupByArgs['orderBy'] }
        : { orderBy?: SecurityCompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecurityCompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecurityCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SecurityCompany model
   */
  readonly fields: SecurityCompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SecurityCompany.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SecurityCompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    serviceAds<T extends SecurityCompany$serviceAdsArgs<ExtArgs> = {}>(args?: Subset<T, SecurityCompany$serviceAdsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceAdPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SecurityCompany model
   */
  interface SecurityCompanyFieldRefs {
    readonly id: FieldRef<"SecurityCompany", 'Int'>
    readonly userId: FieldRef<"SecurityCompany", 'Int'>
    readonly companyName: FieldRef<"SecurityCompany", 'String'>
    readonly registrationNumber: FieldRef<"SecurityCompany", 'String'>
    readonly address: FieldRef<"SecurityCompany", 'String'>
    readonly postCode: FieldRef<"SecurityCompany", 'String'>
    readonly contactPerson: FieldRef<"SecurityCompany", 'String'>
    readonly jobTitle: FieldRef<"SecurityCompany", 'String'>
    readonly phoneNumber: FieldRef<"SecurityCompany", 'String'>
    readonly website: FieldRef<"SecurityCompany", 'String'>
    readonly servicesRequirements: FieldRef<"SecurityCompany", 'Json'>
    readonly securityServicesOfferings: FieldRef<"SecurityCompany", 'Json'>
    readonly permissions: FieldRef<"SecurityCompany", 'Json'>
    readonly createdAt: FieldRef<"SecurityCompany", 'DateTime'>
    readonly updatedAt: FieldRef<"SecurityCompany", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SecurityCompany findUnique
   */
  export type SecurityCompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityCompany
     */
    select?: SecurityCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityCompany
     */
    omit?: SecurityCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityCompanyInclude<ExtArgs> | null
    /**
     * Filter, which SecurityCompany to fetch.
     */
    where: SecurityCompanyWhereUniqueInput
  }

  /**
   * SecurityCompany findUniqueOrThrow
   */
  export type SecurityCompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityCompany
     */
    select?: SecurityCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityCompany
     */
    omit?: SecurityCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityCompanyInclude<ExtArgs> | null
    /**
     * Filter, which SecurityCompany to fetch.
     */
    where: SecurityCompanyWhereUniqueInput
  }

  /**
   * SecurityCompany findFirst
   */
  export type SecurityCompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityCompany
     */
    select?: SecurityCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityCompany
     */
    omit?: SecurityCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityCompanyInclude<ExtArgs> | null
    /**
     * Filter, which SecurityCompany to fetch.
     */
    where?: SecurityCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityCompanies to fetch.
     */
    orderBy?: SecurityCompanyOrderByWithRelationInput | SecurityCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityCompanies.
     */
    cursor?: SecurityCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityCompanies.
     */
    distinct?: SecurityCompanyScalarFieldEnum | SecurityCompanyScalarFieldEnum[]
  }

  /**
   * SecurityCompany findFirstOrThrow
   */
  export type SecurityCompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityCompany
     */
    select?: SecurityCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityCompany
     */
    omit?: SecurityCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityCompanyInclude<ExtArgs> | null
    /**
     * Filter, which SecurityCompany to fetch.
     */
    where?: SecurityCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityCompanies to fetch.
     */
    orderBy?: SecurityCompanyOrderByWithRelationInput | SecurityCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityCompanies.
     */
    cursor?: SecurityCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityCompanies.
     */
    distinct?: SecurityCompanyScalarFieldEnum | SecurityCompanyScalarFieldEnum[]
  }

  /**
   * SecurityCompany findMany
   */
  export type SecurityCompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityCompany
     */
    select?: SecurityCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityCompany
     */
    omit?: SecurityCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityCompanyInclude<ExtArgs> | null
    /**
     * Filter, which SecurityCompanies to fetch.
     */
    where?: SecurityCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityCompanies to fetch.
     */
    orderBy?: SecurityCompanyOrderByWithRelationInput | SecurityCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SecurityCompanies.
     */
    cursor?: SecurityCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityCompanies.
     */
    skip?: number
    distinct?: SecurityCompanyScalarFieldEnum | SecurityCompanyScalarFieldEnum[]
  }

  /**
   * SecurityCompany create
   */
  export type SecurityCompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityCompany
     */
    select?: SecurityCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityCompany
     */
    omit?: SecurityCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityCompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a SecurityCompany.
     */
    data: XOR<SecurityCompanyCreateInput, SecurityCompanyUncheckedCreateInput>
  }

  /**
   * SecurityCompany createMany
   */
  export type SecurityCompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SecurityCompanies.
     */
    data: SecurityCompanyCreateManyInput | SecurityCompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SecurityCompany createManyAndReturn
   */
  export type SecurityCompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityCompany
     */
    select?: SecurityCompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityCompany
     */
    omit?: SecurityCompanyOmit<ExtArgs> | null
    /**
     * The data used to create many SecurityCompanies.
     */
    data: SecurityCompanyCreateManyInput | SecurityCompanyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityCompanyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SecurityCompany update
   */
  export type SecurityCompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityCompany
     */
    select?: SecurityCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityCompany
     */
    omit?: SecurityCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityCompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a SecurityCompany.
     */
    data: XOR<SecurityCompanyUpdateInput, SecurityCompanyUncheckedUpdateInput>
    /**
     * Choose, which SecurityCompany to update.
     */
    where: SecurityCompanyWhereUniqueInput
  }

  /**
   * SecurityCompany updateMany
   */
  export type SecurityCompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SecurityCompanies.
     */
    data: XOR<SecurityCompanyUpdateManyMutationInput, SecurityCompanyUncheckedUpdateManyInput>
    /**
     * Filter which SecurityCompanies to update
     */
    where?: SecurityCompanyWhereInput
    /**
     * Limit how many SecurityCompanies to update.
     */
    limit?: number
  }

  /**
   * SecurityCompany updateManyAndReturn
   */
  export type SecurityCompanyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityCompany
     */
    select?: SecurityCompanySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityCompany
     */
    omit?: SecurityCompanyOmit<ExtArgs> | null
    /**
     * The data used to update SecurityCompanies.
     */
    data: XOR<SecurityCompanyUpdateManyMutationInput, SecurityCompanyUncheckedUpdateManyInput>
    /**
     * Filter which SecurityCompanies to update
     */
    where?: SecurityCompanyWhereInput
    /**
     * Limit how many SecurityCompanies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityCompanyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SecurityCompany upsert
   */
  export type SecurityCompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityCompany
     */
    select?: SecurityCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityCompany
     */
    omit?: SecurityCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityCompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the SecurityCompany to update in case it exists.
     */
    where: SecurityCompanyWhereUniqueInput
    /**
     * In case the SecurityCompany found by the `where` argument doesn't exist, create a new SecurityCompany with this data.
     */
    create: XOR<SecurityCompanyCreateInput, SecurityCompanyUncheckedCreateInput>
    /**
     * In case the SecurityCompany was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SecurityCompanyUpdateInput, SecurityCompanyUncheckedUpdateInput>
  }

  /**
   * SecurityCompany delete
   */
  export type SecurityCompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityCompany
     */
    select?: SecurityCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityCompany
     */
    omit?: SecurityCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityCompanyInclude<ExtArgs> | null
    /**
     * Filter which SecurityCompany to delete.
     */
    where: SecurityCompanyWhereUniqueInput
  }

  /**
   * SecurityCompany deleteMany
   */
  export type SecurityCompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityCompanies to delete
     */
    where?: SecurityCompanyWhereInput
    /**
     * Limit how many SecurityCompanies to delete.
     */
    limit?: number
  }

  /**
   * SecurityCompany.serviceAds
   */
  export type SecurityCompany$serviceAdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAd
     */
    select?: ServiceAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAd
     */
    omit?: ServiceAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAdInclude<ExtArgs> | null
    where?: ServiceAdWhereInput
    orderBy?: ServiceAdOrderByWithRelationInput | ServiceAdOrderByWithRelationInput[]
    cursor?: ServiceAdWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceAdScalarFieldEnum | ServiceAdScalarFieldEnum[]
  }

  /**
   * SecurityCompany without action
   */
  export type SecurityCompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityCompany
     */
    select?: SecurityCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityCompany
     */
    omit?: SecurityCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityCompanyInclude<ExtArgs> | null
  }


  /**
   * Model CourseProvider
   */

  export type AggregateCourseProvider = {
    _count: CourseProviderCountAggregateOutputType | null
    _avg: CourseProviderAvgAggregateOutputType | null
    _sum: CourseProviderSumAggregateOutputType | null
    _min: CourseProviderMinAggregateOutputType | null
    _max: CourseProviderMaxAggregateOutputType | null
  }

  export type CourseProviderAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type CourseProviderSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type CourseProviderMinAggregateOutputType = {
    id: number | null
    userId: number | null
    companyName: string | null
    registrationNumber: string | null
    address: string | null
    postCode: string | null
    contactPerson: string | null
    jobTitle: string | null
    phoneNumber: string | null
    website: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseProviderMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    companyName: string | null
    registrationNumber: string | null
    address: string | null
    postCode: string | null
    contactPerson: string | null
    jobTitle: string | null
    phoneNumber: string | null
    website: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseProviderCountAggregateOutputType = {
    id: number
    userId: number
    companyName: number
    registrationNumber: number
    address: number
    postCode: number
    contactPerson: number
    jobTitle: number
    phoneNumber: number
    website: number
    servicesRequirements: number
    securityServicesOfferings: number
    permissions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CourseProviderAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type CourseProviderSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type CourseProviderMinAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    registrationNumber?: true
    address?: true
    postCode?: true
    contactPerson?: true
    jobTitle?: true
    phoneNumber?: true
    website?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseProviderMaxAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    registrationNumber?: true
    address?: true
    postCode?: true
    contactPerson?: true
    jobTitle?: true
    phoneNumber?: true
    website?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseProviderCountAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    registrationNumber?: true
    address?: true
    postCode?: true
    contactPerson?: true
    jobTitle?: true
    phoneNumber?: true
    website?: true
    servicesRequirements?: true
    securityServicesOfferings?: true
    permissions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CourseProviderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseProvider to aggregate.
     */
    where?: CourseProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseProviders to fetch.
     */
    orderBy?: CourseProviderOrderByWithRelationInput | CourseProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseProviders
    **/
    _count?: true | CourseProviderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseProviderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseProviderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseProviderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseProviderMaxAggregateInputType
  }

  export type GetCourseProviderAggregateType<T extends CourseProviderAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseProvider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseProvider[P]>
      : GetScalarType<T[P], AggregateCourseProvider[P]>
  }




  export type CourseProviderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseProviderWhereInput
    orderBy?: CourseProviderOrderByWithAggregationInput | CourseProviderOrderByWithAggregationInput[]
    by: CourseProviderScalarFieldEnum[] | CourseProviderScalarFieldEnum
    having?: CourseProviderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseProviderCountAggregateInputType | true
    _avg?: CourseProviderAvgAggregateInputType
    _sum?: CourseProviderSumAggregateInputType
    _min?: CourseProviderMinAggregateInputType
    _max?: CourseProviderMaxAggregateInputType
  }

  export type CourseProviderGroupByOutputType = {
    id: number
    userId: number
    companyName: string
    registrationNumber: string
    address: string
    postCode: string
    contactPerson: string
    jobTitle: string
    phoneNumber: string
    website: string | null
    servicesRequirements: JsonValue | null
    securityServicesOfferings: JsonValue | null
    permissions: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: CourseProviderCountAggregateOutputType | null
    _avg: CourseProviderAvgAggregateOutputType | null
    _sum: CourseProviderSumAggregateOutputType | null
    _min: CourseProviderMinAggregateOutputType | null
    _max: CourseProviderMaxAggregateOutputType | null
  }

  type GetCourseProviderGroupByPayload<T extends CourseProviderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseProviderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseProviderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseProviderGroupByOutputType[P]>
            : GetScalarType<T[P], CourseProviderGroupByOutputType[P]>
        }
      >
    >


  export type CourseProviderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    registrationNumber?: boolean
    address?: boolean
    postCode?: boolean
    contactPerson?: boolean
    jobTitle?: boolean
    phoneNumber?: boolean
    website?: boolean
    servicesRequirements?: boolean
    securityServicesOfferings?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    courseAds?: boolean | CourseProvider$courseAdsArgs<ExtArgs>
    _count?: boolean | CourseProviderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseProvider"]>

  export type CourseProviderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    registrationNumber?: boolean
    address?: boolean
    postCode?: boolean
    contactPerson?: boolean
    jobTitle?: boolean
    phoneNumber?: boolean
    website?: boolean
    servicesRequirements?: boolean
    securityServicesOfferings?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseProvider"]>

  export type CourseProviderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    registrationNumber?: boolean
    address?: boolean
    postCode?: boolean
    contactPerson?: boolean
    jobTitle?: boolean
    phoneNumber?: boolean
    website?: boolean
    servicesRequirements?: boolean
    securityServicesOfferings?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseProvider"]>

  export type CourseProviderSelectScalar = {
    id?: boolean
    userId?: boolean
    companyName?: boolean
    registrationNumber?: boolean
    address?: boolean
    postCode?: boolean
    contactPerson?: boolean
    jobTitle?: boolean
    phoneNumber?: boolean
    website?: boolean
    servicesRequirements?: boolean
    securityServicesOfferings?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CourseProviderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "companyName" | "registrationNumber" | "address" | "postCode" | "contactPerson" | "jobTitle" | "phoneNumber" | "website" | "servicesRequirements" | "securityServicesOfferings" | "permissions" | "createdAt" | "updatedAt", ExtArgs["result"]["courseProvider"]>
  export type CourseProviderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    courseAds?: boolean | CourseProvider$courseAdsArgs<ExtArgs>
    _count?: boolean | CourseProviderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseProviderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CourseProviderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CourseProviderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseProvider"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      courseAds: Prisma.$CourseAdPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      companyName: string
      registrationNumber: string
      address: string
      postCode: string
      contactPerson: string
      jobTitle: string
      phoneNumber: string
      website: string | null
      servicesRequirements: Prisma.JsonValue | null
      securityServicesOfferings: Prisma.JsonValue | null
      permissions: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["courseProvider"]>
    composites: {}
  }

  type CourseProviderGetPayload<S extends boolean | null | undefined | CourseProviderDefaultArgs> = $Result.GetResult<Prisma.$CourseProviderPayload, S>

  type CourseProviderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseProviderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseProviderCountAggregateInputType | true
    }

  export interface CourseProviderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseProvider'], meta: { name: 'CourseProvider' } }
    /**
     * Find zero or one CourseProvider that matches the filter.
     * @param {CourseProviderFindUniqueArgs} args - Arguments to find a CourseProvider
     * @example
     * // Get one CourseProvider
     * const courseProvider = await prisma.courseProvider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseProviderFindUniqueArgs>(args: SelectSubset<T, CourseProviderFindUniqueArgs<ExtArgs>>): Prisma__CourseProviderClient<$Result.GetResult<Prisma.$CourseProviderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourseProvider that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseProviderFindUniqueOrThrowArgs} args - Arguments to find a CourseProvider
     * @example
     * // Get one CourseProvider
     * const courseProvider = await prisma.courseProvider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseProviderFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseProviderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseProviderClient<$Result.GetResult<Prisma.$CourseProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseProvider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseProviderFindFirstArgs} args - Arguments to find a CourseProvider
     * @example
     * // Get one CourseProvider
     * const courseProvider = await prisma.courseProvider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseProviderFindFirstArgs>(args?: SelectSubset<T, CourseProviderFindFirstArgs<ExtArgs>>): Prisma__CourseProviderClient<$Result.GetResult<Prisma.$CourseProviderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseProvider that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseProviderFindFirstOrThrowArgs} args - Arguments to find a CourseProvider
     * @example
     * // Get one CourseProvider
     * const courseProvider = await prisma.courseProvider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseProviderFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseProviderFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseProviderClient<$Result.GetResult<Prisma.$CourseProviderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourseProviders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseProviderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseProviders
     * const courseProviders = await prisma.courseProvider.findMany()
     * 
     * // Get first 10 CourseProviders
     * const courseProviders = await prisma.courseProvider.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseProviderWithIdOnly = await prisma.courseProvider.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseProviderFindManyArgs>(args?: SelectSubset<T, CourseProviderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseProviderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourseProvider.
     * @param {CourseProviderCreateArgs} args - Arguments to create a CourseProvider.
     * @example
     * // Create one CourseProvider
     * const CourseProvider = await prisma.courseProvider.create({
     *   data: {
     *     // ... data to create a CourseProvider
     *   }
     * })
     * 
     */
    create<T extends CourseProviderCreateArgs>(args: SelectSubset<T, CourseProviderCreateArgs<ExtArgs>>): Prisma__CourseProviderClient<$Result.GetResult<Prisma.$CourseProviderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourseProviders.
     * @param {CourseProviderCreateManyArgs} args - Arguments to create many CourseProviders.
     * @example
     * // Create many CourseProviders
     * const courseProvider = await prisma.courseProvider.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseProviderCreateManyArgs>(args?: SelectSubset<T, CourseProviderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseProviders and returns the data saved in the database.
     * @param {CourseProviderCreateManyAndReturnArgs} args - Arguments to create many CourseProviders.
     * @example
     * // Create many CourseProviders
     * const courseProvider = await prisma.courseProvider.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseProviders and only return the `id`
     * const courseProviderWithIdOnly = await prisma.courseProvider.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseProviderCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseProviderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseProviderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CourseProvider.
     * @param {CourseProviderDeleteArgs} args - Arguments to delete one CourseProvider.
     * @example
     * // Delete one CourseProvider
     * const CourseProvider = await prisma.courseProvider.delete({
     *   where: {
     *     // ... filter to delete one CourseProvider
     *   }
     * })
     * 
     */
    delete<T extends CourseProviderDeleteArgs>(args: SelectSubset<T, CourseProviderDeleteArgs<ExtArgs>>): Prisma__CourseProviderClient<$Result.GetResult<Prisma.$CourseProviderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourseProvider.
     * @param {CourseProviderUpdateArgs} args - Arguments to update one CourseProvider.
     * @example
     * // Update one CourseProvider
     * const courseProvider = await prisma.courseProvider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseProviderUpdateArgs>(args: SelectSubset<T, CourseProviderUpdateArgs<ExtArgs>>): Prisma__CourseProviderClient<$Result.GetResult<Prisma.$CourseProviderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourseProviders.
     * @param {CourseProviderDeleteManyArgs} args - Arguments to filter CourseProviders to delete.
     * @example
     * // Delete a few CourseProviders
     * const { count } = await prisma.courseProvider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseProviderDeleteManyArgs>(args?: SelectSubset<T, CourseProviderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseProviderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseProviders
     * const courseProvider = await prisma.courseProvider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseProviderUpdateManyArgs>(args: SelectSubset<T, CourseProviderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseProviders and returns the data updated in the database.
     * @param {CourseProviderUpdateManyAndReturnArgs} args - Arguments to update many CourseProviders.
     * @example
     * // Update many CourseProviders
     * const courseProvider = await prisma.courseProvider.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CourseProviders and only return the `id`
     * const courseProviderWithIdOnly = await prisma.courseProvider.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseProviderUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseProviderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseProviderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CourseProvider.
     * @param {CourseProviderUpsertArgs} args - Arguments to update or create a CourseProvider.
     * @example
     * // Update or create a CourseProvider
     * const courseProvider = await prisma.courseProvider.upsert({
     *   create: {
     *     // ... data to create a CourseProvider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseProvider we want to update
     *   }
     * })
     */
    upsert<T extends CourseProviderUpsertArgs>(args: SelectSubset<T, CourseProviderUpsertArgs<ExtArgs>>): Prisma__CourseProviderClient<$Result.GetResult<Prisma.$CourseProviderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourseProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseProviderCountArgs} args - Arguments to filter CourseProviders to count.
     * @example
     * // Count the number of CourseProviders
     * const count = await prisma.courseProvider.count({
     *   where: {
     *     // ... the filter for the CourseProviders we want to count
     *   }
     * })
    **/
    count<T extends CourseProviderCountArgs>(
      args?: Subset<T, CourseProviderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseProviderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseProvider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseProviderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseProviderAggregateArgs>(args: Subset<T, CourseProviderAggregateArgs>): Prisma.PrismaPromise<GetCourseProviderAggregateType<T>>

    /**
     * Group by CourseProvider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseProviderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseProviderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseProviderGroupByArgs['orderBy'] }
        : { orderBy?: CourseProviderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseProviderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseProviderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseProvider model
   */
  readonly fields: CourseProviderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseProvider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseProviderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    courseAds<T extends CourseProvider$courseAdsArgs<ExtArgs> = {}>(args?: Subset<T, CourseProvider$courseAdsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseAdPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseProvider model
   */
  interface CourseProviderFieldRefs {
    readonly id: FieldRef<"CourseProvider", 'Int'>
    readonly userId: FieldRef<"CourseProvider", 'Int'>
    readonly companyName: FieldRef<"CourseProvider", 'String'>
    readonly registrationNumber: FieldRef<"CourseProvider", 'String'>
    readonly address: FieldRef<"CourseProvider", 'String'>
    readonly postCode: FieldRef<"CourseProvider", 'String'>
    readonly contactPerson: FieldRef<"CourseProvider", 'String'>
    readonly jobTitle: FieldRef<"CourseProvider", 'String'>
    readonly phoneNumber: FieldRef<"CourseProvider", 'String'>
    readonly website: FieldRef<"CourseProvider", 'String'>
    readonly servicesRequirements: FieldRef<"CourseProvider", 'Json'>
    readonly securityServicesOfferings: FieldRef<"CourseProvider", 'Json'>
    readonly permissions: FieldRef<"CourseProvider", 'Json'>
    readonly createdAt: FieldRef<"CourseProvider", 'DateTime'>
    readonly updatedAt: FieldRef<"CourseProvider", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CourseProvider findUnique
   */
  export type CourseProviderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProvider
     */
    select?: CourseProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseProvider
     */
    omit?: CourseProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProviderInclude<ExtArgs> | null
    /**
     * Filter, which CourseProvider to fetch.
     */
    where: CourseProviderWhereUniqueInput
  }

  /**
   * CourseProvider findUniqueOrThrow
   */
  export type CourseProviderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProvider
     */
    select?: CourseProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseProvider
     */
    omit?: CourseProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProviderInclude<ExtArgs> | null
    /**
     * Filter, which CourseProvider to fetch.
     */
    where: CourseProviderWhereUniqueInput
  }

  /**
   * CourseProvider findFirst
   */
  export type CourseProviderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProvider
     */
    select?: CourseProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseProvider
     */
    omit?: CourseProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProviderInclude<ExtArgs> | null
    /**
     * Filter, which CourseProvider to fetch.
     */
    where?: CourseProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseProviders to fetch.
     */
    orderBy?: CourseProviderOrderByWithRelationInput | CourseProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseProviders.
     */
    cursor?: CourseProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseProviders.
     */
    distinct?: CourseProviderScalarFieldEnum | CourseProviderScalarFieldEnum[]
  }

  /**
   * CourseProvider findFirstOrThrow
   */
  export type CourseProviderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProvider
     */
    select?: CourseProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseProvider
     */
    omit?: CourseProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProviderInclude<ExtArgs> | null
    /**
     * Filter, which CourseProvider to fetch.
     */
    where?: CourseProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseProviders to fetch.
     */
    orderBy?: CourseProviderOrderByWithRelationInput | CourseProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseProviders.
     */
    cursor?: CourseProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseProviders.
     */
    distinct?: CourseProviderScalarFieldEnum | CourseProviderScalarFieldEnum[]
  }

  /**
   * CourseProvider findMany
   */
  export type CourseProviderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProvider
     */
    select?: CourseProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseProvider
     */
    omit?: CourseProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProviderInclude<ExtArgs> | null
    /**
     * Filter, which CourseProviders to fetch.
     */
    where?: CourseProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseProviders to fetch.
     */
    orderBy?: CourseProviderOrderByWithRelationInput | CourseProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseProviders.
     */
    cursor?: CourseProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseProviders.
     */
    skip?: number
    distinct?: CourseProviderScalarFieldEnum | CourseProviderScalarFieldEnum[]
  }

  /**
   * CourseProvider create
   */
  export type CourseProviderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProvider
     */
    select?: CourseProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseProvider
     */
    omit?: CourseProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProviderInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseProvider.
     */
    data: XOR<CourseProviderCreateInput, CourseProviderUncheckedCreateInput>
  }

  /**
   * CourseProvider createMany
   */
  export type CourseProviderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseProviders.
     */
    data: CourseProviderCreateManyInput | CourseProviderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseProvider createManyAndReturn
   */
  export type CourseProviderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProvider
     */
    select?: CourseProviderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseProvider
     */
    omit?: CourseProviderOmit<ExtArgs> | null
    /**
     * The data used to create many CourseProviders.
     */
    data: CourseProviderCreateManyInput | CourseProviderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProviderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseProvider update
   */
  export type CourseProviderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProvider
     */
    select?: CourseProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseProvider
     */
    omit?: CourseProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProviderInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseProvider.
     */
    data: XOR<CourseProviderUpdateInput, CourseProviderUncheckedUpdateInput>
    /**
     * Choose, which CourseProvider to update.
     */
    where: CourseProviderWhereUniqueInput
  }

  /**
   * CourseProvider updateMany
   */
  export type CourseProviderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseProviders.
     */
    data: XOR<CourseProviderUpdateManyMutationInput, CourseProviderUncheckedUpdateManyInput>
    /**
     * Filter which CourseProviders to update
     */
    where?: CourseProviderWhereInput
    /**
     * Limit how many CourseProviders to update.
     */
    limit?: number
  }

  /**
   * CourseProvider updateManyAndReturn
   */
  export type CourseProviderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProvider
     */
    select?: CourseProviderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseProvider
     */
    omit?: CourseProviderOmit<ExtArgs> | null
    /**
     * The data used to update CourseProviders.
     */
    data: XOR<CourseProviderUpdateManyMutationInput, CourseProviderUncheckedUpdateManyInput>
    /**
     * Filter which CourseProviders to update
     */
    where?: CourseProviderWhereInput
    /**
     * Limit how many CourseProviders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProviderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseProvider upsert
   */
  export type CourseProviderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProvider
     */
    select?: CourseProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseProvider
     */
    omit?: CourseProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProviderInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseProvider to update in case it exists.
     */
    where: CourseProviderWhereUniqueInput
    /**
     * In case the CourseProvider found by the `where` argument doesn't exist, create a new CourseProvider with this data.
     */
    create: XOR<CourseProviderCreateInput, CourseProviderUncheckedCreateInput>
    /**
     * In case the CourseProvider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseProviderUpdateInput, CourseProviderUncheckedUpdateInput>
  }

  /**
   * CourseProvider delete
   */
  export type CourseProviderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProvider
     */
    select?: CourseProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseProvider
     */
    omit?: CourseProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProviderInclude<ExtArgs> | null
    /**
     * Filter which CourseProvider to delete.
     */
    where: CourseProviderWhereUniqueInput
  }

  /**
   * CourseProvider deleteMany
   */
  export type CourseProviderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseProviders to delete
     */
    where?: CourseProviderWhereInput
    /**
     * Limit how many CourseProviders to delete.
     */
    limit?: number
  }

  /**
   * CourseProvider.courseAds
   */
  export type CourseProvider$courseAdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseAd
     */
    select?: CourseAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseAd
     */
    omit?: CourseAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseAdInclude<ExtArgs> | null
    where?: CourseAdWhereInput
    orderBy?: CourseAdOrderByWithRelationInput | CourseAdOrderByWithRelationInput[]
    cursor?: CourseAdWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseAdScalarFieldEnum | CourseAdScalarFieldEnum[]
  }

  /**
   * CourseProvider without action
   */
  export type CourseProviderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProvider
     */
    select?: CourseProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseProvider
     */
    omit?: CourseProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProviderInclude<ExtArgs> | null
  }


  /**
   * Model CorporateClient
   */

  export type AggregateCorporateClient = {
    _count: CorporateClientCountAggregateOutputType | null
    _avg: CorporateClientAvgAggregateOutputType | null
    _sum: CorporateClientSumAggregateOutputType | null
    _min: CorporateClientMinAggregateOutputType | null
    _max: CorporateClientMaxAggregateOutputType | null
  }

  export type CorporateClientAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type CorporateClientSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type CorporateClientMinAggregateOutputType = {
    id: number | null
    userId: number | null
    companyName: string | null
    registrationNumber: string | null
    address: string | null
    postCode: string | null
    industryType: string | null
    contactPerson: string | null
    jobTitle: string | null
    phoneNumber: string | null
    website: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CorporateClientMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    companyName: string | null
    registrationNumber: string | null
    address: string | null
    postCode: string | null
    industryType: string | null
    contactPerson: string | null
    jobTitle: string | null
    phoneNumber: string | null
    website: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CorporateClientCountAggregateOutputType = {
    id: number
    userId: number
    companyName: number
    registrationNumber: number
    address: number
    postCode: number
    industryType: number
    contactPerson: number
    jobTitle: number
    phoneNumber: number
    website: number
    serviceRequirements: number
    permissions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CorporateClientAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type CorporateClientSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type CorporateClientMinAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    registrationNumber?: true
    address?: true
    postCode?: true
    industryType?: true
    contactPerson?: true
    jobTitle?: true
    phoneNumber?: true
    website?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CorporateClientMaxAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    registrationNumber?: true
    address?: true
    postCode?: true
    industryType?: true
    contactPerson?: true
    jobTitle?: true
    phoneNumber?: true
    website?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CorporateClientCountAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    registrationNumber?: true
    address?: true
    postCode?: true
    industryType?: true
    contactPerson?: true
    jobTitle?: true
    phoneNumber?: true
    website?: true
    serviceRequirements?: true
    permissions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CorporateClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CorporateClient to aggregate.
     */
    where?: CorporateClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CorporateClients to fetch.
     */
    orderBy?: CorporateClientOrderByWithRelationInput | CorporateClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CorporateClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CorporateClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CorporateClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CorporateClients
    **/
    _count?: true | CorporateClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CorporateClientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CorporateClientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CorporateClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CorporateClientMaxAggregateInputType
  }

  export type GetCorporateClientAggregateType<T extends CorporateClientAggregateArgs> = {
        [P in keyof T & keyof AggregateCorporateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCorporateClient[P]>
      : GetScalarType<T[P], AggregateCorporateClient[P]>
  }




  export type CorporateClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CorporateClientWhereInput
    orderBy?: CorporateClientOrderByWithAggregationInput | CorporateClientOrderByWithAggregationInput[]
    by: CorporateClientScalarFieldEnum[] | CorporateClientScalarFieldEnum
    having?: CorporateClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CorporateClientCountAggregateInputType | true
    _avg?: CorporateClientAvgAggregateInputType
    _sum?: CorporateClientSumAggregateInputType
    _min?: CorporateClientMinAggregateInputType
    _max?: CorporateClientMaxAggregateInputType
  }

  export type CorporateClientGroupByOutputType = {
    id: number
    userId: number
    companyName: string
    registrationNumber: string
    address: string
    postCode: string
    industryType: string
    contactPerson: string
    jobTitle: string
    phoneNumber: string
    website: string | null
    serviceRequirements: JsonValue | null
    permissions: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: CorporateClientCountAggregateOutputType | null
    _avg: CorporateClientAvgAggregateOutputType | null
    _sum: CorporateClientSumAggregateOutputType | null
    _min: CorporateClientMinAggregateOutputType | null
    _max: CorporateClientMaxAggregateOutputType | null
  }

  type GetCorporateClientGroupByPayload<T extends CorporateClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CorporateClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CorporateClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CorporateClientGroupByOutputType[P]>
            : GetScalarType<T[P], CorporateClientGroupByOutputType[P]>
        }
      >
    >


  export type CorporateClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    registrationNumber?: boolean
    address?: boolean
    postCode?: boolean
    industryType?: boolean
    contactPerson?: boolean
    jobTitle?: boolean
    phoneNumber?: boolean
    website?: boolean
    serviceRequirements?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    corporateAds?: boolean | CorporateClient$corporateAdsArgs<ExtArgs>
    _count?: boolean | CorporateClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["corporateClient"]>

  export type CorporateClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    registrationNumber?: boolean
    address?: boolean
    postCode?: boolean
    industryType?: boolean
    contactPerson?: boolean
    jobTitle?: boolean
    phoneNumber?: boolean
    website?: boolean
    serviceRequirements?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["corporateClient"]>

  export type CorporateClientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    registrationNumber?: boolean
    address?: boolean
    postCode?: boolean
    industryType?: boolean
    contactPerson?: boolean
    jobTitle?: boolean
    phoneNumber?: boolean
    website?: boolean
    serviceRequirements?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["corporateClient"]>

  export type CorporateClientSelectScalar = {
    id?: boolean
    userId?: boolean
    companyName?: boolean
    registrationNumber?: boolean
    address?: boolean
    postCode?: boolean
    industryType?: boolean
    contactPerson?: boolean
    jobTitle?: boolean
    phoneNumber?: boolean
    website?: boolean
    serviceRequirements?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CorporateClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "companyName" | "registrationNumber" | "address" | "postCode" | "industryType" | "contactPerson" | "jobTitle" | "phoneNumber" | "website" | "serviceRequirements" | "permissions" | "createdAt" | "updatedAt", ExtArgs["result"]["corporateClient"]>
  export type CorporateClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    corporateAds?: boolean | CorporateClient$corporateAdsArgs<ExtArgs>
    _count?: boolean | CorporateClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CorporateClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CorporateClientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CorporateClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CorporateClient"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      corporateAds: Prisma.$CorporateAdPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      companyName: string
      registrationNumber: string
      address: string
      postCode: string
      industryType: string
      contactPerson: string
      jobTitle: string
      phoneNumber: string
      website: string | null
      serviceRequirements: Prisma.JsonValue | null
      permissions: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["corporateClient"]>
    composites: {}
  }

  type CorporateClientGetPayload<S extends boolean | null | undefined | CorporateClientDefaultArgs> = $Result.GetResult<Prisma.$CorporateClientPayload, S>

  type CorporateClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CorporateClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CorporateClientCountAggregateInputType | true
    }

  export interface CorporateClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CorporateClient'], meta: { name: 'CorporateClient' } }
    /**
     * Find zero or one CorporateClient that matches the filter.
     * @param {CorporateClientFindUniqueArgs} args - Arguments to find a CorporateClient
     * @example
     * // Get one CorporateClient
     * const corporateClient = await prisma.corporateClient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CorporateClientFindUniqueArgs>(args: SelectSubset<T, CorporateClientFindUniqueArgs<ExtArgs>>): Prisma__CorporateClientClient<$Result.GetResult<Prisma.$CorporateClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CorporateClient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CorporateClientFindUniqueOrThrowArgs} args - Arguments to find a CorporateClient
     * @example
     * // Get one CorporateClient
     * const corporateClient = await prisma.corporateClient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CorporateClientFindUniqueOrThrowArgs>(args: SelectSubset<T, CorporateClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CorporateClientClient<$Result.GetResult<Prisma.$CorporateClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CorporateClient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateClientFindFirstArgs} args - Arguments to find a CorporateClient
     * @example
     * // Get one CorporateClient
     * const corporateClient = await prisma.corporateClient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CorporateClientFindFirstArgs>(args?: SelectSubset<T, CorporateClientFindFirstArgs<ExtArgs>>): Prisma__CorporateClientClient<$Result.GetResult<Prisma.$CorporateClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CorporateClient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateClientFindFirstOrThrowArgs} args - Arguments to find a CorporateClient
     * @example
     * // Get one CorporateClient
     * const corporateClient = await prisma.corporateClient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CorporateClientFindFirstOrThrowArgs>(args?: SelectSubset<T, CorporateClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__CorporateClientClient<$Result.GetResult<Prisma.$CorporateClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CorporateClients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CorporateClients
     * const corporateClients = await prisma.corporateClient.findMany()
     * 
     * // Get first 10 CorporateClients
     * const corporateClients = await prisma.corporateClient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const corporateClientWithIdOnly = await prisma.corporateClient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CorporateClientFindManyArgs>(args?: SelectSubset<T, CorporateClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorporateClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CorporateClient.
     * @param {CorporateClientCreateArgs} args - Arguments to create a CorporateClient.
     * @example
     * // Create one CorporateClient
     * const CorporateClient = await prisma.corporateClient.create({
     *   data: {
     *     // ... data to create a CorporateClient
     *   }
     * })
     * 
     */
    create<T extends CorporateClientCreateArgs>(args: SelectSubset<T, CorporateClientCreateArgs<ExtArgs>>): Prisma__CorporateClientClient<$Result.GetResult<Prisma.$CorporateClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CorporateClients.
     * @param {CorporateClientCreateManyArgs} args - Arguments to create many CorporateClients.
     * @example
     * // Create many CorporateClients
     * const corporateClient = await prisma.corporateClient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CorporateClientCreateManyArgs>(args?: SelectSubset<T, CorporateClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CorporateClients and returns the data saved in the database.
     * @param {CorporateClientCreateManyAndReturnArgs} args - Arguments to create many CorporateClients.
     * @example
     * // Create many CorporateClients
     * const corporateClient = await prisma.corporateClient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CorporateClients and only return the `id`
     * const corporateClientWithIdOnly = await prisma.corporateClient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CorporateClientCreateManyAndReturnArgs>(args?: SelectSubset<T, CorporateClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorporateClientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CorporateClient.
     * @param {CorporateClientDeleteArgs} args - Arguments to delete one CorporateClient.
     * @example
     * // Delete one CorporateClient
     * const CorporateClient = await prisma.corporateClient.delete({
     *   where: {
     *     // ... filter to delete one CorporateClient
     *   }
     * })
     * 
     */
    delete<T extends CorporateClientDeleteArgs>(args: SelectSubset<T, CorporateClientDeleteArgs<ExtArgs>>): Prisma__CorporateClientClient<$Result.GetResult<Prisma.$CorporateClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CorporateClient.
     * @param {CorporateClientUpdateArgs} args - Arguments to update one CorporateClient.
     * @example
     * // Update one CorporateClient
     * const corporateClient = await prisma.corporateClient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CorporateClientUpdateArgs>(args: SelectSubset<T, CorporateClientUpdateArgs<ExtArgs>>): Prisma__CorporateClientClient<$Result.GetResult<Prisma.$CorporateClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CorporateClients.
     * @param {CorporateClientDeleteManyArgs} args - Arguments to filter CorporateClients to delete.
     * @example
     * // Delete a few CorporateClients
     * const { count } = await prisma.corporateClient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CorporateClientDeleteManyArgs>(args?: SelectSubset<T, CorporateClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CorporateClients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CorporateClients
     * const corporateClient = await prisma.corporateClient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CorporateClientUpdateManyArgs>(args: SelectSubset<T, CorporateClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CorporateClients and returns the data updated in the database.
     * @param {CorporateClientUpdateManyAndReturnArgs} args - Arguments to update many CorporateClients.
     * @example
     * // Update many CorporateClients
     * const corporateClient = await prisma.corporateClient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CorporateClients and only return the `id`
     * const corporateClientWithIdOnly = await prisma.corporateClient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CorporateClientUpdateManyAndReturnArgs>(args: SelectSubset<T, CorporateClientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorporateClientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CorporateClient.
     * @param {CorporateClientUpsertArgs} args - Arguments to update or create a CorporateClient.
     * @example
     * // Update or create a CorporateClient
     * const corporateClient = await prisma.corporateClient.upsert({
     *   create: {
     *     // ... data to create a CorporateClient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CorporateClient we want to update
     *   }
     * })
     */
    upsert<T extends CorporateClientUpsertArgs>(args: SelectSubset<T, CorporateClientUpsertArgs<ExtArgs>>): Prisma__CorporateClientClient<$Result.GetResult<Prisma.$CorporateClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CorporateClients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateClientCountArgs} args - Arguments to filter CorporateClients to count.
     * @example
     * // Count the number of CorporateClients
     * const count = await prisma.corporateClient.count({
     *   where: {
     *     // ... the filter for the CorporateClients we want to count
     *   }
     * })
    **/
    count<T extends CorporateClientCountArgs>(
      args?: Subset<T, CorporateClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CorporateClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CorporateClient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CorporateClientAggregateArgs>(args: Subset<T, CorporateClientAggregateArgs>): Prisma.PrismaPromise<GetCorporateClientAggregateType<T>>

    /**
     * Group by CorporateClient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CorporateClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CorporateClientGroupByArgs['orderBy'] }
        : { orderBy?: CorporateClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CorporateClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCorporateClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CorporateClient model
   */
  readonly fields: CorporateClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CorporateClient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CorporateClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    corporateAds<T extends CorporateClient$corporateAdsArgs<ExtArgs> = {}>(args?: Subset<T, CorporateClient$corporateAdsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorporateAdPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CorporateClient model
   */
  interface CorporateClientFieldRefs {
    readonly id: FieldRef<"CorporateClient", 'Int'>
    readonly userId: FieldRef<"CorporateClient", 'Int'>
    readonly companyName: FieldRef<"CorporateClient", 'String'>
    readonly registrationNumber: FieldRef<"CorporateClient", 'String'>
    readonly address: FieldRef<"CorporateClient", 'String'>
    readonly postCode: FieldRef<"CorporateClient", 'String'>
    readonly industryType: FieldRef<"CorporateClient", 'String'>
    readonly contactPerson: FieldRef<"CorporateClient", 'String'>
    readonly jobTitle: FieldRef<"CorporateClient", 'String'>
    readonly phoneNumber: FieldRef<"CorporateClient", 'String'>
    readonly website: FieldRef<"CorporateClient", 'String'>
    readonly serviceRequirements: FieldRef<"CorporateClient", 'Json'>
    readonly permissions: FieldRef<"CorporateClient", 'Json'>
    readonly createdAt: FieldRef<"CorporateClient", 'DateTime'>
    readonly updatedAt: FieldRef<"CorporateClient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CorporateClient findUnique
   */
  export type CorporateClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateClient
     */
    select?: CorporateClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorporateClient
     */
    omit?: CorporateClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateClientInclude<ExtArgs> | null
    /**
     * Filter, which CorporateClient to fetch.
     */
    where: CorporateClientWhereUniqueInput
  }

  /**
   * CorporateClient findUniqueOrThrow
   */
  export type CorporateClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateClient
     */
    select?: CorporateClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorporateClient
     */
    omit?: CorporateClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateClientInclude<ExtArgs> | null
    /**
     * Filter, which CorporateClient to fetch.
     */
    where: CorporateClientWhereUniqueInput
  }

  /**
   * CorporateClient findFirst
   */
  export type CorporateClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateClient
     */
    select?: CorporateClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorporateClient
     */
    omit?: CorporateClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateClientInclude<ExtArgs> | null
    /**
     * Filter, which CorporateClient to fetch.
     */
    where?: CorporateClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CorporateClients to fetch.
     */
    orderBy?: CorporateClientOrderByWithRelationInput | CorporateClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CorporateClients.
     */
    cursor?: CorporateClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CorporateClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CorporateClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CorporateClients.
     */
    distinct?: CorporateClientScalarFieldEnum | CorporateClientScalarFieldEnum[]
  }

  /**
   * CorporateClient findFirstOrThrow
   */
  export type CorporateClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateClient
     */
    select?: CorporateClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorporateClient
     */
    omit?: CorporateClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateClientInclude<ExtArgs> | null
    /**
     * Filter, which CorporateClient to fetch.
     */
    where?: CorporateClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CorporateClients to fetch.
     */
    orderBy?: CorporateClientOrderByWithRelationInput | CorporateClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CorporateClients.
     */
    cursor?: CorporateClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CorporateClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CorporateClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CorporateClients.
     */
    distinct?: CorporateClientScalarFieldEnum | CorporateClientScalarFieldEnum[]
  }

  /**
   * CorporateClient findMany
   */
  export type CorporateClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateClient
     */
    select?: CorporateClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorporateClient
     */
    omit?: CorporateClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateClientInclude<ExtArgs> | null
    /**
     * Filter, which CorporateClients to fetch.
     */
    where?: CorporateClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CorporateClients to fetch.
     */
    orderBy?: CorporateClientOrderByWithRelationInput | CorporateClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CorporateClients.
     */
    cursor?: CorporateClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CorporateClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CorporateClients.
     */
    skip?: number
    distinct?: CorporateClientScalarFieldEnum | CorporateClientScalarFieldEnum[]
  }

  /**
   * CorporateClient create
   */
  export type CorporateClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateClient
     */
    select?: CorporateClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorporateClient
     */
    omit?: CorporateClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateClientInclude<ExtArgs> | null
    /**
     * The data needed to create a CorporateClient.
     */
    data: XOR<CorporateClientCreateInput, CorporateClientUncheckedCreateInput>
  }

  /**
   * CorporateClient createMany
   */
  export type CorporateClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CorporateClients.
     */
    data: CorporateClientCreateManyInput | CorporateClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CorporateClient createManyAndReturn
   */
  export type CorporateClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateClient
     */
    select?: CorporateClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CorporateClient
     */
    omit?: CorporateClientOmit<ExtArgs> | null
    /**
     * The data used to create many CorporateClients.
     */
    data: CorporateClientCreateManyInput | CorporateClientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateClientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CorporateClient update
   */
  export type CorporateClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateClient
     */
    select?: CorporateClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorporateClient
     */
    omit?: CorporateClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateClientInclude<ExtArgs> | null
    /**
     * The data needed to update a CorporateClient.
     */
    data: XOR<CorporateClientUpdateInput, CorporateClientUncheckedUpdateInput>
    /**
     * Choose, which CorporateClient to update.
     */
    where: CorporateClientWhereUniqueInput
  }

  /**
   * CorporateClient updateMany
   */
  export type CorporateClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CorporateClients.
     */
    data: XOR<CorporateClientUpdateManyMutationInput, CorporateClientUncheckedUpdateManyInput>
    /**
     * Filter which CorporateClients to update
     */
    where?: CorporateClientWhereInput
    /**
     * Limit how many CorporateClients to update.
     */
    limit?: number
  }

  /**
   * CorporateClient updateManyAndReturn
   */
  export type CorporateClientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateClient
     */
    select?: CorporateClientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CorporateClient
     */
    omit?: CorporateClientOmit<ExtArgs> | null
    /**
     * The data used to update CorporateClients.
     */
    data: XOR<CorporateClientUpdateManyMutationInput, CorporateClientUncheckedUpdateManyInput>
    /**
     * Filter which CorporateClients to update
     */
    where?: CorporateClientWhereInput
    /**
     * Limit how many CorporateClients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateClientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CorporateClient upsert
   */
  export type CorporateClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateClient
     */
    select?: CorporateClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorporateClient
     */
    omit?: CorporateClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateClientInclude<ExtArgs> | null
    /**
     * The filter to search for the CorporateClient to update in case it exists.
     */
    where: CorporateClientWhereUniqueInput
    /**
     * In case the CorporateClient found by the `where` argument doesn't exist, create a new CorporateClient with this data.
     */
    create: XOR<CorporateClientCreateInput, CorporateClientUncheckedCreateInput>
    /**
     * In case the CorporateClient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CorporateClientUpdateInput, CorporateClientUncheckedUpdateInput>
  }

  /**
   * CorporateClient delete
   */
  export type CorporateClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateClient
     */
    select?: CorporateClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorporateClient
     */
    omit?: CorporateClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateClientInclude<ExtArgs> | null
    /**
     * Filter which CorporateClient to delete.
     */
    where: CorporateClientWhereUniqueInput
  }

  /**
   * CorporateClient deleteMany
   */
  export type CorporateClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CorporateClients to delete
     */
    where?: CorporateClientWhereInput
    /**
     * Limit how many CorporateClients to delete.
     */
    limit?: number
  }

  /**
   * CorporateClient.corporateAds
   */
  export type CorporateClient$corporateAdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateAd
     */
    select?: CorporateAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorporateAd
     */
    omit?: CorporateAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateAdInclude<ExtArgs> | null
    where?: CorporateAdWhereInput
    orderBy?: CorporateAdOrderByWithRelationInput | CorporateAdOrderByWithRelationInput[]
    cursor?: CorporateAdWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CorporateAdScalarFieldEnum | CorporateAdScalarFieldEnum[]
  }

  /**
   * CorporateClient without action
   */
  export type CorporateClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateClient
     */
    select?: CorporateClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorporateClient
     */
    omit?: CorporateClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateClientInclude<ExtArgs> | null
  }


  /**
   * Model CorporateAd
   */

  export type AggregateCorporateAd = {
    _count: CorporateAdCountAggregateOutputType | null
    _avg: CorporateAdAvgAggregateOutputType | null
    _sum: CorporateAdSumAggregateOutputType | null
    _min: CorporateAdMinAggregateOutputType | null
    _max: CorporateAdMaxAggregateOutputType | null
  }

  export type CorporateAdAvgAggregateOutputType = {
    id: number | null
    corporateClientId: number | null
  }

  export type CorporateAdSumAggregateOutputType = {
    id: number | null
    corporateClientId: number | null
  }

  export type CorporateAdMinAggregateOutputType = {
    id: number | null
    corporateClientId: number | null
    title: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CorporateAdMaxAggregateOutputType = {
    id: number | null
    corporateClientId: number | null
    title: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CorporateAdCountAggregateOutputType = {
    id: number
    corporateClientId: number
    title: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CorporateAdAvgAggregateInputType = {
    id?: true
    corporateClientId?: true
  }

  export type CorporateAdSumAggregateInputType = {
    id?: true
    corporateClientId?: true
  }

  export type CorporateAdMinAggregateInputType = {
    id?: true
    corporateClientId?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CorporateAdMaxAggregateInputType = {
    id?: true
    corporateClientId?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CorporateAdCountAggregateInputType = {
    id?: true
    corporateClientId?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CorporateAdAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CorporateAd to aggregate.
     */
    where?: CorporateAdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CorporateAds to fetch.
     */
    orderBy?: CorporateAdOrderByWithRelationInput | CorporateAdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CorporateAdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CorporateAds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CorporateAds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CorporateAds
    **/
    _count?: true | CorporateAdCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CorporateAdAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CorporateAdSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CorporateAdMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CorporateAdMaxAggregateInputType
  }

  export type GetCorporateAdAggregateType<T extends CorporateAdAggregateArgs> = {
        [P in keyof T & keyof AggregateCorporateAd]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCorporateAd[P]>
      : GetScalarType<T[P], AggregateCorporateAd[P]>
  }




  export type CorporateAdGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CorporateAdWhereInput
    orderBy?: CorporateAdOrderByWithAggregationInput | CorporateAdOrderByWithAggregationInput[]
    by: CorporateAdScalarFieldEnum[] | CorporateAdScalarFieldEnum
    having?: CorporateAdScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CorporateAdCountAggregateInputType | true
    _avg?: CorporateAdAvgAggregateInputType
    _sum?: CorporateAdSumAggregateInputType
    _min?: CorporateAdMinAggregateInputType
    _max?: CorporateAdMaxAggregateInputType
  }

  export type CorporateAdGroupByOutputType = {
    id: number
    corporateClientId: number
    title: string
    description: string
    createdAt: Date
    updatedAt: Date
    _count: CorporateAdCountAggregateOutputType | null
    _avg: CorporateAdAvgAggregateOutputType | null
    _sum: CorporateAdSumAggregateOutputType | null
    _min: CorporateAdMinAggregateOutputType | null
    _max: CorporateAdMaxAggregateOutputType | null
  }

  type GetCorporateAdGroupByPayload<T extends CorporateAdGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CorporateAdGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CorporateAdGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CorporateAdGroupByOutputType[P]>
            : GetScalarType<T[P], CorporateAdGroupByOutputType[P]>
        }
      >
    >


  export type CorporateAdSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    corporateClientId?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    corporateClient?: boolean | CorporateClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["corporateAd"]>

  export type CorporateAdSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    corporateClientId?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    corporateClient?: boolean | CorporateClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["corporateAd"]>

  export type CorporateAdSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    corporateClientId?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    corporateClient?: boolean | CorporateClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["corporateAd"]>

  export type CorporateAdSelectScalar = {
    id?: boolean
    corporateClientId?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CorporateAdOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "corporateClientId" | "title" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["corporateAd"]>
  export type CorporateAdInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    corporateClient?: boolean | CorporateClientDefaultArgs<ExtArgs>
  }
  export type CorporateAdIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    corporateClient?: boolean | CorporateClientDefaultArgs<ExtArgs>
  }
  export type CorporateAdIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    corporateClient?: boolean | CorporateClientDefaultArgs<ExtArgs>
  }

  export type $CorporateAdPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CorporateAd"
    objects: {
      corporateClient: Prisma.$CorporateClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      corporateClientId: number
      title: string
      description: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["corporateAd"]>
    composites: {}
  }

  type CorporateAdGetPayload<S extends boolean | null | undefined | CorporateAdDefaultArgs> = $Result.GetResult<Prisma.$CorporateAdPayload, S>

  type CorporateAdCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CorporateAdFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CorporateAdCountAggregateInputType | true
    }

  export interface CorporateAdDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CorporateAd'], meta: { name: 'CorporateAd' } }
    /**
     * Find zero or one CorporateAd that matches the filter.
     * @param {CorporateAdFindUniqueArgs} args - Arguments to find a CorporateAd
     * @example
     * // Get one CorporateAd
     * const corporateAd = await prisma.corporateAd.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CorporateAdFindUniqueArgs>(args: SelectSubset<T, CorporateAdFindUniqueArgs<ExtArgs>>): Prisma__CorporateAdClient<$Result.GetResult<Prisma.$CorporateAdPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CorporateAd that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CorporateAdFindUniqueOrThrowArgs} args - Arguments to find a CorporateAd
     * @example
     * // Get one CorporateAd
     * const corporateAd = await prisma.corporateAd.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CorporateAdFindUniqueOrThrowArgs>(args: SelectSubset<T, CorporateAdFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CorporateAdClient<$Result.GetResult<Prisma.$CorporateAdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CorporateAd that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateAdFindFirstArgs} args - Arguments to find a CorporateAd
     * @example
     * // Get one CorporateAd
     * const corporateAd = await prisma.corporateAd.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CorporateAdFindFirstArgs>(args?: SelectSubset<T, CorporateAdFindFirstArgs<ExtArgs>>): Prisma__CorporateAdClient<$Result.GetResult<Prisma.$CorporateAdPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CorporateAd that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateAdFindFirstOrThrowArgs} args - Arguments to find a CorporateAd
     * @example
     * // Get one CorporateAd
     * const corporateAd = await prisma.corporateAd.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CorporateAdFindFirstOrThrowArgs>(args?: SelectSubset<T, CorporateAdFindFirstOrThrowArgs<ExtArgs>>): Prisma__CorporateAdClient<$Result.GetResult<Prisma.$CorporateAdPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CorporateAds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateAdFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CorporateAds
     * const corporateAds = await prisma.corporateAd.findMany()
     * 
     * // Get first 10 CorporateAds
     * const corporateAds = await prisma.corporateAd.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const corporateAdWithIdOnly = await prisma.corporateAd.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CorporateAdFindManyArgs>(args?: SelectSubset<T, CorporateAdFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorporateAdPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CorporateAd.
     * @param {CorporateAdCreateArgs} args - Arguments to create a CorporateAd.
     * @example
     * // Create one CorporateAd
     * const CorporateAd = await prisma.corporateAd.create({
     *   data: {
     *     // ... data to create a CorporateAd
     *   }
     * })
     * 
     */
    create<T extends CorporateAdCreateArgs>(args: SelectSubset<T, CorporateAdCreateArgs<ExtArgs>>): Prisma__CorporateAdClient<$Result.GetResult<Prisma.$CorporateAdPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CorporateAds.
     * @param {CorporateAdCreateManyArgs} args - Arguments to create many CorporateAds.
     * @example
     * // Create many CorporateAds
     * const corporateAd = await prisma.corporateAd.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CorporateAdCreateManyArgs>(args?: SelectSubset<T, CorporateAdCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CorporateAds and returns the data saved in the database.
     * @param {CorporateAdCreateManyAndReturnArgs} args - Arguments to create many CorporateAds.
     * @example
     * // Create many CorporateAds
     * const corporateAd = await prisma.corporateAd.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CorporateAds and only return the `id`
     * const corporateAdWithIdOnly = await prisma.corporateAd.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CorporateAdCreateManyAndReturnArgs>(args?: SelectSubset<T, CorporateAdCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorporateAdPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CorporateAd.
     * @param {CorporateAdDeleteArgs} args - Arguments to delete one CorporateAd.
     * @example
     * // Delete one CorporateAd
     * const CorporateAd = await prisma.corporateAd.delete({
     *   where: {
     *     // ... filter to delete one CorporateAd
     *   }
     * })
     * 
     */
    delete<T extends CorporateAdDeleteArgs>(args: SelectSubset<T, CorporateAdDeleteArgs<ExtArgs>>): Prisma__CorporateAdClient<$Result.GetResult<Prisma.$CorporateAdPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CorporateAd.
     * @param {CorporateAdUpdateArgs} args - Arguments to update one CorporateAd.
     * @example
     * // Update one CorporateAd
     * const corporateAd = await prisma.corporateAd.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CorporateAdUpdateArgs>(args: SelectSubset<T, CorporateAdUpdateArgs<ExtArgs>>): Prisma__CorporateAdClient<$Result.GetResult<Prisma.$CorporateAdPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CorporateAds.
     * @param {CorporateAdDeleteManyArgs} args - Arguments to filter CorporateAds to delete.
     * @example
     * // Delete a few CorporateAds
     * const { count } = await prisma.corporateAd.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CorporateAdDeleteManyArgs>(args?: SelectSubset<T, CorporateAdDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CorporateAds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateAdUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CorporateAds
     * const corporateAd = await prisma.corporateAd.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CorporateAdUpdateManyArgs>(args: SelectSubset<T, CorporateAdUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CorporateAds and returns the data updated in the database.
     * @param {CorporateAdUpdateManyAndReturnArgs} args - Arguments to update many CorporateAds.
     * @example
     * // Update many CorporateAds
     * const corporateAd = await prisma.corporateAd.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CorporateAds and only return the `id`
     * const corporateAdWithIdOnly = await prisma.corporateAd.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CorporateAdUpdateManyAndReturnArgs>(args: SelectSubset<T, CorporateAdUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorporateAdPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CorporateAd.
     * @param {CorporateAdUpsertArgs} args - Arguments to update or create a CorporateAd.
     * @example
     * // Update or create a CorporateAd
     * const corporateAd = await prisma.corporateAd.upsert({
     *   create: {
     *     // ... data to create a CorporateAd
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CorporateAd we want to update
     *   }
     * })
     */
    upsert<T extends CorporateAdUpsertArgs>(args: SelectSubset<T, CorporateAdUpsertArgs<ExtArgs>>): Prisma__CorporateAdClient<$Result.GetResult<Prisma.$CorporateAdPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CorporateAds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateAdCountArgs} args - Arguments to filter CorporateAds to count.
     * @example
     * // Count the number of CorporateAds
     * const count = await prisma.corporateAd.count({
     *   where: {
     *     // ... the filter for the CorporateAds we want to count
     *   }
     * })
    **/
    count<T extends CorporateAdCountArgs>(
      args?: Subset<T, CorporateAdCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CorporateAdCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CorporateAd.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateAdAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CorporateAdAggregateArgs>(args: Subset<T, CorporateAdAggregateArgs>): Prisma.PrismaPromise<GetCorporateAdAggregateType<T>>

    /**
     * Group by CorporateAd.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateAdGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CorporateAdGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CorporateAdGroupByArgs['orderBy'] }
        : { orderBy?: CorporateAdGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CorporateAdGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCorporateAdGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CorporateAd model
   */
  readonly fields: CorporateAdFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CorporateAd.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CorporateAdClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    corporateClient<T extends CorporateClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CorporateClientDefaultArgs<ExtArgs>>): Prisma__CorporateClientClient<$Result.GetResult<Prisma.$CorporateClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CorporateAd model
   */
  interface CorporateAdFieldRefs {
    readonly id: FieldRef<"CorporateAd", 'Int'>
    readonly corporateClientId: FieldRef<"CorporateAd", 'Int'>
    readonly title: FieldRef<"CorporateAd", 'String'>
    readonly description: FieldRef<"CorporateAd", 'String'>
    readonly createdAt: FieldRef<"CorporateAd", 'DateTime'>
    readonly updatedAt: FieldRef<"CorporateAd", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CorporateAd findUnique
   */
  export type CorporateAdFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateAd
     */
    select?: CorporateAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorporateAd
     */
    omit?: CorporateAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateAdInclude<ExtArgs> | null
    /**
     * Filter, which CorporateAd to fetch.
     */
    where: CorporateAdWhereUniqueInput
  }

  /**
   * CorporateAd findUniqueOrThrow
   */
  export type CorporateAdFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateAd
     */
    select?: CorporateAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorporateAd
     */
    omit?: CorporateAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateAdInclude<ExtArgs> | null
    /**
     * Filter, which CorporateAd to fetch.
     */
    where: CorporateAdWhereUniqueInput
  }

  /**
   * CorporateAd findFirst
   */
  export type CorporateAdFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateAd
     */
    select?: CorporateAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorporateAd
     */
    omit?: CorporateAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateAdInclude<ExtArgs> | null
    /**
     * Filter, which CorporateAd to fetch.
     */
    where?: CorporateAdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CorporateAds to fetch.
     */
    orderBy?: CorporateAdOrderByWithRelationInput | CorporateAdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CorporateAds.
     */
    cursor?: CorporateAdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CorporateAds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CorporateAds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CorporateAds.
     */
    distinct?: CorporateAdScalarFieldEnum | CorporateAdScalarFieldEnum[]
  }

  /**
   * CorporateAd findFirstOrThrow
   */
  export type CorporateAdFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateAd
     */
    select?: CorporateAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorporateAd
     */
    omit?: CorporateAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateAdInclude<ExtArgs> | null
    /**
     * Filter, which CorporateAd to fetch.
     */
    where?: CorporateAdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CorporateAds to fetch.
     */
    orderBy?: CorporateAdOrderByWithRelationInput | CorporateAdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CorporateAds.
     */
    cursor?: CorporateAdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CorporateAds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CorporateAds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CorporateAds.
     */
    distinct?: CorporateAdScalarFieldEnum | CorporateAdScalarFieldEnum[]
  }

  /**
   * CorporateAd findMany
   */
  export type CorporateAdFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateAd
     */
    select?: CorporateAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorporateAd
     */
    omit?: CorporateAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateAdInclude<ExtArgs> | null
    /**
     * Filter, which CorporateAds to fetch.
     */
    where?: CorporateAdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CorporateAds to fetch.
     */
    orderBy?: CorporateAdOrderByWithRelationInput | CorporateAdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CorporateAds.
     */
    cursor?: CorporateAdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CorporateAds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CorporateAds.
     */
    skip?: number
    distinct?: CorporateAdScalarFieldEnum | CorporateAdScalarFieldEnum[]
  }

  /**
   * CorporateAd create
   */
  export type CorporateAdCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateAd
     */
    select?: CorporateAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorporateAd
     */
    omit?: CorporateAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateAdInclude<ExtArgs> | null
    /**
     * The data needed to create a CorporateAd.
     */
    data: XOR<CorporateAdCreateInput, CorporateAdUncheckedCreateInput>
  }

  /**
   * CorporateAd createMany
   */
  export type CorporateAdCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CorporateAds.
     */
    data: CorporateAdCreateManyInput | CorporateAdCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CorporateAd createManyAndReturn
   */
  export type CorporateAdCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateAd
     */
    select?: CorporateAdSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CorporateAd
     */
    omit?: CorporateAdOmit<ExtArgs> | null
    /**
     * The data used to create many CorporateAds.
     */
    data: CorporateAdCreateManyInput | CorporateAdCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateAdIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CorporateAd update
   */
  export type CorporateAdUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateAd
     */
    select?: CorporateAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorporateAd
     */
    omit?: CorporateAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateAdInclude<ExtArgs> | null
    /**
     * The data needed to update a CorporateAd.
     */
    data: XOR<CorporateAdUpdateInput, CorporateAdUncheckedUpdateInput>
    /**
     * Choose, which CorporateAd to update.
     */
    where: CorporateAdWhereUniqueInput
  }

  /**
   * CorporateAd updateMany
   */
  export type CorporateAdUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CorporateAds.
     */
    data: XOR<CorporateAdUpdateManyMutationInput, CorporateAdUncheckedUpdateManyInput>
    /**
     * Filter which CorporateAds to update
     */
    where?: CorporateAdWhereInput
    /**
     * Limit how many CorporateAds to update.
     */
    limit?: number
  }

  /**
   * CorporateAd updateManyAndReturn
   */
  export type CorporateAdUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateAd
     */
    select?: CorporateAdSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CorporateAd
     */
    omit?: CorporateAdOmit<ExtArgs> | null
    /**
     * The data used to update CorporateAds.
     */
    data: XOR<CorporateAdUpdateManyMutationInput, CorporateAdUncheckedUpdateManyInput>
    /**
     * Filter which CorporateAds to update
     */
    where?: CorporateAdWhereInput
    /**
     * Limit how many CorporateAds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateAdIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CorporateAd upsert
   */
  export type CorporateAdUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateAd
     */
    select?: CorporateAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorporateAd
     */
    omit?: CorporateAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateAdInclude<ExtArgs> | null
    /**
     * The filter to search for the CorporateAd to update in case it exists.
     */
    where: CorporateAdWhereUniqueInput
    /**
     * In case the CorporateAd found by the `where` argument doesn't exist, create a new CorporateAd with this data.
     */
    create: XOR<CorporateAdCreateInput, CorporateAdUncheckedCreateInput>
    /**
     * In case the CorporateAd was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CorporateAdUpdateInput, CorporateAdUncheckedUpdateInput>
  }

  /**
   * CorporateAd delete
   */
  export type CorporateAdDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateAd
     */
    select?: CorporateAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorporateAd
     */
    omit?: CorporateAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateAdInclude<ExtArgs> | null
    /**
     * Filter which CorporateAd to delete.
     */
    where: CorporateAdWhereUniqueInput
  }

  /**
   * CorporateAd deleteMany
   */
  export type CorporateAdDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CorporateAds to delete
     */
    where?: CorporateAdWhereInput
    /**
     * Limit how many CorporateAds to delete.
     */
    limit?: number
  }

  /**
   * CorporateAd without action
   */
  export type CorporateAdDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateAd
     */
    select?: CorporateAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorporateAd
     */
    omit?: CorporateAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateAdInclude<ExtArgs> | null
  }


  /**
   * Model CourseAd
   */

  export type AggregateCourseAd = {
    _count: CourseAdCountAggregateOutputType | null
    _avg: CourseAdAvgAggregateOutputType | null
    _sum: CourseAdSumAggregateOutputType | null
    _min: CourseAdMinAggregateOutputType | null
    _max: CourseAdMaxAggregateOutputType | null
  }

  export type CourseAdAvgAggregateOutputType = {
    id: number | null
    courseProviderId: number | null
  }

  export type CourseAdSumAggregateOutputType = {
    id: number | null
    courseProviderId: number | null
  }

  export type CourseAdMinAggregateOutputType = {
    id: number | null
    courseProviderId: number | null
    title: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseAdMaxAggregateOutputType = {
    id: number | null
    courseProviderId: number | null
    title: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseAdCountAggregateOutputType = {
    id: number
    courseProviderId: number
    title: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CourseAdAvgAggregateInputType = {
    id?: true
    courseProviderId?: true
  }

  export type CourseAdSumAggregateInputType = {
    id?: true
    courseProviderId?: true
  }

  export type CourseAdMinAggregateInputType = {
    id?: true
    courseProviderId?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseAdMaxAggregateInputType = {
    id?: true
    courseProviderId?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseAdCountAggregateInputType = {
    id?: true
    courseProviderId?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CourseAdAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseAd to aggregate.
     */
    where?: CourseAdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseAds to fetch.
     */
    orderBy?: CourseAdOrderByWithRelationInput | CourseAdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseAdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseAds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseAds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseAds
    **/
    _count?: true | CourseAdCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseAdAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseAdSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseAdMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseAdMaxAggregateInputType
  }

  export type GetCourseAdAggregateType<T extends CourseAdAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseAd]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseAd[P]>
      : GetScalarType<T[P], AggregateCourseAd[P]>
  }




  export type CourseAdGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseAdWhereInput
    orderBy?: CourseAdOrderByWithAggregationInput | CourseAdOrderByWithAggregationInput[]
    by: CourseAdScalarFieldEnum[] | CourseAdScalarFieldEnum
    having?: CourseAdScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseAdCountAggregateInputType | true
    _avg?: CourseAdAvgAggregateInputType
    _sum?: CourseAdSumAggregateInputType
    _min?: CourseAdMinAggregateInputType
    _max?: CourseAdMaxAggregateInputType
  }

  export type CourseAdGroupByOutputType = {
    id: number
    courseProviderId: number
    title: string
    description: string
    createdAt: Date
    updatedAt: Date
    _count: CourseAdCountAggregateOutputType | null
    _avg: CourseAdAvgAggregateOutputType | null
    _sum: CourseAdSumAggregateOutputType | null
    _min: CourseAdMinAggregateOutputType | null
    _max: CourseAdMaxAggregateOutputType | null
  }

  type GetCourseAdGroupByPayload<T extends CourseAdGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseAdGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseAdGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseAdGroupByOutputType[P]>
            : GetScalarType<T[P], CourseAdGroupByOutputType[P]>
        }
      >
    >


  export type CourseAdSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseProviderId?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    courseProvider?: boolean | CourseProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseAd"]>

  export type CourseAdSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseProviderId?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    courseProvider?: boolean | CourseProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseAd"]>

  export type CourseAdSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseProviderId?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    courseProvider?: boolean | CourseProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseAd"]>

  export type CourseAdSelectScalar = {
    id?: boolean
    courseProviderId?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CourseAdOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courseProviderId" | "title" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["courseAd"]>
  export type CourseAdInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courseProvider?: boolean | CourseProviderDefaultArgs<ExtArgs>
  }
  export type CourseAdIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courseProvider?: boolean | CourseProviderDefaultArgs<ExtArgs>
  }
  export type CourseAdIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courseProvider?: boolean | CourseProviderDefaultArgs<ExtArgs>
  }

  export type $CourseAdPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseAd"
    objects: {
      courseProvider: Prisma.$CourseProviderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      courseProviderId: number
      title: string
      description: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["courseAd"]>
    composites: {}
  }

  type CourseAdGetPayload<S extends boolean | null | undefined | CourseAdDefaultArgs> = $Result.GetResult<Prisma.$CourseAdPayload, S>

  type CourseAdCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseAdFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseAdCountAggregateInputType | true
    }

  export interface CourseAdDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseAd'], meta: { name: 'CourseAd' } }
    /**
     * Find zero or one CourseAd that matches the filter.
     * @param {CourseAdFindUniqueArgs} args - Arguments to find a CourseAd
     * @example
     * // Get one CourseAd
     * const courseAd = await prisma.courseAd.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseAdFindUniqueArgs>(args: SelectSubset<T, CourseAdFindUniqueArgs<ExtArgs>>): Prisma__CourseAdClient<$Result.GetResult<Prisma.$CourseAdPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourseAd that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseAdFindUniqueOrThrowArgs} args - Arguments to find a CourseAd
     * @example
     * // Get one CourseAd
     * const courseAd = await prisma.courseAd.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseAdFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseAdFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseAdClient<$Result.GetResult<Prisma.$CourseAdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseAd that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAdFindFirstArgs} args - Arguments to find a CourseAd
     * @example
     * // Get one CourseAd
     * const courseAd = await prisma.courseAd.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseAdFindFirstArgs>(args?: SelectSubset<T, CourseAdFindFirstArgs<ExtArgs>>): Prisma__CourseAdClient<$Result.GetResult<Prisma.$CourseAdPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseAd that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAdFindFirstOrThrowArgs} args - Arguments to find a CourseAd
     * @example
     * // Get one CourseAd
     * const courseAd = await prisma.courseAd.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseAdFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseAdFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseAdClient<$Result.GetResult<Prisma.$CourseAdPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourseAds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAdFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseAds
     * const courseAds = await prisma.courseAd.findMany()
     * 
     * // Get first 10 CourseAds
     * const courseAds = await prisma.courseAd.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseAdWithIdOnly = await prisma.courseAd.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseAdFindManyArgs>(args?: SelectSubset<T, CourseAdFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseAdPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourseAd.
     * @param {CourseAdCreateArgs} args - Arguments to create a CourseAd.
     * @example
     * // Create one CourseAd
     * const CourseAd = await prisma.courseAd.create({
     *   data: {
     *     // ... data to create a CourseAd
     *   }
     * })
     * 
     */
    create<T extends CourseAdCreateArgs>(args: SelectSubset<T, CourseAdCreateArgs<ExtArgs>>): Prisma__CourseAdClient<$Result.GetResult<Prisma.$CourseAdPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourseAds.
     * @param {CourseAdCreateManyArgs} args - Arguments to create many CourseAds.
     * @example
     * // Create many CourseAds
     * const courseAd = await prisma.courseAd.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseAdCreateManyArgs>(args?: SelectSubset<T, CourseAdCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseAds and returns the data saved in the database.
     * @param {CourseAdCreateManyAndReturnArgs} args - Arguments to create many CourseAds.
     * @example
     * // Create many CourseAds
     * const courseAd = await prisma.courseAd.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseAds and only return the `id`
     * const courseAdWithIdOnly = await prisma.courseAd.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseAdCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseAdCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseAdPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CourseAd.
     * @param {CourseAdDeleteArgs} args - Arguments to delete one CourseAd.
     * @example
     * // Delete one CourseAd
     * const CourseAd = await prisma.courseAd.delete({
     *   where: {
     *     // ... filter to delete one CourseAd
     *   }
     * })
     * 
     */
    delete<T extends CourseAdDeleteArgs>(args: SelectSubset<T, CourseAdDeleteArgs<ExtArgs>>): Prisma__CourseAdClient<$Result.GetResult<Prisma.$CourseAdPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourseAd.
     * @param {CourseAdUpdateArgs} args - Arguments to update one CourseAd.
     * @example
     * // Update one CourseAd
     * const courseAd = await prisma.courseAd.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseAdUpdateArgs>(args: SelectSubset<T, CourseAdUpdateArgs<ExtArgs>>): Prisma__CourseAdClient<$Result.GetResult<Prisma.$CourseAdPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourseAds.
     * @param {CourseAdDeleteManyArgs} args - Arguments to filter CourseAds to delete.
     * @example
     * // Delete a few CourseAds
     * const { count } = await prisma.courseAd.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseAdDeleteManyArgs>(args?: SelectSubset<T, CourseAdDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseAds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAdUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseAds
     * const courseAd = await prisma.courseAd.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseAdUpdateManyArgs>(args: SelectSubset<T, CourseAdUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseAds and returns the data updated in the database.
     * @param {CourseAdUpdateManyAndReturnArgs} args - Arguments to update many CourseAds.
     * @example
     * // Update many CourseAds
     * const courseAd = await prisma.courseAd.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CourseAds and only return the `id`
     * const courseAdWithIdOnly = await prisma.courseAd.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseAdUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseAdUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseAdPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CourseAd.
     * @param {CourseAdUpsertArgs} args - Arguments to update or create a CourseAd.
     * @example
     * // Update or create a CourseAd
     * const courseAd = await prisma.courseAd.upsert({
     *   create: {
     *     // ... data to create a CourseAd
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseAd we want to update
     *   }
     * })
     */
    upsert<T extends CourseAdUpsertArgs>(args: SelectSubset<T, CourseAdUpsertArgs<ExtArgs>>): Prisma__CourseAdClient<$Result.GetResult<Prisma.$CourseAdPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourseAds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAdCountArgs} args - Arguments to filter CourseAds to count.
     * @example
     * // Count the number of CourseAds
     * const count = await prisma.courseAd.count({
     *   where: {
     *     // ... the filter for the CourseAds we want to count
     *   }
     * })
    **/
    count<T extends CourseAdCountArgs>(
      args?: Subset<T, CourseAdCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseAdCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseAd.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAdAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAdAggregateArgs>(args: Subset<T, CourseAdAggregateArgs>): Prisma.PrismaPromise<GetCourseAdAggregateType<T>>

    /**
     * Group by CourseAd.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAdGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseAdGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseAdGroupByArgs['orderBy'] }
        : { orderBy?: CourseAdGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseAdGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseAdGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseAd model
   */
  readonly fields: CourseAdFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseAd.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseAdClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courseProvider<T extends CourseProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseProviderDefaultArgs<ExtArgs>>): Prisma__CourseProviderClient<$Result.GetResult<Prisma.$CourseProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseAd model
   */
  interface CourseAdFieldRefs {
    readonly id: FieldRef<"CourseAd", 'Int'>
    readonly courseProviderId: FieldRef<"CourseAd", 'Int'>
    readonly title: FieldRef<"CourseAd", 'String'>
    readonly description: FieldRef<"CourseAd", 'String'>
    readonly createdAt: FieldRef<"CourseAd", 'DateTime'>
    readonly updatedAt: FieldRef<"CourseAd", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CourseAd findUnique
   */
  export type CourseAdFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseAd
     */
    select?: CourseAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseAd
     */
    omit?: CourseAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseAdInclude<ExtArgs> | null
    /**
     * Filter, which CourseAd to fetch.
     */
    where: CourseAdWhereUniqueInput
  }

  /**
   * CourseAd findUniqueOrThrow
   */
  export type CourseAdFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseAd
     */
    select?: CourseAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseAd
     */
    omit?: CourseAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseAdInclude<ExtArgs> | null
    /**
     * Filter, which CourseAd to fetch.
     */
    where: CourseAdWhereUniqueInput
  }

  /**
   * CourseAd findFirst
   */
  export type CourseAdFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseAd
     */
    select?: CourseAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseAd
     */
    omit?: CourseAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseAdInclude<ExtArgs> | null
    /**
     * Filter, which CourseAd to fetch.
     */
    where?: CourseAdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseAds to fetch.
     */
    orderBy?: CourseAdOrderByWithRelationInput | CourseAdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseAds.
     */
    cursor?: CourseAdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseAds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseAds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseAds.
     */
    distinct?: CourseAdScalarFieldEnum | CourseAdScalarFieldEnum[]
  }

  /**
   * CourseAd findFirstOrThrow
   */
  export type CourseAdFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseAd
     */
    select?: CourseAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseAd
     */
    omit?: CourseAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseAdInclude<ExtArgs> | null
    /**
     * Filter, which CourseAd to fetch.
     */
    where?: CourseAdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseAds to fetch.
     */
    orderBy?: CourseAdOrderByWithRelationInput | CourseAdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseAds.
     */
    cursor?: CourseAdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseAds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseAds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseAds.
     */
    distinct?: CourseAdScalarFieldEnum | CourseAdScalarFieldEnum[]
  }

  /**
   * CourseAd findMany
   */
  export type CourseAdFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseAd
     */
    select?: CourseAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseAd
     */
    omit?: CourseAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseAdInclude<ExtArgs> | null
    /**
     * Filter, which CourseAds to fetch.
     */
    where?: CourseAdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseAds to fetch.
     */
    orderBy?: CourseAdOrderByWithRelationInput | CourseAdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseAds.
     */
    cursor?: CourseAdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseAds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseAds.
     */
    skip?: number
    distinct?: CourseAdScalarFieldEnum | CourseAdScalarFieldEnum[]
  }

  /**
   * CourseAd create
   */
  export type CourseAdCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseAd
     */
    select?: CourseAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseAd
     */
    omit?: CourseAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseAdInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseAd.
     */
    data: XOR<CourseAdCreateInput, CourseAdUncheckedCreateInput>
  }

  /**
   * CourseAd createMany
   */
  export type CourseAdCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseAds.
     */
    data: CourseAdCreateManyInput | CourseAdCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseAd createManyAndReturn
   */
  export type CourseAdCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseAd
     */
    select?: CourseAdSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseAd
     */
    omit?: CourseAdOmit<ExtArgs> | null
    /**
     * The data used to create many CourseAds.
     */
    data: CourseAdCreateManyInput | CourseAdCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseAdIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseAd update
   */
  export type CourseAdUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseAd
     */
    select?: CourseAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseAd
     */
    omit?: CourseAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseAdInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseAd.
     */
    data: XOR<CourseAdUpdateInput, CourseAdUncheckedUpdateInput>
    /**
     * Choose, which CourseAd to update.
     */
    where: CourseAdWhereUniqueInput
  }

  /**
   * CourseAd updateMany
   */
  export type CourseAdUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseAds.
     */
    data: XOR<CourseAdUpdateManyMutationInput, CourseAdUncheckedUpdateManyInput>
    /**
     * Filter which CourseAds to update
     */
    where?: CourseAdWhereInput
    /**
     * Limit how many CourseAds to update.
     */
    limit?: number
  }

  /**
   * CourseAd updateManyAndReturn
   */
  export type CourseAdUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseAd
     */
    select?: CourseAdSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseAd
     */
    omit?: CourseAdOmit<ExtArgs> | null
    /**
     * The data used to update CourseAds.
     */
    data: XOR<CourseAdUpdateManyMutationInput, CourseAdUncheckedUpdateManyInput>
    /**
     * Filter which CourseAds to update
     */
    where?: CourseAdWhereInput
    /**
     * Limit how many CourseAds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseAdIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseAd upsert
   */
  export type CourseAdUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseAd
     */
    select?: CourseAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseAd
     */
    omit?: CourseAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseAdInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseAd to update in case it exists.
     */
    where: CourseAdWhereUniqueInput
    /**
     * In case the CourseAd found by the `where` argument doesn't exist, create a new CourseAd with this data.
     */
    create: XOR<CourseAdCreateInput, CourseAdUncheckedCreateInput>
    /**
     * In case the CourseAd was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseAdUpdateInput, CourseAdUncheckedUpdateInput>
  }

  /**
   * CourseAd delete
   */
  export type CourseAdDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseAd
     */
    select?: CourseAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseAd
     */
    omit?: CourseAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseAdInclude<ExtArgs> | null
    /**
     * Filter which CourseAd to delete.
     */
    where: CourseAdWhereUniqueInput
  }

  /**
   * CourseAd deleteMany
   */
  export type CourseAdDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseAds to delete
     */
    where?: CourseAdWhereInput
    /**
     * Limit how many CourseAds to delete.
     */
    limit?: number
  }

  /**
   * CourseAd without action
   */
  export type CourseAdDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseAd
     */
    select?: CourseAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseAd
     */
    omit?: CourseAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseAdInclude<ExtArgs> | null
  }


  /**
   * Model ServiceAd
   */

  export type AggregateServiceAd = {
    _count: ServiceAdCountAggregateOutputType | null
    _avg: ServiceAdAvgAggregateOutputType | null
    _sum: ServiceAdSumAggregateOutputType | null
    _min: ServiceAdMinAggregateOutputType | null
    _max: ServiceAdMaxAggregateOutputType | null
  }

  export type ServiceAdAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
    salaryRate: number | null
  }

  export type ServiceAdSumAggregateOutputType = {
    id: number | null
    companyId: number | null
    salaryRate: number | null
  }

  export type ServiceAdMinAggregateOutputType = {
    id: number | null
    companyId: number | null
    jobTitle: string | null
    jobType: string | null
    industryCategory: string | null
    region: string | null
    postcode: string | null
    salaryRate: number | null
    salaryType: string | null
    jobDescription: string | null
    requiredExperience: string | null
    requiredLicences: string | null
    shiftAndHours: string | null
    startDate: Date | null
    deadline: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceAdMaxAggregateOutputType = {
    id: number | null
    companyId: number | null
    jobTitle: string | null
    jobType: string | null
    industryCategory: string | null
    region: string | null
    postcode: string | null
    salaryRate: number | null
    salaryType: string | null
    jobDescription: string | null
    requiredExperience: string | null
    requiredLicences: string | null
    shiftAndHours: string | null
    startDate: Date | null
    deadline: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceAdCountAggregateOutputType = {
    id: number
    companyId: number
    jobTitle: number
    jobType: number
    industryCategory: number
    region: number
    postcode: number
    salaryRate: number
    salaryType: number
    jobDescription: number
    requiredExperience: number
    requiredLicences: number
    shiftAndHours: number
    startDate: number
    deadline: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceAdAvgAggregateInputType = {
    id?: true
    companyId?: true
    salaryRate?: true
  }

  export type ServiceAdSumAggregateInputType = {
    id?: true
    companyId?: true
    salaryRate?: true
  }

  export type ServiceAdMinAggregateInputType = {
    id?: true
    companyId?: true
    jobTitle?: true
    jobType?: true
    industryCategory?: true
    region?: true
    postcode?: true
    salaryRate?: true
    salaryType?: true
    jobDescription?: true
    requiredExperience?: true
    requiredLicences?: true
    shiftAndHours?: true
    startDate?: true
    deadline?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceAdMaxAggregateInputType = {
    id?: true
    companyId?: true
    jobTitle?: true
    jobType?: true
    industryCategory?: true
    region?: true
    postcode?: true
    salaryRate?: true
    salaryType?: true
    jobDescription?: true
    requiredExperience?: true
    requiredLicences?: true
    shiftAndHours?: true
    startDate?: true
    deadline?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceAdCountAggregateInputType = {
    id?: true
    companyId?: true
    jobTitle?: true
    jobType?: true
    industryCategory?: true
    region?: true
    postcode?: true
    salaryRate?: true
    salaryType?: true
    jobDescription?: true
    requiredExperience?: true
    requiredLicences?: true
    shiftAndHours?: true
    startDate?: true
    deadline?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceAdAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceAd to aggregate.
     */
    where?: ServiceAdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceAds to fetch.
     */
    orderBy?: ServiceAdOrderByWithRelationInput | ServiceAdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceAdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceAds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceAds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceAds
    **/
    _count?: true | ServiceAdCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAdAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceAdSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceAdMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceAdMaxAggregateInputType
  }

  export type GetServiceAdAggregateType<T extends ServiceAdAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceAd]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceAd[P]>
      : GetScalarType<T[P], AggregateServiceAd[P]>
  }




  export type ServiceAdGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceAdWhereInput
    orderBy?: ServiceAdOrderByWithAggregationInput | ServiceAdOrderByWithAggregationInput[]
    by: ServiceAdScalarFieldEnum[] | ServiceAdScalarFieldEnum
    having?: ServiceAdScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceAdCountAggregateInputType | true
    _avg?: ServiceAdAvgAggregateInputType
    _sum?: ServiceAdSumAggregateInputType
    _min?: ServiceAdMinAggregateInputType
    _max?: ServiceAdMaxAggregateInputType
  }

  export type ServiceAdGroupByOutputType = {
    id: number
    companyId: number
    jobTitle: string
    jobType: string
    industryCategory: string
    region: string
    postcode: string
    salaryRate: number
    salaryType: string
    jobDescription: string
    requiredExperience: string
    requiredLicences: string | null
    shiftAndHours: string | null
    startDate: Date | null
    deadline: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ServiceAdCountAggregateOutputType | null
    _avg: ServiceAdAvgAggregateOutputType | null
    _sum: ServiceAdSumAggregateOutputType | null
    _min: ServiceAdMinAggregateOutputType | null
    _max: ServiceAdMaxAggregateOutputType | null
  }

  type GetServiceAdGroupByPayload<T extends ServiceAdGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceAdGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceAdGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceAdGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceAdGroupByOutputType[P]>
        }
      >
    >


  export type ServiceAdSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    jobTitle?: boolean
    jobType?: boolean
    industryCategory?: boolean
    region?: boolean
    postcode?: boolean
    salaryRate?: boolean
    salaryType?: boolean
    jobDescription?: boolean
    requiredExperience?: boolean
    requiredLicences?: boolean
    shiftAndHours?: boolean
    startDate?: boolean
    deadline?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | SecurityCompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceAd"]>

  export type ServiceAdSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    jobTitle?: boolean
    jobType?: boolean
    industryCategory?: boolean
    region?: boolean
    postcode?: boolean
    salaryRate?: boolean
    salaryType?: boolean
    jobDescription?: boolean
    requiredExperience?: boolean
    requiredLicences?: boolean
    shiftAndHours?: boolean
    startDate?: boolean
    deadline?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | SecurityCompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceAd"]>

  export type ServiceAdSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    jobTitle?: boolean
    jobType?: boolean
    industryCategory?: boolean
    region?: boolean
    postcode?: boolean
    salaryRate?: boolean
    salaryType?: boolean
    jobDescription?: boolean
    requiredExperience?: boolean
    requiredLicences?: boolean
    shiftAndHours?: boolean
    startDate?: boolean
    deadline?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | SecurityCompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceAd"]>

  export type ServiceAdSelectScalar = {
    id?: boolean
    companyId?: boolean
    jobTitle?: boolean
    jobType?: boolean
    industryCategory?: boolean
    region?: boolean
    postcode?: boolean
    salaryRate?: boolean
    salaryType?: boolean
    jobDescription?: boolean
    requiredExperience?: boolean
    requiredLicences?: boolean
    shiftAndHours?: boolean
    startDate?: boolean
    deadline?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceAdOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "jobTitle" | "jobType" | "industryCategory" | "region" | "postcode" | "salaryRate" | "salaryType" | "jobDescription" | "requiredExperience" | "requiredLicences" | "shiftAndHours" | "startDate" | "deadline" | "createdAt" | "updatedAt", ExtArgs["result"]["serviceAd"]>
  export type ServiceAdInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | SecurityCompanyDefaultArgs<ExtArgs>
  }
  export type ServiceAdIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | SecurityCompanyDefaultArgs<ExtArgs>
  }
  export type ServiceAdIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | SecurityCompanyDefaultArgs<ExtArgs>
  }

  export type $ServiceAdPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceAd"
    objects: {
      company: Prisma.$SecurityCompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      companyId: number
      jobTitle: string
      jobType: string
      industryCategory: string
      region: string
      postcode: string
      salaryRate: number
      salaryType: string
      jobDescription: string
      requiredExperience: string
      requiredLicences: string | null
      shiftAndHours: string | null
      startDate: Date | null
      deadline: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["serviceAd"]>
    composites: {}
  }

  type ServiceAdGetPayload<S extends boolean | null | undefined | ServiceAdDefaultArgs> = $Result.GetResult<Prisma.$ServiceAdPayload, S>

  type ServiceAdCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceAdFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceAdCountAggregateInputType | true
    }

  export interface ServiceAdDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceAd'], meta: { name: 'ServiceAd' } }
    /**
     * Find zero or one ServiceAd that matches the filter.
     * @param {ServiceAdFindUniqueArgs} args - Arguments to find a ServiceAd
     * @example
     * // Get one ServiceAd
     * const serviceAd = await prisma.serviceAd.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceAdFindUniqueArgs>(args: SelectSubset<T, ServiceAdFindUniqueArgs<ExtArgs>>): Prisma__ServiceAdClient<$Result.GetResult<Prisma.$ServiceAdPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceAd that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceAdFindUniqueOrThrowArgs} args - Arguments to find a ServiceAd
     * @example
     * // Get one ServiceAd
     * const serviceAd = await prisma.serviceAd.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceAdFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceAdFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceAdClient<$Result.GetResult<Prisma.$ServiceAdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceAd that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAdFindFirstArgs} args - Arguments to find a ServiceAd
     * @example
     * // Get one ServiceAd
     * const serviceAd = await prisma.serviceAd.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceAdFindFirstArgs>(args?: SelectSubset<T, ServiceAdFindFirstArgs<ExtArgs>>): Prisma__ServiceAdClient<$Result.GetResult<Prisma.$ServiceAdPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceAd that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAdFindFirstOrThrowArgs} args - Arguments to find a ServiceAd
     * @example
     * // Get one ServiceAd
     * const serviceAd = await prisma.serviceAd.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceAdFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceAdFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceAdClient<$Result.GetResult<Prisma.$ServiceAdPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceAds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAdFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceAds
     * const serviceAds = await prisma.serviceAd.findMany()
     * 
     * // Get first 10 ServiceAds
     * const serviceAds = await prisma.serviceAd.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceAdWithIdOnly = await prisma.serviceAd.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceAdFindManyArgs>(args?: SelectSubset<T, ServiceAdFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceAdPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceAd.
     * @param {ServiceAdCreateArgs} args - Arguments to create a ServiceAd.
     * @example
     * // Create one ServiceAd
     * const ServiceAd = await prisma.serviceAd.create({
     *   data: {
     *     // ... data to create a ServiceAd
     *   }
     * })
     * 
     */
    create<T extends ServiceAdCreateArgs>(args: SelectSubset<T, ServiceAdCreateArgs<ExtArgs>>): Prisma__ServiceAdClient<$Result.GetResult<Prisma.$ServiceAdPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceAds.
     * @param {ServiceAdCreateManyArgs} args - Arguments to create many ServiceAds.
     * @example
     * // Create many ServiceAds
     * const serviceAd = await prisma.serviceAd.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceAdCreateManyArgs>(args?: SelectSubset<T, ServiceAdCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceAds and returns the data saved in the database.
     * @param {ServiceAdCreateManyAndReturnArgs} args - Arguments to create many ServiceAds.
     * @example
     * // Create many ServiceAds
     * const serviceAd = await prisma.serviceAd.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceAds and only return the `id`
     * const serviceAdWithIdOnly = await prisma.serviceAd.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceAdCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceAdCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceAdPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceAd.
     * @param {ServiceAdDeleteArgs} args - Arguments to delete one ServiceAd.
     * @example
     * // Delete one ServiceAd
     * const ServiceAd = await prisma.serviceAd.delete({
     *   where: {
     *     // ... filter to delete one ServiceAd
     *   }
     * })
     * 
     */
    delete<T extends ServiceAdDeleteArgs>(args: SelectSubset<T, ServiceAdDeleteArgs<ExtArgs>>): Prisma__ServiceAdClient<$Result.GetResult<Prisma.$ServiceAdPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceAd.
     * @param {ServiceAdUpdateArgs} args - Arguments to update one ServiceAd.
     * @example
     * // Update one ServiceAd
     * const serviceAd = await prisma.serviceAd.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceAdUpdateArgs>(args: SelectSubset<T, ServiceAdUpdateArgs<ExtArgs>>): Prisma__ServiceAdClient<$Result.GetResult<Prisma.$ServiceAdPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceAds.
     * @param {ServiceAdDeleteManyArgs} args - Arguments to filter ServiceAds to delete.
     * @example
     * // Delete a few ServiceAds
     * const { count } = await prisma.serviceAd.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceAdDeleteManyArgs>(args?: SelectSubset<T, ServiceAdDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceAds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAdUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceAds
     * const serviceAd = await prisma.serviceAd.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceAdUpdateManyArgs>(args: SelectSubset<T, ServiceAdUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceAds and returns the data updated in the database.
     * @param {ServiceAdUpdateManyAndReturnArgs} args - Arguments to update many ServiceAds.
     * @example
     * // Update many ServiceAds
     * const serviceAd = await prisma.serviceAd.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceAds and only return the `id`
     * const serviceAdWithIdOnly = await prisma.serviceAd.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceAdUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceAdUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceAdPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceAd.
     * @param {ServiceAdUpsertArgs} args - Arguments to update or create a ServiceAd.
     * @example
     * // Update or create a ServiceAd
     * const serviceAd = await prisma.serviceAd.upsert({
     *   create: {
     *     // ... data to create a ServiceAd
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceAd we want to update
     *   }
     * })
     */
    upsert<T extends ServiceAdUpsertArgs>(args: SelectSubset<T, ServiceAdUpsertArgs<ExtArgs>>): Prisma__ServiceAdClient<$Result.GetResult<Prisma.$ServiceAdPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceAds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAdCountArgs} args - Arguments to filter ServiceAds to count.
     * @example
     * // Count the number of ServiceAds
     * const count = await prisma.serviceAd.count({
     *   where: {
     *     // ... the filter for the ServiceAds we want to count
     *   }
     * })
    **/
    count<T extends ServiceAdCountArgs>(
      args?: Subset<T, ServiceAdCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceAdCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceAd.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAdAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAdAggregateArgs>(args: Subset<T, ServiceAdAggregateArgs>): Prisma.PrismaPromise<GetServiceAdAggregateType<T>>

    /**
     * Group by ServiceAd.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAdGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceAdGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceAdGroupByArgs['orderBy'] }
        : { orderBy?: ServiceAdGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceAdGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceAdGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceAd model
   */
  readonly fields: ServiceAdFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceAd.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceAdClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends SecurityCompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SecurityCompanyDefaultArgs<ExtArgs>>): Prisma__SecurityCompanyClient<$Result.GetResult<Prisma.$SecurityCompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceAd model
   */
  interface ServiceAdFieldRefs {
    readonly id: FieldRef<"ServiceAd", 'Int'>
    readonly companyId: FieldRef<"ServiceAd", 'Int'>
    readonly jobTitle: FieldRef<"ServiceAd", 'String'>
    readonly jobType: FieldRef<"ServiceAd", 'String'>
    readonly industryCategory: FieldRef<"ServiceAd", 'String'>
    readonly region: FieldRef<"ServiceAd", 'String'>
    readonly postcode: FieldRef<"ServiceAd", 'String'>
    readonly salaryRate: FieldRef<"ServiceAd", 'Float'>
    readonly salaryType: FieldRef<"ServiceAd", 'String'>
    readonly jobDescription: FieldRef<"ServiceAd", 'String'>
    readonly requiredExperience: FieldRef<"ServiceAd", 'String'>
    readonly requiredLicences: FieldRef<"ServiceAd", 'String'>
    readonly shiftAndHours: FieldRef<"ServiceAd", 'String'>
    readonly startDate: FieldRef<"ServiceAd", 'DateTime'>
    readonly deadline: FieldRef<"ServiceAd", 'DateTime'>
    readonly createdAt: FieldRef<"ServiceAd", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceAd", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceAd findUnique
   */
  export type ServiceAdFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAd
     */
    select?: ServiceAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAd
     */
    omit?: ServiceAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAdInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAd to fetch.
     */
    where: ServiceAdWhereUniqueInput
  }

  /**
   * ServiceAd findUniqueOrThrow
   */
  export type ServiceAdFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAd
     */
    select?: ServiceAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAd
     */
    omit?: ServiceAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAdInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAd to fetch.
     */
    where: ServiceAdWhereUniqueInput
  }

  /**
   * ServiceAd findFirst
   */
  export type ServiceAdFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAd
     */
    select?: ServiceAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAd
     */
    omit?: ServiceAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAdInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAd to fetch.
     */
    where?: ServiceAdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceAds to fetch.
     */
    orderBy?: ServiceAdOrderByWithRelationInput | ServiceAdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceAds.
     */
    cursor?: ServiceAdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceAds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceAds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceAds.
     */
    distinct?: ServiceAdScalarFieldEnum | ServiceAdScalarFieldEnum[]
  }

  /**
   * ServiceAd findFirstOrThrow
   */
  export type ServiceAdFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAd
     */
    select?: ServiceAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAd
     */
    omit?: ServiceAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAdInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAd to fetch.
     */
    where?: ServiceAdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceAds to fetch.
     */
    orderBy?: ServiceAdOrderByWithRelationInput | ServiceAdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceAds.
     */
    cursor?: ServiceAdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceAds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceAds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceAds.
     */
    distinct?: ServiceAdScalarFieldEnum | ServiceAdScalarFieldEnum[]
  }

  /**
   * ServiceAd findMany
   */
  export type ServiceAdFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAd
     */
    select?: ServiceAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAd
     */
    omit?: ServiceAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAdInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAds to fetch.
     */
    where?: ServiceAdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceAds to fetch.
     */
    orderBy?: ServiceAdOrderByWithRelationInput | ServiceAdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceAds.
     */
    cursor?: ServiceAdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceAds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceAds.
     */
    skip?: number
    distinct?: ServiceAdScalarFieldEnum | ServiceAdScalarFieldEnum[]
  }

  /**
   * ServiceAd create
   */
  export type ServiceAdCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAd
     */
    select?: ServiceAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAd
     */
    omit?: ServiceAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAdInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceAd.
     */
    data: XOR<ServiceAdCreateInput, ServiceAdUncheckedCreateInput>
  }

  /**
   * ServiceAd createMany
   */
  export type ServiceAdCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceAds.
     */
    data: ServiceAdCreateManyInput | ServiceAdCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceAd createManyAndReturn
   */
  export type ServiceAdCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAd
     */
    select?: ServiceAdSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAd
     */
    omit?: ServiceAdOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceAds.
     */
    data: ServiceAdCreateManyInput | ServiceAdCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAdIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceAd update
   */
  export type ServiceAdUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAd
     */
    select?: ServiceAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAd
     */
    omit?: ServiceAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAdInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceAd.
     */
    data: XOR<ServiceAdUpdateInput, ServiceAdUncheckedUpdateInput>
    /**
     * Choose, which ServiceAd to update.
     */
    where: ServiceAdWhereUniqueInput
  }

  /**
   * ServiceAd updateMany
   */
  export type ServiceAdUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceAds.
     */
    data: XOR<ServiceAdUpdateManyMutationInput, ServiceAdUncheckedUpdateManyInput>
    /**
     * Filter which ServiceAds to update
     */
    where?: ServiceAdWhereInput
    /**
     * Limit how many ServiceAds to update.
     */
    limit?: number
  }

  /**
   * ServiceAd updateManyAndReturn
   */
  export type ServiceAdUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAd
     */
    select?: ServiceAdSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAd
     */
    omit?: ServiceAdOmit<ExtArgs> | null
    /**
     * The data used to update ServiceAds.
     */
    data: XOR<ServiceAdUpdateManyMutationInput, ServiceAdUncheckedUpdateManyInput>
    /**
     * Filter which ServiceAds to update
     */
    where?: ServiceAdWhereInput
    /**
     * Limit how many ServiceAds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAdIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceAd upsert
   */
  export type ServiceAdUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAd
     */
    select?: ServiceAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAd
     */
    omit?: ServiceAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAdInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceAd to update in case it exists.
     */
    where: ServiceAdWhereUniqueInput
    /**
     * In case the ServiceAd found by the `where` argument doesn't exist, create a new ServiceAd with this data.
     */
    create: XOR<ServiceAdCreateInput, ServiceAdUncheckedCreateInput>
    /**
     * In case the ServiceAd was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceAdUpdateInput, ServiceAdUncheckedUpdateInput>
  }

  /**
   * ServiceAd delete
   */
  export type ServiceAdDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAd
     */
    select?: ServiceAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAd
     */
    omit?: ServiceAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAdInclude<ExtArgs> | null
    /**
     * Filter which ServiceAd to delete.
     */
    where: ServiceAdWhereUniqueInput
  }

  /**
   * ServiceAd deleteMany
   */
  export type ServiceAdDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceAds to delete
     */
    where?: ServiceAdWhereInput
    /**
     * Limit how many ServiceAds to delete.
     */
    limit?: number
  }

  /**
   * ServiceAd without action
   */
  export type ServiceAdDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAd
     */
    select?: ServiceAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAd
     */
    omit?: ServiceAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAdInclude<ExtArgs> | null
  }


  /**
   * Model ClientAd
   */

  export type AggregateClientAd = {
    _count: ClientAdCountAggregateOutputType | null
    _avg: ClientAdAvgAggregateOutputType | null
    _sum: ClientAdSumAggregateOutputType | null
    _min: ClientAdMinAggregateOutputType | null
    _max: ClientAdMaxAggregateOutputType | null
  }

  export type ClientAdAvgAggregateOutputType = {
    id: number | null
    clientId: number | null
  }

  export type ClientAdSumAggregateOutputType = {
    id: number | null
    clientId: number | null
  }

  export type ClientAdMinAggregateOutputType = {
    id: number | null
    clientId: number | null
    title: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientAdMaxAggregateOutputType = {
    id: number | null
    clientId: number | null
    title: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientAdCountAggregateOutputType = {
    id: number
    clientId: number
    title: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientAdAvgAggregateInputType = {
    id?: true
    clientId?: true
  }

  export type ClientAdSumAggregateInputType = {
    id?: true
    clientId?: true
  }

  export type ClientAdMinAggregateInputType = {
    id?: true
    clientId?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientAdMaxAggregateInputType = {
    id?: true
    clientId?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientAdCountAggregateInputType = {
    id?: true
    clientId?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientAdAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientAd to aggregate.
     */
    where?: ClientAdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientAds to fetch.
     */
    orderBy?: ClientAdOrderByWithRelationInput | ClientAdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientAdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientAds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientAds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientAds
    **/
    _count?: true | ClientAdCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientAdAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientAdSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientAdMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientAdMaxAggregateInputType
  }

  export type GetClientAdAggregateType<T extends ClientAdAggregateArgs> = {
        [P in keyof T & keyof AggregateClientAd]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientAd[P]>
      : GetScalarType<T[P], AggregateClientAd[P]>
  }




  export type ClientAdGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientAdWhereInput
    orderBy?: ClientAdOrderByWithAggregationInput | ClientAdOrderByWithAggregationInput[]
    by: ClientAdScalarFieldEnum[] | ClientAdScalarFieldEnum
    having?: ClientAdScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientAdCountAggregateInputType | true
    _avg?: ClientAdAvgAggregateInputType
    _sum?: ClientAdSumAggregateInputType
    _min?: ClientAdMinAggregateInputType
    _max?: ClientAdMaxAggregateInputType
  }

  export type ClientAdGroupByOutputType = {
    id: number
    clientId: number
    title: string
    description: string
    createdAt: Date
    updatedAt: Date
    _count: ClientAdCountAggregateOutputType | null
    _avg: ClientAdAvgAggregateOutputType | null
    _sum: ClientAdSumAggregateOutputType | null
    _min: ClientAdMinAggregateOutputType | null
    _max: ClientAdMaxAggregateOutputType | null
  }

  type GetClientAdGroupByPayload<T extends ClientAdGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientAdGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientAdGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientAdGroupByOutputType[P]>
            : GetScalarType<T[P], ClientAdGroupByOutputType[P]>
        }
      >
    >


  export type ClientAdSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientAd"]>

  export type ClientAdSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientAd"]>

  export type ClientAdSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientAd"]>

  export type ClientAdSelectScalar = {
    id?: boolean
    clientId?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientAdOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "title" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["clientAd"]>
  export type ClientAdInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type ClientAdIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type ClientAdIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $ClientAdPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientAd"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      clientId: number
      title: string
      description: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clientAd"]>
    composites: {}
  }

  type ClientAdGetPayload<S extends boolean | null | undefined | ClientAdDefaultArgs> = $Result.GetResult<Prisma.$ClientAdPayload, S>

  type ClientAdCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientAdFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientAdCountAggregateInputType | true
    }

  export interface ClientAdDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientAd'], meta: { name: 'ClientAd' } }
    /**
     * Find zero or one ClientAd that matches the filter.
     * @param {ClientAdFindUniqueArgs} args - Arguments to find a ClientAd
     * @example
     * // Get one ClientAd
     * const clientAd = await prisma.clientAd.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientAdFindUniqueArgs>(args: SelectSubset<T, ClientAdFindUniqueArgs<ExtArgs>>): Prisma__ClientAdClient<$Result.GetResult<Prisma.$ClientAdPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientAd that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientAdFindUniqueOrThrowArgs} args - Arguments to find a ClientAd
     * @example
     * // Get one ClientAd
     * const clientAd = await prisma.clientAd.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientAdFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientAdFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientAdClient<$Result.GetResult<Prisma.$ClientAdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientAd that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAdFindFirstArgs} args - Arguments to find a ClientAd
     * @example
     * // Get one ClientAd
     * const clientAd = await prisma.clientAd.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientAdFindFirstArgs>(args?: SelectSubset<T, ClientAdFindFirstArgs<ExtArgs>>): Prisma__ClientAdClient<$Result.GetResult<Prisma.$ClientAdPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientAd that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAdFindFirstOrThrowArgs} args - Arguments to find a ClientAd
     * @example
     * // Get one ClientAd
     * const clientAd = await prisma.clientAd.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientAdFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientAdFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientAdClient<$Result.GetResult<Prisma.$ClientAdPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientAds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAdFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientAds
     * const clientAds = await prisma.clientAd.findMany()
     * 
     * // Get first 10 ClientAds
     * const clientAds = await prisma.clientAd.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientAdWithIdOnly = await prisma.clientAd.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientAdFindManyArgs>(args?: SelectSubset<T, ClientAdFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientAdPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientAd.
     * @param {ClientAdCreateArgs} args - Arguments to create a ClientAd.
     * @example
     * // Create one ClientAd
     * const ClientAd = await prisma.clientAd.create({
     *   data: {
     *     // ... data to create a ClientAd
     *   }
     * })
     * 
     */
    create<T extends ClientAdCreateArgs>(args: SelectSubset<T, ClientAdCreateArgs<ExtArgs>>): Prisma__ClientAdClient<$Result.GetResult<Prisma.$ClientAdPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientAds.
     * @param {ClientAdCreateManyArgs} args - Arguments to create many ClientAds.
     * @example
     * // Create many ClientAds
     * const clientAd = await prisma.clientAd.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientAdCreateManyArgs>(args?: SelectSubset<T, ClientAdCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClientAds and returns the data saved in the database.
     * @param {ClientAdCreateManyAndReturnArgs} args - Arguments to create many ClientAds.
     * @example
     * // Create many ClientAds
     * const clientAd = await prisma.clientAd.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClientAds and only return the `id`
     * const clientAdWithIdOnly = await prisma.clientAd.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientAdCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientAdCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientAdPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClientAd.
     * @param {ClientAdDeleteArgs} args - Arguments to delete one ClientAd.
     * @example
     * // Delete one ClientAd
     * const ClientAd = await prisma.clientAd.delete({
     *   where: {
     *     // ... filter to delete one ClientAd
     *   }
     * })
     * 
     */
    delete<T extends ClientAdDeleteArgs>(args: SelectSubset<T, ClientAdDeleteArgs<ExtArgs>>): Prisma__ClientAdClient<$Result.GetResult<Prisma.$ClientAdPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientAd.
     * @param {ClientAdUpdateArgs} args - Arguments to update one ClientAd.
     * @example
     * // Update one ClientAd
     * const clientAd = await prisma.clientAd.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientAdUpdateArgs>(args: SelectSubset<T, ClientAdUpdateArgs<ExtArgs>>): Prisma__ClientAdClient<$Result.GetResult<Prisma.$ClientAdPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientAds.
     * @param {ClientAdDeleteManyArgs} args - Arguments to filter ClientAds to delete.
     * @example
     * // Delete a few ClientAds
     * const { count } = await prisma.clientAd.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientAdDeleteManyArgs>(args?: SelectSubset<T, ClientAdDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientAds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAdUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientAds
     * const clientAd = await prisma.clientAd.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientAdUpdateManyArgs>(args: SelectSubset<T, ClientAdUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientAds and returns the data updated in the database.
     * @param {ClientAdUpdateManyAndReturnArgs} args - Arguments to update many ClientAds.
     * @example
     * // Update many ClientAds
     * const clientAd = await prisma.clientAd.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClientAds and only return the `id`
     * const clientAdWithIdOnly = await prisma.clientAd.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientAdUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientAdUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientAdPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClientAd.
     * @param {ClientAdUpsertArgs} args - Arguments to update or create a ClientAd.
     * @example
     * // Update or create a ClientAd
     * const clientAd = await prisma.clientAd.upsert({
     *   create: {
     *     // ... data to create a ClientAd
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientAd we want to update
     *   }
     * })
     */
    upsert<T extends ClientAdUpsertArgs>(args: SelectSubset<T, ClientAdUpsertArgs<ExtArgs>>): Prisma__ClientAdClient<$Result.GetResult<Prisma.$ClientAdPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientAds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAdCountArgs} args - Arguments to filter ClientAds to count.
     * @example
     * // Count the number of ClientAds
     * const count = await prisma.clientAd.count({
     *   where: {
     *     // ... the filter for the ClientAds we want to count
     *   }
     * })
    **/
    count<T extends ClientAdCountArgs>(
      args?: Subset<T, ClientAdCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientAdCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientAd.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAdAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAdAggregateArgs>(args: Subset<T, ClientAdAggregateArgs>): Prisma.PrismaPromise<GetClientAdAggregateType<T>>

    /**
     * Group by ClientAd.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAdGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientAdGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientAdGroupByArgs['orderBy'] }
        : { orderBy?: ClientAdGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientAdGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientAdGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientAd model
   */
  readonly fields: ClientAdFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientAd.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientAdClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientAd model
   */
  interface ClientAdFieldRefs {
    readonly id: FieldRef<"ClientAd", 'Int'>
    readonly clientId: FieldRef<"ClientAd", 'Int'>
    readonly title: FieldRef<"ClientAd", 'String'>
    readonly description: FieldRef<"ClientAd", 'String'>
    readonly createdAt: FieldRef<"ClientAd", 'DateTime'>
    readonly updatedAt: FieldRef<"ClientAd", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientAd findUnique
   */
  export type ClientAdFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAd
     */
    select?: ClientAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAd
     */
    omit?: ClientAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAdInclude<ExtArgs> | null
    /**
     * Filter, which ClientAd to fetch.
     */
    where: ClientAdWhereUniqueInput
  }

  /**
   * ClientAd findUniqueOrThrow
   */
  export type ClientAdFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAd
     */
    select?: ClientAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAd
     */
    omit?: ClientAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAdInclude<ExtArgs> | null
    /**
     * Filter, which ClientAd to fetch.
     */
    where: ClientAdWhereUniqueInput
  }

  /**
   * ClientAd findFirst
   */
  export type ClientAdFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAd
     */
    select?: ClientAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAd
     */
    omit?: ClientAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAdInclude<ExtArgs> | null
    /**
     * Filter, which ClientAd to fetch.
     */
    where?: ClientAdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientAds to fetch.
     */
    orderBy?: ClientAdOrderByWithRelationInput | ClientAdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientAds.
     */
    cursor?: ClientAdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientAds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientAds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientAds.
     */
    distinct?: ClientAdScalarFieldEnum | ClientAdScalarFieldEnum[]
  }

  /**
   * ClientAd findFirstOrThrow
   */
  export type ClientAdFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAd
     */
    select?: ClientAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAd
     */
    omit?: ClientAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAdInclude<ExtArgs> | null
    /**
     * Filter, which ClientAd to fetch.
     */
    where?: ClientAdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientAds to fetch.
     */
    orderBy?: ClientAdOrderByWithRelationInput | ClientAdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientAds.
     */
    cursor?: ClientAdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientAds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientAds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientAds.
     */
    distinct?: ClientAdScalarFieldEnum | ClientAdScalarFieldEnum[]
  }

  /**
   * ClientAd findMany
   */
  export type ClientAdFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAd
     */
    select?: ClientAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAd
     */
    omit?: ClientAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAdInclude<ExtArgs> | null
    /**
     * Filter, which ClientAds to fetch.
     */
    where?: ClientAdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientAds to fetch.
     */
    orderBy?: ClientAdOrderByWithRelationInput | ClientAdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientAds.
     */
    cursor?: ClientAdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientAds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientAds.
     */
    skip?: number
    distinct?: ClientAdScalarFieldEnum | ClientAdScalarFieldEnum[]
  }

  /**
   * ClientAd create
   */
  export type ClientAdCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAd
     */
    select?: ClientAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAd
     */
    omit?: ClientAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAdInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientAd.
     */
    data: XOR<ClientAdCreateInput, ClientAdUncheckedCreateInput>
  }

  /**
   * ClientAd createMany
   */
  export type ClientAdCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientAds.
     */
    data: ClientAdCreateManyInput | ClientAdCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientAd createManyAndReturn
   */
  export type ClientAdCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAd
     */
    select?: ClientAdSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAd
     */
    omit?: ClientAdOmit<ExtArgs> | null
    /**
     * The data used to create many ClientAds.
     */
    data: ClientAdCreateManyInput | ClientAdCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAdIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientAd update
   */
  export type ClientAdUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAd
     */
    select?: ClientAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAd
     */
    omit?: ClientAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAdInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientAd.
     */
    data: XOR<ClientAdUpdateInput, ClientAdUncheckedUpdateInput>
    /**
     * Choose, which ClientAd to update.
     */
    where: ClientAdWhereUniqueInput
  }

  /**
   * ClientAd updateMany
   */
  export type ClientAdUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientAds.
     */
    data: XOR<ClientAdUpdateManyMutationInput, ClientAdUncheckedUpdateManyInput>
    /**
     * Filter which ClientAds to update
     */
    where?: ClientAdWhereInput
    /**
     * Limit how many ClientAds to update.
     */
    limit?: number
  }

  /**
   * ClientAd updateManyAndReturn
   */
  export type ClientAdUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAd
     */
    select?: ClientAdSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAd
     */
    omit?: ClientAdOmit<ExtArgs> | null
    /**
     * The data used to update ClientAds.
     */
    data: XOR<ClientAdUpdateManyMutationInput, ClientAdUncheckedUpdateManyInput>
    /**
     * Filter which ClientAds to update
     */
    where?: ClientAdWhereInput
    /**
     * Limit how many ClientAds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAdIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientAd upsert
   */
  export type ClientAdUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAd
     */
    select?: ClientAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAd
     */
    omit?: ClientAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAdInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientAd to update in case it exists.
     */
    where: ClientAdWhereUniqueInput
    /**
     * In case the ClientAd found by the `where` argument doesn't exist, create a new ClientAd with this data.
     */
    create: XOR<ClientAdCreateInput, ClientAdUncheckedCreateInput>
    /**
     * In case the ClientAd was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientAdUpdateInput, ClientAdUncheckedUpdateInput>
  }

  /**
   * ClientAd delete
   */
  export type ClientAdDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAd
     */
    select?: ClientAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAd
     */
    omit?: ClientAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAdInclude<ExtArgs> | null
    /**
     * Filter which ClientAd to delete.
     */
    where: ClientAdWhereUniqueInput
  }

  /**
   * ClientAd deleteMany
   */
  export type ClientAdDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientAds to delete
     */
    where?: ClientAdWhereInput
    /**
     * Limit how many ClientAds to delete.
     */
    limit?: number
  }

  /**
   * ClientAd without action
   */
  export type ClientAdDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAd
     */
    select?: ClientAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAd
     */
    omit?: ClientAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAdInclude<ExtArgs> | null
  }


  /**
   * Model RoleUser
   */

  export type AggregateRoleUser = {
    _count: RoleUserCountAggregateOutputType | null
    _avg: RoleUserAvgAggregateOutputType | null
    _sum: RoleUserSumAggregateOutputType | null
    _min: RoleUserMinAggregateOutputType | null
    _max: RoleUserMaxAggregateOutputType | null
  }

  export type RoleUserAvgAggregateOutputType = {
    id: number | null
    roleId: number | null
    userId: number | null
  }

  export type RoleUserSumAggregateOutputType = {
    id: number | null
    roleId: number | null
    userId: number | null
  }

  export type RoleUserMinAggregateOutputType = {
    id: number | null
    roleId: number | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleUserMaxAggregateOutputType = {
    id: number | null
    roleId: number | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleUserCountAggregateOutputType = {
    id: number
    roleId: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleUserAvgAggregateInputType = {
    id?: true
    roleId?: true
    userId?: true
  }

  export type RoleUserSumAggregateInputType = {
    id?: true
    roleId?: true
    userId?: true
  }

  export type RoleUserMinAggregateInputType = {
    id?: true
    roleId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleUserMaxAggregateInputType = {
    id?: true
    roleId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleUserCountAggregateInputType = {
    id?: true
    roleId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleUser to aggregate.
     */
    where?: RoleUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleUsers to fetch.
     */
    orderBy?: RoleUserOrderByWithRelationInput | RoleUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoleUsers
    **/
    _count?: true | RoleUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleUserMaxAggregateInputType
  }

  export type GetRoleUserAggregateType<T extends RoleUserAggregateArgs> = {
        [P in keyof T & keyof AggregateRoleUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoleUser[P]>
      : GetScalarType<T[P], AggregateRoleUser[P]>
  }




  export type RoleUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleUserWhereInput
    orderBy?: RoleUserOrderByWithAggregationInput | RoleUserOrderByWithAggregationInput[]
    by: RoleUserScalarFieldEnum[] | RoleUserScalarFieldEnum
    having?: RoleUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleUserCountAggregateInputType | true
    _avg?: RoleUserAvgAggregateInputType
    _sum?: RoleUserSumAggregateInputType
    _min?: RoleUserMinAggregateInputType
    _max?: RoleUserMaxAggregateInputType
  }

  export type RoleUserGroupByOutputType = {
    id: number
    roleId: number
    userId: number
    createdAt: Date
    updatedAt: Date
    _count: RoleUserCountAggregateOutputType | null
    _avg: RoleUserAvgAggregateOutputType | null
    _sum: RoleUserSumAggregateOutputType | null
    _min: RoleUserMinAggregateOutputType | null
    _max: RoleUserMaxAggregateOutputType | null
  }

  type GetRoleUserGroupByPayload<T extends RoleUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleUserGroupByOutputType[P]>
            : GetScalarType<T[P], RoleUserGroupByOutputType[P]>
        }
      >
    >


  export type RoleUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roleUser"]>

  export type RoleUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roleUser"]>

  export type RoleUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roleUser"]>

  export type RoleUserSelectScalar = {
    id?: boolean
    roleId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roleId" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["roleUser"]>
  export type RoleUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RoleUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RoleUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RoleUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoleUser"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      roleId: number
      userId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["roleUser"]>
    composites: {}
  }

  type RoleUserGetPayload<S extends boolean | null | undefined | RoleUserDefaultArgs> = $Result.GetResult<Prisma.$RoleUserPayload, S>

  type RoleUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleUserCountAggregateInputType | true
    }

  export interface RoleUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoleUser'], meta: { name: 'RoleUser' } }
    /**
     * Find zero or one RoleUser that matches the filter.
     * @param {RoleUserFindUniqueArgs} args - Arguments to find a RoleUser
     * @example
     * // Get one RoleUser
     * const roleUser = await prisma.roleUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleUserFindUniqueArgs>(args: SelectSubset<T, RoleUserFindUniqueArgs<ExtArgs>>): Prisma__RoleUserClient<$Result.GetResult<Prisma.$RoleUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoleUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleUserFindUniqueOrThrowArgs} args - Arguments to find a RoleUser
     * @example
     * // Get one RoleUser
     * const roleUser = await prisma.roleUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleUserFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleUserClient<$Result.GetResult<Prisma.$RoleUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoleUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUserFindFirstArgs} args - Arguments to find a RoleUser
     * @example
     * // Get one RoleUser
     * const roleUser = await prisma.roleUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleUserFindFirstArgs>(args?: SelectSubset<T, RoleUserFindFirstArgs<ExtArgs>>): Prisma__RoleUserClient<$Result.GetResult<Prisma.$RoleUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoleUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUserFindFirstOrThrowArgs} args - Arguments to find a RoleUser
     * @example
     * // Get one RoleUser
     * const roleUser = await prisma.roleUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleUserFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleUserClient<$Result.GetResult<Prisma.$RoleUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoleUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoleUsers
     * const roleUsers = await prisma.roleUser.findMany()
     * 
     * // Get first 10 RoleUsers
     * const roleUsers = await prisma.roleUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleUserWithIdOnly = await prisma.roleUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleUserFindManyArgs>(args?: SelectSubset<T, RoleUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoleUser.
     * @param {RoleUserCreateArgs} args - Arguments to create a RoleUser.
     * @example
     * // Create one RoleUser
     * const RoleUser = await prisma.roleUser.create({
     *   data: {
     *     // ... data to create a RoleUser
     *   }
     * })
     * 
     */
    create<T extends RoleUserCreateArgs>(args: SelectSubset<T, RoleUserCreateArgs<ExtArgs>>): Prisma__RoleUserClient<$Result.GetResult<Prisma.$RoleUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoleUsers.
     * @param {RoleUserCreateManyArgs} args - Arguments to create many RoleUsers.
     * @example
     * // Create many RoleUsers
     * const roleUser = await prisma.roleUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleUserCreateManyArgs>(args?: SelectSubset<T, RoleUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoleUsers and returns the data saved in the database.
     * @param {RoleUserCreateManyAndReturnArgs} args - Arguments to create many RoleUsers.
     * @example
     * // Create many RoleUsers
     * const roleUser = await prisma.roleUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoleUsers and only return the `id`
     * const roleUserWithIdOnly = await prisma.roleUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleUserCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RoleUser.
     * @param {RoleUserDeleteArgs} args - Arguments to delete one RoleUser.
     * @example
     * // Delete one RoleUser
     * const RoleUser = await prisma.roleUser.delete({
     *   where: {
     *     // ... filter to delete one RoleUser
     *   }
     * })
     * 
     */
    delete<T extends RoleUserDeleteArgs>(args: SelectSubset<T, RoleUserDeleteArgs<ExtArgs>>): Prisma__RoleUserClient<$Result.GetResult<Prisma.$RoleUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoleUser.
     * @param {RoleUserUpdateArgs} args - Arguments to update one RoleUser.
     * @example
     * // Update one RoleUser
     * const roleUser = await prisma.roleUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUserUpdateArgs>(args: SelectSubset<T, RoleUserUpdateArgs<ExtArgs>>): Prisma__RoleUserClient<$Result.GetResult<Prisma.$RoleUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoleUsers.
     * @param {RoleUserDeleteManyArgs} args - Arguments to filter RoleUsers to delete.
     * @example
     * // Delete a few RoleUsers
     * const { count } = await prisma.roleUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleUserDeleteManyArgs>(args?: SelectSubset<T, RoleUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoleUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoleUsers
     * const roleUser = await prisma.roleUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUserUpdateManyArgs>(args: SelectSubset<T, RoleUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoleUsers and returns the data updated in the database.
     * @param {RoleUserUpdateManyAndReturnArgs} args - Arguments to update many RoleUsers.
     * @example
     * // Update many RoleUsers
     * const roleUser = await prisma.roleUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RoleUsers and only return the `id`
     * const roleUserWithIdOnly = await prisma.roleUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUserUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RoleUser.
     * @param {RoleUserUpsertArgs} args - Arguments to update or create a RoleUser.
     * @example
     * // Update or create a RoleUser
     * const roleUser = await prisma.roleUser.upsert({
     *   create: {
     *     // ... data to create a RoleUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoleUser we want to update
     *   }
     * })
     */
    upsert<T extends RoleUserUpsertArgs>(args: SelectSubset<T, RoleUserUpsertArgs<ExtArgs>>): Prisma__RoleUserClient<$Result.GetResult<Prisma.$RoleUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoleUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUserCountArgs} args - Arguments to filter RoleUsers to count.
     * @example
     * // Count the number of RoleUsers
     * const count = await prisma.roleUser.count({
     *   where: {
     *     // ... the filter for the RoleUsers we want to count
     *   }
     * })
    **/
    count<T extends RoleUserCountArgs>(
      args?: Subset<T, RoleUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoleUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleUserAggregateArgs>(args: Subset<T, RoleUserAggregateArgs>): Prisma.PrismaPromise<GetRoleUserAggregateType<T>>

    /**
     * Group by RoleUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleUserGroupByArgs['orderBy'] }
        : { orderBy?: RoleUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoleUser model
   */
  readonly fields: RoleUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoleUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoleUser model
   */
  interface RoleUserFieldRefs {
    readonly id: FieldRef<"RoleUser", 'Int'>
    readonly roleId: FieldRef<"RoleUser", 'Int'>
    readonly userId: FieldRef<"RoleUser", 'Int'>
    readonly createdAt: FieldRef<"RoleUser", 'DateTime'>
    readonly updatedAt: FieldRef<"RoleUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoleUser findUnique
   */
  export type RoleUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleUser
     */
    select?: RoleUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleUser
     */
    omit?: RoleUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleUserInclude<ExtArgs> | null
    /**
     * Filter, which RoleUser to fetch.
     */
    where: RoleUserWhereUniqueInput
  }

  /**
   * RoleUser findUniqueOrThrow
   */
  export type RoleUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleUser
     */
    select?: RoleUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleUser
     */
    omit?: RoleUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleUserInclude<ExtArgs> | null
    /**
     * Filter, which RoleUser to fetch.
     */
    where: RoleUserWhereUniqueInput
  }

  /**
   * RoleUser findFirst
   */
  export type RoleUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleUser
     */
    select?: RoleUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleUser
     */
    omit?: RoleUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleUserInclude<ExtArgs> | null
    /**
     * Filter, which RoleUser to fetch.
     */
    where?: RoleUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleUsers to fetch.
     */
    orderBy?: RoleUserOrderByWithRelationInput | RoleUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleUsers.
     */
    cursor?: RoleUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleUsers.
     */
    distinct?: RoleUserScalarFieldEnum | RoleUserScalarFieldEnum[]
  }

  /**
   * RoleUser findFirstOrThrow
   */
  export type RoleUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleUser
     */
    select?: RoleUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleUser
     */
    omit?: RoleUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleUserInclude<ExtArgs> | null
    /**
     * Filter, which RoleUser to fetch.
     */
    where?: RoleUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleUsers to fetch.
     */
    orderBy?: RoleUserOrderByWithRelationInput | RoleUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleUsers.
     */
    cursor?: RoleUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleUsers.
     */
    distinct?: RoleUserScalarFieldEnum | RoleUserScalarFieldEnum[]
  }

  /**
   * RoleUser findMany
   */
  export type RoleUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleUser
     */
    select?: RoleUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleUser
     */
    omit?: RoleUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleUserInclude<ExtArgs> | null
    /**
     * Filter, which RoleUsers to fetch.
     */
    where?: RoleUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleUsers to fetch.
     */
    orderBy?: RoleUserOrderByWithRelationInput | RoleUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoleUsers.
     */
    cursor?: RoleUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleUsers.
     */
    skip?: number
    distinct?: RoleUserScalarFieldEnum | RoleUserScalarFieldEnum[]
  }

  /**
   * RoleUser create
   */
  export type RoleUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleUser
     */
    select?: RoleUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleUser
     */
    omit?: RoleUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleUserInclude<ExtArgs> | null
    /**
     * The data needed to create a RoleUser.
     */
    data: XOR<RoleUserCreateInput, RoleUserUncheckedCreateInput>
  }

  /**
   * RoleUser createMany
   */
  export type RoleUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoleUsers.
     */
    data: RoleUserCreateManyInput | RoleUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoleUser createManyAndReturn
   */
  export type RoleUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleUser
     */
    select?: RoleUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoleUser
     */
    omit?: RoleUserOmit<ExtArgs> | null
    /**
     * The data used to create many RoleUsers.
     */
    data: RoleUserCreateManyInput | RoleUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoleUser update
   */
  export type RoleUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleUser
     */
    select?: RoleUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleUser
     */
    omit?: RoleUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleUserInclude<ExtArgs> | null
    /**
     * The data needed to update a RoleUser.
     */
    data: XOR<RoleUserUpdateInput, RoleUserUncheckedUpdateInput>
    /**
     * Choose, which RoleUser to update.
     */
    where: RoleUserWhereUniqueInput
  }

  /**
   * RoleUser updateMany
   */
  export type RoleUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoleUsers.
     */
    data: XOR<RoleUserUpdateManyMutationInput, RoleUserUncheckedUpdateManyInput>
    /**
     * Filter which RoleUsers to update
     */
    where?: RoleUserWhereInput
    /**
     * Limit how many RoleUsers to update.
     */
    limit?: number
  }

  /**
   * RoleUser updateManyAndReturn
   */
  export type RoleUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleUser
     */
    select?: RoleUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoleUser
     */
    omit?: RoleUserOmit<ExtArgs> | null
    /**
     * The data used to update RoleUsers.
     */
    data: XOR<RoleUserUpdateManyMutationInput, RoleUserUncheckedUpdateManyInput>
    /**
     * Filter which RoleUsers to update
     */
    where?: RoleUserWhereInput
    /**
     * Limit how many RoleUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoleUser upsert
   */
  export type RoleUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleUser
     */
    select?: RoleUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleUser
     */
    omit?: RoleUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleUserInclude<ExtArgs> | null
    /**
     * The filter to search for the RoleUser to update in case it exists.
     */
    where: RoleUserWhereUniqueInput
    /**
     * In case the RoleUser found by the `where` argument doesn't exist, create a new RoleUser with this data.
     */
    create: XOR<RoleUserCreateInput, RoleUserUncheckedCreateInput>
    /**
     * In case the RoleUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUserUpdateInput, RoleUserUncheckedUpdateInput>
  }

  /**
   * RoleUser delete
   */
  export type RoleUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleUser
     */
    select?: RoleUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleUser
     */
    omit?: RoleUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleUserInclude<ExtArgs> | null
    /**
     * Filter which RoleUser to delete.
     */
    where: RoleUserWhereUniqueInput
  }

  /**
   * RoleUser deleteMany
   */
  export type RoleUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleUsers to delete
     */
    where?: RoleUserWhereInput
    /**
     * Limit how many RoleUsers to delete.
     */
    limit?: number
  }

  /**
   * RoleUser without action
   */
  export type RoleUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleUser
     */
    select?: RoleUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleUser
     */
    omit?: RoleUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleUserInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const VerificationCodeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    code: 'code',
    expiresAt: 'expiresAt'
  };

  export type VerificationCodeScalarFieldEnum = (typeof VerificationCodeScalarFieldEnum)[keyof typeof VerificationCodeScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const RolePermissionScalarFieldEnum: {
    id: 'id',
    roleId: 'roleId',
    permissionId: 'permissionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    firstName: 'firstName',
    lastName: 'lastName',
    screenName: 'screenName',
    phoneNumber: 'phoneNumber',
    dateOfBirth: 'dateOfBirth',
    address: 'address',
    roleId: 'roleId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const IndividualProfessionalScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    profileData: 'profileData',
    permissions: 'permissions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IndividualProfessionalScalarFieldEnum = (typeof IndividualProfessionalScalarFieldEnum)[keyof typeof IndividualProfessionalScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    permissions: 'permissions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const SecurityCompanyScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyName: 'companyName',
    registrationNumber: 'registrationNumber',
    address: 'address',
    postCode: 'postCode',
    contactPerson: 'contactPerson',
    jobTitle: 'jobTitle',
    phoneNumber: 'phoneNumber',
    website: 'website',
    servicesRequirements: 'servicesRequirements',
    securityServicesOfferings: 'securityServicesOfferings',
    permissions: 'permissions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SecurityCompanyScalarFieldEnum = (typeof SecurityCompanyScalarFieldEnum)[keyof typeof SecurityCompanyScalarFieldEnum]


  export const CourseProviderScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyName: 'companyName',
    registrationNumber: 'registrationNumber',
    address: 'address',
    postCode: 'postCode',
    contactPerson: 'contactPerson',
    jobTitle: 'jobTitle',
    phoneNumber: 'phoneNumber',
    website: 'website',
    servicesRequirements: 'servicesRequirements',
    securityServicesOfferings: 'securityServicesOfferings',
    permissions: 'permissions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CourseProviderScalarFieldEnum = (typeof CourseProviderScalarFieldEnum)[keyof typeof CourseProviderScalarFieldEnum]


  export const CorporateClientScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyName: 'companyName',
    registrationNumber: 'registrationNumber',
    address: 'address',
    postCode: 'postCode',
    industryType: 'industryType',
    contactPerson: 'contactPerson',
    jobTitle: 'jobTitle',
    phoneNumber: 'phoneNumber',
    website: 'website',
    serviceRequirements: 'serviceRequirements',
    permissions: 'permissions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CorporateClientScalarFieldEnum = (typeof CorporateClientScalarFieldEnum)[keyof typeof CorporateClientScalarFieldEnum]


  export const CorporateAdScalarFieldEnum: {
    id: 'id',
    corporateClientId: 'corporateClientId',
    title: 'title',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CorporateAdScalarFieldEnum = (typeof CorporateAdScalarFieldEnum)[keyof typeof CorporateAdScalarFieldEnum]


  export const CourseAdScalarFieldEnum: {
    id: 'id',
    courseProviderId: 'courseProviderId',
    title: 'title',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CourseAdScalarFieldEnum = (typeof CourseAdScalarFieldEnum)[keyof typeof CourseAdScalarFieldEnum]


  export const ServiceAdScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    jobTitle: 'jobTitle',
    jobType: 'jobType',
    industryCategory: 'industryCategory',
    region: 'region',
    postcode: 'postcode',
    salaryRate: 'salaryRate',
    salaryType: 'salaryType',
    jobDescription: 'jobDescription',
    requiredExperience: 'requiredExperience',
    requiredLicences: 'requiredLicences',
    shiftAndHours: 'shiftAndHours',
    startDate: 'startDate',
    deadline: 'deadline',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceAdScalarFieldEnum = (typeof ServiceAdScalarFieldEnum)[keyof typeof ServiceAdScalarFieldEnum]


  export const ClientAdScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    title: 'title',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientAdScalarFieldEnum = (typeof ClientAdScalarFieldEnum)[keyof typeof ClientAdScalarFieldEnum]


  export const RoleUserScalarFieldEnum: {
    id: 'id',
    roleId: 'roleId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleUserScalarFieldEnum = (typeof RoleUserScalarFieldEnum)[keyof typeof RoleUserScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: IntFilter<"Permission"> | number
    name?: StringFilter<"Permission"> | string
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
    roles?: RolePermissionListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roles?: RolePermissionOrderByRelationAggregateInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
    roles?: RolePermissionListRelationFilter
  }, "id" | "name">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _avg?: PermissionAvgOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
    _sum?: PermissionSumOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Permission"> | number
    name?: StringWithAggregatesFilter<"Permission"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
  }

  export type VerificationCodeWhereInput = {
    AND?: VerificationCodeWhereInput | VerificationCodeWhereInput[]
    OR?: VerificationCodeWhereInput[]
    NOT?: VerificationCodeWhereInput | VerificationCodeWhereInput[]
    id?: IntFilter<"VerificationCode"> | number
    userId?: IntFilter<"VerificationCode"> | number
    code?: StringFilter<"VerificationCode"> | string
    expiresAt?: DateTimeFilter<"VerificationCode"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type VerificationCodeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type VerificationCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: VerificationCodeWhereInput | VerificationCodeWhereInput[]
    OR?: VerificationCodeWhereInput[]
    NOT?: VerificationCodeWhereInput | VerificationCodeWhereInput[]
    code?: StringFilter<"VerificationCode"> | string
    expiresAt?: DateTimeFilter<"VerificationCode"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type VerificationCodeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    _count?: VerificationCodeCountOrderByAggregateInput
    _avg?: VerificationCodeAvgOrderByAggregateInput
    _max?: VerificationCodeMaxOrderByAggregateInput
    _min?: VerificationCodeMinOrderByAggregateInput
    _sum?: VerificationCodeSumOrderByAggregateInput
  }

  export type VerificationCodeScalarWhereWithAggregatesInput = {
    AND?: VerificationCodeScalarWhereWithAggregatesInput | VerificationCodeScalarWhereWithAggregatesInput[]
    OR?: VerificationCodeScalarWhereWithAggregatesInput[]
    NOT?: VerificationCodeScalarWhereWithAggregatesInput | VerificationCodeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VerificationCode"> | number
    userId?: IntWithAggregatesFilter<"VerificationCode"> | number
    code?: StringWithAggregatesFilter<"VerificationCode"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"VerificationCode"> | Date | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: IntFilter<"Role"> | number
    name?: StringFilter<"Role"> | string
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    permissions?: RolePermissionListRelationFilter
    users?: UserListRelationFilter
    roleUsers?: RoleUserListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    permissions?: RolePermissionOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    roleUsers?: RoleUserOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    permissions?: RolePermissionListRelationFilter
    users?: UserListRelationFilter
    roleUsers?: RoleUserListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Role"> | number
    name?: StringWithAggregatesFilter<"Role"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type RolePermissionWhereInput = {
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    id?: IntFilter<"RolePermission"> | number
    roleId?: IntFilter<"RolePermission"> | number
    permissionId?: IntFilter<"RolePermission"> | number
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    updatedAt?: DateTimeFilter<"RolePermission"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
  }

  export type RolePermissionOrderByWithRelationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: RoleOrderByWithRelationInput
    permission?: PermissionOrderByWithRelationInput
  }

  export type RolePermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    roleId?: IntFilter<"RolePermission"> | number
    permissionId?: IntFilter<"RolePermission"> | number
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    updatedAt?: DateTimeFilter<"RolePermission"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
  }, "id">

  export type RolePermissionOrderByWithAggregationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RolePermissionCountOrderByAggregateInput
    _avg?: RolePermissionAvgOrderByAggregateInput
    _max?: RolePermissionMaxOrderByAggregateInput
    _min?: RolePermissionMinOrderByAggregateInput
    _sum?: RolePermissionSumOrderByAggregateInput
  }

  export type RolePermissionScalarWhereWithAggregatesInput = {
    AND?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    OR?: RolePermissionScalarWhereWithAggregatesInput[]
    NOT?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RolePermission"> | number
    roleId?: IntWithAggregatesFilter<"RolePermission"> | number
    permissionId?: IntWithAggregatesFilter<"RolePermission"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RolePermission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RolePermission"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    screenName?: StringNullableFilter<"User"> | string | null
    phoneNumber?: StringFilter<"User"> | string
    dateOfBirth?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    roleId?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    roleUsers?: RoleUserListRelationFilter
    individualProfessional?: XOR<IndividualProfessionalNullableScalarRelationFilter, IndividualProfessionalWhereInput> | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    securityCompany?: XOR<SecurityCompanyNullableScalarRelationFilter, SecurityCompanyWhereInput> | null
    courseProvider?: XOR<CourseProviderNullableScalarRelationFilter, CourseProviderWhereInput> | null
    corporateClient?: XOR<CorporateClientNullableScalarRelationFilter, CorporateClientWhereInput> | null
    VerificationCode?: XOR<VerificationCodeNullableScalarRelationFilter, VerificationCodeWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    screenName?: SortOrderInput | SortOrder
    phoneNumber?: SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: RoleOrderByWithRelationInput
    roleUsers?: RoleUserOrderByRelationAggregateInput
    individualProfessional?: IndividualProfessionalOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    securityCompany?: SecurityCompanyOrderByWithRelationInput
    courseProvider?: CourseProviderOrderByWithRelationInput
    corporateClient?: CorporateClientOrderByWithRelationInput
    VerificationCode?: VerificationCodeOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    screenName?: StringNullableFilter<"User"> | string | null
    phoneNumber?: StringFilter<"User"> | string
    dateOfBirth?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    roleId?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    roleUsers?: RoleUserListRelationFilter
    individualProfessional?: XOR<IndividualProfessionalNullableScalarRelationFilter, IndividualProfessionalWhereInput> | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    securityCompany?: XOR<SecurityCompanyNullableScalarRelationFilter, SecurityCompanyWhereInput> | null
    courseProvider?: XOR<CourseProviderNullableScalarRelationFilter, CourseProviderWhereInput> | null
    corporateClient?: XOR<CorporateClientNullableScalarRelationFilter, CorporateClientWhereInput> | null
    VerificationCode?: XOR<VerificationCodeNullableScalarRelationFilter, VerificationCodeWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    screenName?: SortOrderInput | SortOrder
    phoneNumber?: SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    screenName?: StringNullableWithAggregatesFilter<"User"> | string | null
    phoneNumber?: StringWithAggregatesFilter<"User"> | string
    dateOfBirth?: StringNullableWithAggregatesFilter<"User"> | string | null
    address?: StringNullableWithAggregatesFilter<"User"> | string | null
    roleId?: IntWithAggregatesFilter<"User"> | number
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type IndividualProfessionalWhereInput = {
    AND?: IndividualProfessionalWhereInput | IndividualProfessionalWhereInput[]
    OR?: IndividualProfessionalWhereInput[]
    NOT?: IndividualProfessionalWhereInput | IndividualProfessionalWhereInput[]
    id?: IntFilter<"IndividualProfessional"> | number
    userId?: IntFilter<"IndividualProfessional"> | number
    profileData?: JsonFilter<"IndividualProfessional">
    permissions?: JsonNullableFilter<"IndividualProfessional">
    createdAt?: DateTimeFilter<"IndividualProfessional"> | Date | string
    updatedAt?: DateTimeFilter<"IndividualProfessional"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type IndividualProfessionalOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    profileData?: SortOrder
    permissions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type IndividualProfessionalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: IndividualProfessionalWhereInput | IndividualProfessionalWhereInput[]
    OR?: IndividualProfessionalWhereInput[]
    NOT?: IndividualProfessionalWhereInput | IndividualProfessionalWhereInput[]
    profileData?: JsonFilter<"IndividualProfessional">
    permissions?: JsonNullableFilter<"IndividualProfessional">
    createdAt?: DateTimeFilter<"IndividualProfessional"> | Date | string
    updatedAt?: DateTimeFilter<"IndividualProfessional"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type IndividualProfessionalOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    profileData?: SortOrder
    permissions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IndividualProfessionalCountOrderByAggregateInput
    _avg?: IndividualProfessionalAvgOrderByAggregateInput
    _max?: IndividualProfessionalMaxOrderByAggregateInput
    _min?: IndividualProfessionalMinOrderByAggregateInput
    _sum?: IndividualProfessionalSumOrderByAggregateInput
  }

  export type IndividualProfessionalScalarWhereWithAggregatesInput = {
    AND?: IndividualProfessionalScalarWhereWithAggregatesInput | IndividualProfessionalScalarWhereWithAggregatesInput[]
    OR?: IndividualProfessionalScalarWhereWithAggregatesInput[]
    NOT?: IndividualProfessionalScalarWhereWithAggregatesInput | IndividualProfessionalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"IndividualProfessional"> | number
    userId?: IntWithAggregatesFilter<"IndividualProfessional"> | number
    profileData?: JsonWithAggregatesFilter<"IndividualProfessional">
    permissions?: JsonNullableWithAggregatesFilter<"IndividualProfessional">
    createdAt?: DateTimeWithAggregatesFilter<"IndividualProfessional"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IndividualProfessional"> | Date | string
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: IntFilter<"Client"> | number
    userId?: IntFilter<"Client"> | number
    permissions?: JsonNullableFilter<"Client">
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    ads?: ClientAdListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    permissions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    ads?: ClientAdOrderByRelationAggregateInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    permissions?: JsonNullableFilter<"Client">
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    ads?: ClientAdListRelationFilter
  }, "id" | "userId">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    permissions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _avg?: ClientAvgOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
    _sum?: ClientSumOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Client"> | number
    userId?: IntWithAggregatesFilter<"Client"> | number
    permissions?: JsonNullableWithAggregatesFilter<"Client">
    createdAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
  }

  export type SecurityCompanyWhereInput = {
    AND?: SecurityCompanyWhereInput | SecurityCompanyWhereInput[]
    OR?: SecurityCompanyWhereInput[]
    NOT?: SecurityCompanyWhereInput | SecurityCompanyWhereInput[]
    id?: IntFilter<"SecurityCompany"> | number
    userId?: IntFilter<"SecurityCompany"> | number
    companyName?: StringFilter<"SecurityCompany"> | string
    registrationNumber?: StringFilter<"SecurityCompany"> | string
    address?: StringFilter<"SecurityCompany"> | string
    postCode?: StringFilter<"SecurityCompany"> | string
    contactPerson?: StringFilter<"SecurityCompany"> | string
    jobTitle?: StringFilter<"SecurityCompany"> | string
    phoneNumber?: StringFilter<"SecurityCompany"> | string
    website?: StringNullableFilter<"SecurityCompany"> | string | null
    servicesRequirements?: JsonNullableFilter<"SecurityCompany">
    securityServicesOfferings?: JsonNullableFilter<"SecurityCompany">
    permissions?: JsonNullableFilter<"SecurityCompany">
    createdAt?: DateTimeFilter<"SecurityCompany"> | Date | string
    updatedAt?: DateTimeFilter<"SecurityCompany"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    serviceAds?: ServiceAdListRelationFilter
  }

  export type SecurityCompanyOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    registrationNumber?: SortOrder
    address?: SortOrder
    postCode?: SortOrder
    contactPerson?: SortOrder
    jobTitle?: SortOrder
    phoneNumber?: SortOrder
    website?: SortOrderInput | SortOrder
    servicesRequirements?: SortOrderInput | SortOrder
    securityServicesOfferings?: SortOrderInput | SortOrder
    permissions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    serviceAds?: ServiceAdOrderByRelationAggregateInput
  }

  export type SecurityCompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: SecurityCompanyWhereInput | SecurityCompanyWhereInput[]
    OR?: SecurityCompanyWhereInput[]
    NOT?: SecurityCompanyWhereInput | SecurityCompanyWhereInput[]
    companyName?: StringFilter<"SecurityCompany"> | string
    registrationNumber?: StringFilter<"SecurityCompany"> | string
    address?: StringFilter<"SecurityCompany"> | string
    postCode?: StringFilter<"SecurityCompany"> | string
    contactPerson?: StringFilter<"SecurityCompany"> | string
    jobTitle?: StringFilter<"SecurityCompany"> | string
    phoneNumber?: StringFilter<"SecurityCompany"> | string
    website?: StringNullableFilter<"SecurityCompany"> | string | null
    servicesRequirements?: JsonNullableFilter<"SecurityCompany">
    securityServicesOfferings?: JsonNullableFilter<"SecurityCompany">
    permissions?: JsonNullableFilter<"SecurityCompany">
    createdAt?: DateTimeFilter<"SecurityCompany"> | Date | string
    updatedAt?: DateTimeFilter<"SecurityCompany"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    serviceAds?: ServiceAdListRelationFilter
  }, "id" | "userId">

  export type SecurityCompanyOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    registrationNumber?: SortOrder
    address?: SortOrder
    postCode?: SortOrder
    contactPerson?: SortOrder
    jobTitle?: SortOrder
    phoneNumber?: SortOrder
    website?: SortOrderInput | SortOrder
    servicesRequirements?: SortOrderInput | SortOrder
    securityServicesOfferings?: SortOrderInput | SortOrder
    permissions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SecurityCompanyCountOrderByAggregateInput
    _avg?: SecurityCompanyAvgOrderByAggregateInput
    _max?: SecurityCompanyMaxOrderByAggregateInput
    _min?: SecurityCompanyMinOrderByAggregateInput
    _sum?: SecurityCompanySumOrderByAggregateInput
  }

  export type SecurityCompanyScalarWhereWithAggregatesInput = {
    AND?: SecurityCompanyScalarWhereWithAggregatesInput | SecurityCompanyScalarWhereWithAggregatesInput[]
    OR?: SecurityCompanyScalarWhereWithAggregatesInput[]
    NOT?: SecurityCompanyScalarWhereWithAggregatesInput | SecurityCompanyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SecurityCompany"> | number
    userId?: IntWithAggregatesFilter<"SecurityCompany"> | number
    companyName?: StringWithAggregatesFilter<"SecurityCompany"> | string
    registrationNumber?: StringWithAggregatesFilter<"SecurityCompany"> | string
    address?: StringWithAggregatesFilter<"SecurityCompany"> | string
    postCode?: StringWithAggregatesFilter<"SecurityCompany"> | string
    contactPerson?: StringWithAggregatesFilter<"SecurityCompany"> | string
    jobTitle?: StringWithAggregatesFilter<"SecurityCompany"> | string
    phoneNumber?: StringWithAggregatesFilter<"SecurityCompany"> | string
    website?: StringNullableWithAggregatesFilter<"SecurityCompany"> | string | null
    servicesRequirements?: JsonNullableWithAggregatesFilter<"SecurityCompany">
    securityServicesOfferings?: JsonNullableWithAggregatesFilter<"SecurityCompany">
    permissions?: JsonNullableWithAggregatesFilter<"SecurityCompany">
    createdAt?: DateTimeWithAggregatesFilter<"SecurityCompany"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SecurityCompany"> | Date | string
  }

  export type CourseProviderWhereInput = {
    AND?: CourseProviderWhereInput | CourseProviderWhereInput[]
    OR?: CourseProviderWhereInput[]
    NOT?: CourseProviderWhereInput | CourseProviderWhereInput[]
    id?: IntFilter<"CourseProvider"> | number
    userId?: IntFilter<"CourseProvider"> | number
    companyName?: StringFilter<"CourseProvider"> | string
    registrationNumber?: StringFilter<"CourseProvider"> | string
    address?: StringFilter<"CourseProvider"> | string
    postCode?: StringFilter<"CourseProvider"> | string
    contactPerson?: StringFilter<"CourseProvider"> | string
    jobTitle?: StringFilter<"CourseProvider"> | string
    phoneNumber?: StringFilter<"CourseProvider"> | string
    website?: StringNullableFilter<"CourseProvider"> | string | null
    servicesRequirements?: JsonNullableFilter<"CourseProvider">
    securityServicesOfferings?: JsonNullableFilter<"CourseProvider">
    permissions?: JsonNullableFilter<"CourseProvider">
    createdAt?: DateTimeFilter<"CourseProvider"> | Date | string
    updatedAt?: DateTimeFilter<"CourseProvider"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    courseAds?: CourseAdListRelationFilter
  }

  export type CourseProviderOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    registrationNumber?: SortOrder
    address?: SortOrder
    postCode?: SortOrder
    contactPerson?: SortOrder
    jobTitle?: SortOrder
    phoneNumber?: SortOrder
    website?: SortOrderInput | SortOrder
    servicesRequirements?: SortOrderInput | SortOrder
    securityServicesOfferings?: SortOrderInput | SortOrder
    permissions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    courseAds?: CourseAdOrderByRelationAggregateInput
  }

  export type CourseProviderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: CourseProviderWhereInput | CourseProviderWhereInput[]
    OR?: CourseProviderWhereInput[]
    NOT?: CourseProviderWhereInput | CourseProviderWhereInput[]
    companyName?: StringFilter<"CourseProvider"> | string
    registrationNumber?: StringFilter<"CourseProvider"> | string
    address?: StringFilter<"CourseProvider"> | string
    postCode?: StringFilter<"CourseProvider"> | string
    contactPerson?: StringFilter<"CourseProvider"> | string
    jobTitle?: StringFilter<"CourseProvider"> | string
    phoneNumber?: StringFilter<"CourseProvider"> | string
    website?: StringNullableFilter<"CourseProvider"> | string | null
    servicesRequirements?: JsonNullableFilter<"CourseProvider">
    securityServicesOfferings?: JsonNullableFilter<"CourseProvider">
    permissions?: JsonNullableFilter<"CourseProvider">
    createdAt?: DateTimeFilter<"CourseProvider"> | Date | string
    updatedAt?: DateTimeFilter<"CourseProvider"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    courseAds?: CourseAdListRelationFilter
  }, "id" | "userId">

  export type CourseProviderOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    registrationNumber?: SortOrder
    address?: SortOrder
    postCode?: SortOrder
    contactPerson?: SortOrder
    jobTitle?: SortOrder
    phoneNumber?: SortOrder
    website?: SortOrderInput | SortOrder
    servicesRequirements?: SortOrderInput | SortOrder
    securityServicesOfferings?: SortOrderInput | SortOrder
    permissions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CourseProviderCountOrderByAggregateInput
    _avg?: CourseProviderAvgOrderByAggregateInput
    _max?: CourseProviderMaxOrderByAggregateInput
    _min?: CourseProviderMinOrderByAggregateInput
    _sum?: CourseProviderSumOrderByAggregateInput
  }

  export type CourseProviderScalarWhereWithAggregatesInput = {
    AND?: CourseProviderScalarWhereWithAggregatesInput | CourseProviderScalarWhereWithAggregatesInput[]
    OR?: CourseProviderScalarWhereWithAggregatesInput[]
    NOT?: CourseProviderScalarWhereWithAggregatesInput | CourseProviderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CourseProvider"> | number
    userId?: IntWithAggregatesFilter<"CourseProvider"> | number
    companyName?: StringWithAggregatesFilter<"CourseProvider"> | string
    registrationNumber?: StringWithAggregatesFilter<"CourseProvider"> | string
    address?: StringWithAggregatesFilter<"CourseProvider"> | string
    postCode?: StringWithAggregatesFilter<"CourseProvider"> | string
    contactPerson?: StringWithAggregatesFilter<"CourseProvider"> | string
    jobTitle?: StringWithAggregatesFilter<"CourseProvider"> | string
    phoneNumber?: StringWithAggregatesFilter<"CourseProvider"> | string
    website?: StringNullableWithAggregatesFilter<"CourseProvider"> | string | null
    servicesRequirements?: JsonNullableWithAggregatesFilter<"CourseProvider">
    securityServicesOfferings?: JsonNullableWithAggregatesFilter<"CourseProvider">
    permissions?: JsonNullableWithAggregatesFilter<"CourseProvider">
    createdAt?: DateTimeWithAggregatesFilter<"CourseProvider"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CourseProvider"> | Date | string
  }

  export type CorporateClientWhereInput = {
    AND?: CorporateClientWhereInput | CorporateClientWhereInput[]
    OR?: CorporateClientWhereInput[]
    NOT?: CorporateClientWhereInput | CorporateClientWhereInput[]
    id?: IntFilter<"CorporateClient"> | number
    userId?: IntFilter<"CorporateClient"> | number
    companyName?: StringFilter<"CorporateClient"> | string
    registrationNumber?: StringFilter<"CorporateClient"> | string
    address?: StringFilter<"CorporateClient"> | string
    postCode?: StringFilter<"CorporateClient"> | string
    industryType?: StringFilter<"CorporateClient"> | string
    contactPerson?: StringFilter<"CorporateClient"> | string
    jobTitle?: StringFilter<"CorporateClient"> | string
    phoneNumber?: StringFilter<"CorporateClient"> | string
    website?: StringNullableFilter<"CorporateClient"> | string | null
    serviceRequirements?: JsonNullableFilter<"CorporateClient">
    permissions?: JsonNullableFilter<"CorporateClient">
    createdAt?: DateTimeFilter<"CorporateClient"> | Date | string
    updatedAt?: DateTimeFilter<"CorporateClient"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    corporateAds?: CorporateAdListRelationFilter
  }

  export type CorporateClientOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    registrationNumber?: SortOrder
    address?: SortOrder
    postCode?: SortOrder
    industryType?: SortOrder
    contactPerson?: SortOrder
    jobTitle?: SortOrder
    phoneNumber?: SortOrder
    website?: SortOrderInput | SortOrder
    serviceRequirements?: SortOrderInput | SortOrder
    permissions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    corporateAds?: CorporateAdOrderByRelationAggregateInput
  }

  export type CorporateClientWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: CorporateClientWhereInput | CorporateClientWhereInput[]
    OR?: CorporateClientWhereInput[]
    NOT?: CorporateClientWhereInput | CorporateClientWhereInput[]
    companyName?: StringFilter<"CorporateClient"> | string
    registrationNumber?: StringFilter<"CorporateClient"> | string
    address?: StringFilter<"CorporateClient"> | string
    postCode?: StringFilter<"CorporateClient"> | string
    industryType?: StringFilter<"CorporateClient"> | string
    contactPerson?: StringFilter<"CorporateClient"> | string
    jobTitle?: StringFilter<"CorporateClient"> | string
    phoneNumber?: StringFilter<"CorporateClient"> | string
    website?: StringNullableFilter<"CorporateClient"> | string | null
    serviceRequirements?: JsonNullableFilter<"CorporateClient">
    permissions?: JsonNullableFilter<"CorporateClient">
    createdAt?: DateTimeFilter<"CorporateClient"> | Date | string
    updatedAt?: DateTimeFilter<"CorporateClient"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    corporateAds?: CorporateAdListRelationFilter
  }, "id" | "userId">

  export type CorporateClientOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    registrationNumber?: SortOrder
    address?: SortOrder
    postCode?: SortOrder
    industryType?: SortOrder
    contactPerson?: SortOrder
    jobTitle?: SortOrder
    phoneNumber?: SortOrder
    website?: SortOrderInput | SortOrder
    serviceRequirements?: SortOrderInput | SortOrder
    permissions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CorporateClientCountOrderByAggregateInput
    _avg?: CorporateClientAvgOrderByAggregateInput
    _max?: CorporateClientMaxOrderByAggregateInput
    _min?: CorporateClientMinOrderByAggregateInput
    _sum?: CorporateClientSumOrderByAggregateInput
  }

  export type CorporateClientScalarWhereWithAggregatesInput = {
    AND?: CorporateClientScalarWhereWithAggregatesInput | CorporateClientScalarWhereWithAggregatesInput[]
    OR?: CorporateClientScalarWhereWithAggregatesInput[]
    NOT?: CorporateClientScalarWhereWithAggregatesInput | CorporateClientScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CorporateClient"> | number
    userId?: IntWithAggregatesFilter<"CorporateClient"> | number
    companyName?: StringWithAggregatesFilter<"CorporateClient"> | string
    registrationNumber?: StringWithAggregatesFilter<"CorporateClient"> | string
    address?: StringWithAggregatesFilter<"CorporateClient"> | string
    postCode?: StringWithAggregatesFilter<"CorporateClient"> | string
    industryType?: StringWithAggregatesFilter<"CorporateClient"> | string
    contactPerson?: StringWithAggregatesFilter<"CorporateClient"> | string
    jobTitle?: StringWithAggregatesFilter<"CorporateClient"> | string
    phoneNumber?: StringWithAggregatesFilter<"CorporateClient"> | string
    website?: StringNullableWithAggregatesFilter<"CorporateClient"> | string | null
    serviceRequirements?: JsonNullableWithAggregatesFilter<"CorporateClient">
    permissions?: JsonNullableWithAggregatesFilter<"CorporateClient">
    createdAt?: DateTimeWithAggregatesFilter<"CorporateClient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CorporateClient"> | Date | string
  }

  export type CorporateAdWhereInput = {
    AND?: CorporateAdWhereInput | CorporateAdWhereInput[]
    OR?: CorporateAdWhereInput[]
    NOT?: CorporateAdWhereInput | CorporateAdWhereInput[]
    id?: IntFilter<"CorporateAd"> | number
    corporateClientId?: IntFilter<"CorporateAd"> | number
    title?: StringFilter<"CorporateAd"> | string
    description?: StringFilter<"CorporateAd"> | string
    createdAt?: DateTimeFilter<"CorporateAd"> | Date | string
    updatedAt?: DateTimeFilter<"CorporateAd"> | Date | string
    corporateClient?: XOR<CorporateClientScalarRelationFilter, CorporateClientWhereInput>
  }

  export type CorporateAdOrderByWithRelationInput = {
    id?: SortOrder
    corporateClientId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    corporateClient?: CorporateClientOrderByWithRelationInput
  }

  export type CorporateAdWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CorporateAdWhereInput | CorporateAdWhereInput[]
    OR?: CorporateAdWhereInput[]
    NOT?: CorporateAdWhereInput | CorporateAdWhereInput[]
    corporateClientId?: IntFilter<"CorporateAd"> | number
    title?: StringFilter<"CorporateAd"> | string
    description?: StringFilter<"CorporateAd"> | string
    createdAt?: DateTimeFilter<"CorporateAd"> | Date | string
    updatedAt?: DateTimeFilter<"CorporateAd"> | Date | string
    corporateClient?: XOR<CorporateClientScalarRelationFilter, CorporateClientWhereInput>
  }, "id">

  export type CorporateAdOrderByWithAggregationInput = {
    id?: SortOrder
    corporateClientId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CorporateAdCountOrderByAggregateInput
    _avg?: CorporateAdAvgOrderByAggregateInput
    _max?: CorporateAdMaxOrderByAggregateInput
    _min?: CorporateAdMinOrderByAggregateInput
    _sum?: CorporateAdSumOrderByAggregateInput
  }

  export type CorporateAdScalarWhereWithAggregatesInput = {
    AND?: CorporateAdScalarWhereWithAggregatesInput | CorporateAdScalarWhereWithAggregatesInput[]
    OR?: CorporateAdScalarWhereWithAggregatesInput[]
    NOT?: CorporateAdScalarWhereWithAggregatesInput | CorporateAdScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CorporateAd"> | number
    corporateClientId?: IntWithAggregatesFilter<"CorporateAd"> | number
    title?: StringWithAggregatesFilter<"CorporateAd"> | string
    description?: StringWithAggregatesFilter<"CorporateAd"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CorporateAd"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CorporateAd"> | Date | string
  }

  export type CourseAdWhereInput = {
    AND?: CourseAdWhereInput | CourseAdWhereInput[]
    OR?: CourseAdWhereInput[]
    NOT?: CourseAdWhereInput | CourseAdWhereInput[]
    id?: IntFilter<"CourseAd"> | number
    courseProviderId?: IntFilter<"CourseAd"> | number
    title?: StringFilter<"CourseAd"> | string
    description?: StringFilter<"CourseAd"> | string
    createdAt?: DateTimeFilter<"CourseAd"> | Date | string
    updatedAt?: DateTimeFilter<"CourseAd"> | Date | string
    courseProvider?: XOR<CourseProviderScalarRelationFilter, CourseProviderWhereInput>
  }

  export type CourseAdOrderByWithRelationInput = {
    id?: SortOrder
    courseProviderId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courseProvider?: CourseProviderOrderByWithRelationInput
  }

  export type CourseAdWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CourseAdWhereInput | CourseAdWhereInput[]
    OR?: CourseAdWhereInput[]
    NOT?: CourseAdWhereInput | CourseAdWhereInput[]
    courseProviderId?: IntFilter<"CourseAd"> | number
    title?: StringFilter<"CourseAd"> | string
    description?: StringFilter<"CourseAd"> | string
    createdAt?: DateTimeFilter<"CourseAd"> | Date | string
    updatedAt?: DateTimeFilter<"CourseAd"> | Date | string
    courseProvider?: XOR<CourseProviderScalarRelationFilter, CourseProviderWhereInput>
  }, "id">

  export type CourseAdOrderByWithAggregationInput = {
    id?: SortOrder
    courseProviderId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CourseAdCountOrderByAggregateInput
    _avg?: CourseAdAvgOrderByAggregateInput
    _max?: CourseAdMaxOrderByAggregateInput
    _min?: CourseAdMinOrderByAggregateInput
    _sum?: CourseAdSumOrderByAggregateInput
  }

  export type CourseAdScalarWhereWithAggregatesInput = {
    AND?: CourseAdScalarWhereWithAggregatesInput | CourseAdScalarWhereWithAggregatesInput[]
    OR?: CourseAdScalarWhereWithAggregatesInput[]
    NOT?: CourseAdScalarWhereWithAggregatesInput | CourseAdScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CourseAd"> | number
    courseProviderId?: IntWithAggregatesFilter<"CourseAd"> | number
    title?: StringWithAggregatesFilter<"CourseAd"> | string
    description?: StringWithAggregatesFilter<"CourseAd"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CourseAd"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CourseAd"> | Date | string
  }

  export type ServiceAdWhereInput = {
    AND?: ServiceAdWhereInput | ServiceAdWhereInput[]
    OR?: ServiceAdWhereInput[]
    NOT?: ServiceAdWhereInput | ServiceAdWhereInput[]
    id?: IntFilter<"ServiceAd"> | number
    companyId?: IntFilter<"ServiceAd"> | number
    jobTitle?: StringFilter<"ServiceAd"> | string
    jobType?: StringFilter<"ServiceAd"> | string
    industryCategory?: StringFilter<"ServiceAd"> | string
    region?: StringFilter<"ServiceAd"> | string
    postcode?: StringFilter<"ServiceAd"> | string
    salaryRate?: FloatFilter<"ServiceAd"> | number
    salaryType?: StringFilter<"ServiceAd"> | string
    jobDescription?: StringFilter<"ServiceAd"> | string
    requiredExperience?: StringFilter<"ServiceAd"> | string
    requiredLicences?: StringNullableFilter<"ServiceAd"> | string | null
    shiftAndHours?: StringNullableFilter<"ServiceAd"> | string | null
    startDate?: DateTimeNullableFilter<"ServiceAd"> | Date | string | null
    deadline?: DateTimeNullableFilter<"ServiceAd"> | Date | string | null
    createdAt?: DateTimeFilter<"ServiceAd"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceAd"> | Date | string
    company?: XOR<SecurityCompanyScalarRelationFilter, SecurityCompanyWhereInput>
  }

  export type ServiceAdOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    jobTitle?: SortOrder
    jobType?: SortOrder
    industryCategory?: SortOrder
    region?: SortOrder
    postcode?: SortOrder
    salaryRate?: SortOrder
    salaryType?: SortOrder
    jobDescription?: SortOrder
    requiredExperience?: SortOrder
    requiredLicences?: SortOrderInput | SortOrder
    shiftAndHours?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    deadline?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: SecurityCompanyOrderByWithRelationInput
  }

  export type ServiceAdWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ServiceAdWhereInput | ServiceAdWhereInput[]
    OR?: ServiceAdWhereInput[]
    NOT?: ServiceAdWhereInput | ServiceAdWhereInput[]
    companyId?: IntFilter<"ServiceAd"> | number
    jobTitle?: StringFilter<"ServiceAd"> | string
    jobType?: StringFilter<"ServiceAd"> | string
    industryCategory?: StringFilter<"ServiceAd"> | string
    region?: StringFilter<"ServiceAd"> | string
    postcode?: StringFilter<"ServiceAd"> | string
    salaryRate?: FloatFilter<"ServiceAd"> | number
    salaryType?: StringFilter<"ServiceAd"> | string
    jobDescription?: StringFilter<"ServiceAd"> | string
    requiredExperience?: StringFilter<"ServiceAd"> | string
    requiredLicences?: StringNullableFilter<"ServiceAd"> | string | null
    shiftAndHours?: StringNullableFilter<"ServiceAd"> | string | null
    startDate?: DateTimeNullableFilter<"ServiceAd"> | Date | string | null
    deadline?: DateTimeNullableFilter<"ServiceAd"> | Date | string | null
    createdAt?: DateTimeFilter<"ServiceAd"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceAd"> | Date | string
    company?: XOR<SecurityCompanyScalarRelationFilter, SecurityCompanyWhereInput>
  }, "id">

  export type ServiceAdOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    jobTitle?: SortOrder
    jobType?: SortOrder
    industryCategory?: SortOrder
    region?: SortOrder
    postcode?: SortOrder
    salaryRate?: SortOrder
    salaryType?: SortOrder
    jobDescription?: SortOrder
    requiredExperience?: SortOrder
    requiredLicences?: SortOrderInput | SortOrder
    shiftAndHours?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    deadline?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceAdCountOrderByAggregateInput
    _avg?: ServiceAdAvgOrderByAggregateInput
    _max?: ServiceAdMaxOrderByAggregateInput
    _min?: ServiceAdMinOrderByAggregateInput
    _sum?: ServiceAdSumOrderByAggregateInput
  }

  export type ServiceAdScalarWhereWithAggregatesInput = {
    AND?: ServiceAdScalarWhereWithAggregatesInput | ServiceAdScalarWhereWithAggregatesInput[]
    OR?: ServiceAdScalarWhereWithAggregatesInput[]
    NOT?: ServiceAdScalarWhereWithAggregatesInput | ServiceAdScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ServiceAd"> | number
    companyId?: IntWithAggregatesFilter<"ServiceAd"> | number
    jobTitle?: StringWithAggregatesFilter<"ServiceAd"> | string
    jobType?: StringWithAggregatesFilter<"ServiceAd"> | string
    industryCategory?: StringWithAggregatesFilter<"ServiceAd"> | string
    region?: StringWithAggregatesFilter<"ServiceAd"> | string
    postcode?: StringWithAggregatesFilter<"ServiceAd"> | string
    salaryRate?: FloatWithAggregatesFilter<"ServiceAd"> | number
    salaryType?: StringWithAggregatesFilter<"ServiceAd"> | string
    jobDescription?: StringWithAggregatesFilter<"ServiceAd"> | string
    requiredExperience?: StringWithAggregatesFilter<"ServiceAd"> | string
    requiredLicences?: StringNullableWithAggregatesFilter<"ServiceAd"> | string | null
    shiftAndHours?: StringNullableWithAggregatesFilter<"ServiceAd"> | string | null
    startDate?: DateTimeNullableWithAggregatesFilter<"ServiceAd"> | Date | string | null
    deadline?: DateTimeNullableWithAggregatesFilter<"ServiceAd"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ServiceAd"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceAd"> | Date | string
  }

  export type ClientAdWhereInput = {
    AND?: ClientAdWhereInput | ClientAdWhereInput[]
    OR?: ClientAdWhereInput[]
    NOT?: ClientAdWhereInput | ClientAdWhereInput[]
    id?: IntFilter<"ClientAd"> | number
    clientId?: IntFilter<"ClientAd"> | number
    title?: StringFilter<"ClientAd"> | string
    description?: StringFilter<"ClientAd"> | string
    createdAt?: DateTimeFilter<"ClientAd"> | Date | string
    updatedAt?: DateTimeFilter<"ClientAd"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }

  export type ClientAdOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
  }

  export type ClientAdWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClientAdWhereInput | ClientAdWhereInput[]
    OR?: ClientAdWhereInput[]
    NOT?: ClientAdWhereInput | ClientAdWhereInput[]
    clientId?: IntFilter<"ClientAd"> | number
    title?: StringFilter<"ClientAd"> | string
    description?: StringFilter<"ClientAd"> | string
    createdAt?: DateTimeFilter<"ClientAd"> | Date | string
    updatedAt?: DateTimeFilter<"ClientAd"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }, "id">

  export type ClientAdOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientAdCountOrderByAggregateInput
    _avg?: ClientAdAvgOrderByAggregateInput
    _max?: ClientAdMaxOrderByAggregateInput
    _min?: ClientAdMinOrderByAggregateInput
    _sum?: ClientAdSumOrderByAggregateInput
  }

  export type ClientAdScalarWhereWithAggregatesInput = {
    AND?: ClientAdScalarWhereWithAggregatesInput | ClientAdScalarWhereWithAggregatesInput[]
    OR?: ClientAdScalarWhereWithAggregatesInput[]
    NOT?: ClientAdScalarWhereWithAggregatesInput | ClientAdScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClientAd"> | number
    clientId?: IntWithAggregatesFilter<"ClientAd"> | number
    title?: StringWithAggregatesFilter<"ClientAd"> | string
    description?: StringWithAggregatesFilter<"ClientAd"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ClientAd"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClientAd"> | Date | string
  }

  export type RoleUserWhereInput = {
    AND?: RoleUserWhereInput | RoleUserWhereInput[]
    OR?: RoleUserWhereInput[]
    NOT?: RoleUserWhereInput | RoleUserWhereInput[]
    id?: IntFilter<"RoleUser"> | number
    roleId?: IntFilter<"RoleUser"> | number
    userId?: IntFilter<"RoleUser"> | number
    createdAt?: DateTimeFilter<"RoleUser"> | Date | string
    updatedAt?: DateTimeFilter<"RoleUser"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RoleUserOrderByWithRelationInput = {
    id?: SortOrder
    roleId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: RoleOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type RoleUserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RoleUserWhereInput | RoleUserWhereInput[]
    OR?: RoleUserWhereInput[]
    NOT?: RoleUserWhereInput | RoleUserWhereInput[]
    roleId?: IntFilter<"RoleUser"> | number
    userId?: IntFilter<"RoleUser"> | number
    createdAt?: DateTimeFilter<"RoleUser"> | Date | string
    updatedAt?: DateTimeFilter<"RoleUser"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type RoleUserOrderByWithAggregationInput = {
    id?: SortOrder
    roleId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleUserCountOrderByAggregateInput
    _avg?: RoleUserAvgOrderByAggregateInput
    _max?: RoleUserMaxOrderByAggregateInput
    _min?: RoleUserMinOrderByAggregateInput
    _sum?: RoleUserSumOrderByAggregateInput
  }

  export type RoleUserScalarWhereWithAggregatesInput = {
    AND?: RoleUserScalarWhereWithAggregatesInput | RoleUserScalarWhereWithAggregatesInput[]
    OR?: RoleUserScalarWhereWithAggregatesInput[]
    NOT?: RoleUserScalarWhereWithAggregatesInput | RoleUserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RoleUser"> | number
    roleId?: IntWithAggregatesFilter<"RoleUser"> | number
    userId?: IntWithAggregatesFilter<"RoleUser"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RoleUser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RoleUser"> | Date | string
  }

  export type PermissionCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: RolePermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: RolePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: RolePermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCodeCreateInput = {
    code: string
    expiresAt: Date | string
    user: UserCreateNestedOneWithoutVerificationCodeInput
  }

  export type VerificationCodeUncheckedCreateInput = {
    id?: number
    userId: number
    code: string
    expiresAt: Date | string
  }

  export type VerificationCodeUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVerificationCodeNestedInput
  }

  export type VerificationCodeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCodeCreateManyInput = {
    id?: number
    userId: number
    code: string
    expiresAt: Date | string
  }

  export type VerificationCodeUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCodeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionCreateNestedManyWithoutRoleInput
    users?: UserCreateNestedManyWithoutRoleInput
    roleUsers?: RoleUserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
    roleUsers?: RoleUserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUpdateManyWithoutRoleNestedInput
    users?: UserUpdateManyWithoutRoleNestedInput
    roleUsers?: RoleUserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
    roleUsers?: RoleUserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutPermissionsInput
    permission: PermissionCreateNestedOneWithoutRolesInput
  }

  export type RolePermissionUncheckedCreateInput = {
    id?: number
    roleId: number
    permissionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolePermissionUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutPermissionsNestedInput
    permission?: PermissionUpdateOneRequiredWithoutRolesNestedInput
  }

  export type RolePermissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyInput = {
    id?: number
    roleId: number
    permissionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolePermissionUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    screenName?: string | null
    phoneNumber: string
    dateOfBirth?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    roleUsers?: RoleUserCreateNestedManyWithoutUserInput
    individualProfessional?: IndividualProfessionalCreateNestedOneWithoutUserInput
    client?: ClientCreateNestedOneWithoutUserInput
    securityCompany?: SecurityCompanyCreateNestedOneWithoutUserInput
    courseProvider?: CourseProviderCreateNestedOneWithoutUserInput
    corporateClient?: CorporateClientCreateNestedOneWithoutUserInput
    VerificationCode?: VerificationCodeCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    screenName?: string | null
    phoneNumber: string
    dateOfBirth?: string | null
    address?: string | null
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    roleUsers?: RoleUserUncheckedCreateNestedManyWithoutUserInput
    individualProfessional?: IndividualProfessionalUncheckedCreateNestedOneWithoutUserInput
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    securityCompany?: SecurityCompanyUncheckedCreateNestedOneWithoutUserInput
    courseProvider?: CourseProviderUncheckedCreateNestedOneWithoutUserInput
    corporateClient?: CorporateClientUncheckedCreateNestedOneWithoutUserInput
    VerificationCode?: VerificationCodeUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    roleUsers?: RoleUserUpdateManyWithoutUserNestedInput
    individualProfessional?: IndividualProfessionalUpdateOneWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUserNestedInput
    securityCompany?: SecurityCompanyUpdateOneWithoutUserNestedInput
    courseProvider?: CourseProviderUpdateOneWithoutUserNestedInput
    corporateClient?: CorporateClientUpdateOneWithoutUserNestedInput
    VerificationCode?: VerificationCodeUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleUsers?: RoleUserUncheckedUpdateManyWithoutUserNestedInput
    individualProfessional?: IndividualProfessionalUncheckedUpdateOneWithoutUserNestedInput
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    securityCompany?: SecurityCompanyUncheckedUpdateOneWithoutUserNestedInput
    courseProvider?: CourseProviderUncheckedUpdateOneWithoutUserNestedInput
    corporateClient?: CorporateClientUncheckedUpdateOneWithoutUserNestedInput
    VerificationCode?: VerificationCodeUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    screenName?: string | null
    phoneNumber: string
    dateOfBirth?: string | null
    address?: string | null
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndividualProfessionalCreateInput = {
    profileData: JsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutIndividualProfessionalInput
  }

  export type IndividualProfessionalUncheckedCreateInput = {
    id?: number
    userId: number
    profileData: JsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndividualProfessionalUpdateInput = {
    profileData?: JsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutIndividualProfessionalNestedInput
  }

  export type IndividualProfessionalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    profileData?: JsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndividualProfessionalCreateManyInput = {
    id?: number
    userId: number
    profileData: JsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndividualProfessionalUpdateManyMutationInput = {
    profileData?: JsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndividualProfessionalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    profileData?: JsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateInput = {
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClientInput
    ads?: ClientAdCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: number
    userId: number
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ads?: ClientAdUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientNestedInput
    ads?: ClientAdUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ads?: ClientAdUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: number
    userId: number
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientUpdateManyMutationInput = {
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityCompanyCreateInput = {
    companyName: string
    registrationNumber: string
    address: string
    postCode: string
    contactPerson: string
    jobTitle: string
    phoneNumber: string
    website?: string | null
    servicesRequirements?: NullableJsonNullValueInput | InputJsonValue
    securityServicesOfferings?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSecurityCompanyInput
    serviceAds?: ServiceAdCreateNestedManyWithoutCompanyInput
  }

  export type SecurityCompanyUncheckedCreateInput = {
    id?: number
    userId: number
    companyName: string
    registrationNumber: string
    address: string
    postCode: string
    contactPerson: string
    jobTitle: string
    phoneNumber: string
    website?: string | null
    servicesRequirements?: NullableJsonNullValueInput | InputJsonValue
    securityServicesOfferings?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceAds?: ServiceAdUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type SecurityCompanyUpdateInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    servicesRequirements?: NullableJsonNullValueInput | InputJsonValue
    securityServicesOfferings?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSecurityCompanyNestedInput
    serviceAds?: ServiceAdUpdateManyWithoutCompanyNestedInput
  }

  export type SecurityCompanyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    servicesRequirements?: NullableJsonNullValueInput | InputJsonValue
    securityServicesOfferings?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceAds?: ServiceAdUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type SecurityCompanyCreateManyInput = {
    id?: number
    userId: number
    companyName: string
    registrationNumber: string
    address: string
    postCode: string
    contactPerson: string
    jobTitle: string
    phoneNumber: string
    website?: string | null
    servicesRequirements?: NullableJsonNullValueInput | InputJsonValue
    securityServicesOfferings?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecurityCompanyUpdateManyMutationInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    servicesRequirements?: NullableJsonNullValueInput | InputJsonValue
    securityServicesOfferings?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityCompanyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    servicesRequirements?: NullableJsonNullValueInput | InputJsonValue
    securityServicesOfferings?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseProviderCreateInput = {
    companyName: string
    registrationNumber: string
    address: string
    postCode: string
    contactPerson: string
    jobTitle: string
    phoneNumber: string
    website?: string | null
    servicesRequirements?: NullableJsonNullValueInput | InputJsonValue
    securityServicesOfferings?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCourseProviderInput
    courseAds?: CourseAdCreateNestedManyWithoutCourseProviderInput
  }

  export type CourseProviderUncheckedCreateInput = {
    id?: number
    userId: number
    companyName: string
    registrationNumber: string
    address: string
    postCode: string
    contactPerson: string
    jobTitle: string
    phoneNumber: string
    website?: string | null
    servicesRequirements?: NullableJsonNullValueInput | InputJsonValue
    securityServicesOfferings?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    courseAds?: CourseAdUncheckedCreateNestedManyWithoutCourseProviderInput
  }

  export type CourseProviderUpdateInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    servicesRequirements?: NullableJsonNullValueInput | InputJsonValue
    securityServicesOfferings?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCourseProviderNestedInput
    courseAds?: CourseAdUpdateManyWithoutCourseProviderNestedInput
  }

  export type CourseProviderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    servicesRequirements?: NullableJsonNullValueInput | InputJsonValue
    securityServicesOfferings?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseAds?: CourseAdUncheckedUpdateManyWithoutCourseProviderNestedInput
  }

  export type CourseProviderCreateManyInput = {
    id?: number
    userId: number
    companyName: string
    registrationNumber: string
    address: string
    postCode: string
    contactPerson: string
    jobTitle: string
    phoneNumber: string
    website?: string | null
    servicesRequirements?: NullableJsonNullValueInput | InputJsonValue
    securityServicesOfferings?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseProviderUpdateManyMutationInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    servicesRequirements?: NullableJsonNullValueInput | InputJsonValue
    securityServicesOfferings?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseProviderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    servicesRequirements?: NullableJsonNullValueInput | InputJsonValue
    securityServicesOfferings?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorporateClientCreateInput = {
    companyName: string
    registrationNumber: string
    address: string
    postCode: string
    industryType: string
    contactPerson: string
    jobTitle: string
    phoneNumber: string
    website?: string | null
    serviceRequirements?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCorporateClientInput
    corporateAds?: CorporateAdCreateNestedManyWithoutCorporateClientInput
  }

  export type CorporateClientUncheckedCreateInput = {
    id?: number
    userId: number
    companyName: string
    registrationNumber: string
    address: string
    postCode: string
    industryType: string
    contactPerson: string
    jobTitle: string
    phoneNumber: string
    website?: string | null
    serviceRequirements?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    corporateAds?: CorporateAdUncheckedCreateNestedManyWithoutCorporateClientInput
  }

  export type CorporateClientUpdateInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    industryType?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    serviceRequirements?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCorporateClientNestedInput
    corporateAds?: CorporateAdUpdateManyWithoutCorporateClientNestedInput
  }

  export type CorporateClientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    industryType?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    serviceRequirements?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    corporateAds?: CorporateAdUncheckedUpdateManyWithoutCorporateClientNestedInput
  }

  export type CorporateClientCreateManyInput = {
    id?: number
    userId: number
    companyName: string
    registrationNumber: string
    address: string
    postCode: string
    industryType: string
    contactPerson: string
    jobTitle: string
    phoneNumber: string
    website?: string | null
    serviceRequirements?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorporateClientUpdateManyMutationInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    industryType?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    serviceRequirements?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorporateClientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    industryType?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    serviceRequirements?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorporateAdCreateInput = {
    title: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    corporateClient: CorporateClientCreateNestedOneWithoutCorporateAdsInput
  }

  export type CorporateAdUncheckedCreateInput = {
    id?: number
    corporateClientId: number
    title: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorporateAdUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    corporateClient?: CorporateClientUpdateOneRequiredWithoutCorporateAdsNestedInput
  }

  export type CorporateAdUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    corporateClientId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorporateAdCreateManyInput = {
    id?: number
    corporateClientId: number
    title: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorporateAdUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorporateAdUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    corporateClientId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseAdCreateInput = {
    title: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProvider: CourseProviderCreateNestedOneWithoutCourseAdsInput
  }

  export type CourseAdUncheckedCreateInput = {
    id?: number
    courseProviderId: number
    title: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseAdUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProvider?: CourseProviderUpdateOneRequiredWithoutCourseAdsNestedInput
  }

  export type CourseAdUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseProviderId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseAdCreateManyInput = {
    id?: number
    courseProviderId: number
    title: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseAdUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseAdUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseProviderId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAdCreateInput = {
    jobTitle: string
    jobType: string
    industryCategory: string
    region: string
    postcode: string
    salaryRate: number
    salaryType: string
    jobDescription: string
    requiredExperience: string
    requiredLicences?: string | null
    shiftAndHours?: string | null
    startDate?: Date | string | null
    deadline?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: SecurityCompanyCreateNestedOneWithoutServiceAdsInput
  }

  export type ServiceAdUncheckedCreateInput = {
    id?: number
    companyId: number
    jobTitle: string
    jobType: string
    industryCategory: string
    region: string
    postcode: string
    salaryRate: number
    salaryType: string
    jobDescription: string
    requiredExperience: string
    requiredLicences?: string | null
    shiftAndHours?: string | null
    startDate?: Date | string | null
    deadline?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceAdUpdateInput = {
    jobTitle?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    industryCategory?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    postcode?: StringFieldUpdateOperationsInput | string
    salaryRate?: FloatFieldUpdateOperationsInput | number
    salaryType?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    requiredExperience?: StringFieldUpdateOperationsInput | string
    requiredLicences?: NullableStringFieldUpdateOperationsInput | string | null
    shiftAndHours?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: SecurityCompanyUpdateOneRequiredWithoutServiceAdsNestedInput
  }

  export type ServiceAdUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    jobTitle?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    industryCategory?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    postcode?: StringFieldUpdateOperationsInput | string
    salaryRate?: FloatFieldUpdateOperationsInput | number
    salaryType?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    requiredExperience?: StringFieldUpdateOperationsInput | string
    requiredLicences?: NullableStringFieldUpdateOperationsInput | string | null
    shiftAndHours?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAdCreateManyInput = {
    id?: number
    companyId: number
    jobTitle: string
    jobType: string
    industryCategory: string
    region: string
    postcode: string
    salaryRate: number
    salaryType: string
    jobDescription: string
    requiredExperience: string
    requiredLicences?: string | null
    shiftAndHours?: string | null
    startDate?: Date | string | null
    deadline?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceAdUpdateManyMutationInput = {
    jobTitle?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    industryCategory?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    postcode?: StringFieldUpdateOperationsInput | string
    salaryRate?: FloatFieldUpdateOperationsInput | number
    salaryType?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    requiredExperience?: StringFieldUpdateOperationsInput | string
    requiredLicences?: NullableStringFieldUpdateOperationsInput | string | null
    shiftAndHours?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAdUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    jobTitle?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    industryCategory?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    postcode?: StringFieldUpdateOperationsInput | string
    salaryRate?: FloatFieldUpdateOperationsInput | number
    salaryType?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    requiredExperience?: StringFieldUpdateOperationsInput | string
    requiredLicences?: NullableStringFieldUpdateOperationsInput | string | null
    shiftAndHours?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientAdCreateInput = {
    title: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutAdsInput
  }

  export type ClientAdUncheckedCreateInput = {
    id?: number
    clientId: number
    title: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientAdUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutAdsNestedInput
  }

  export type ClientAdUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientAdCreateManyInput = {
    id?: number
    clientId: number
    title: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientAdUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientAdUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUserCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutRoleUsersInput
    user: UserCreateNestedOneWithoutRoleUsersInput
  }

  export type RoleUserUncheckedCreateInput = {
    id?: number
    roleId: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUserUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutRoleUsersNestedInput
    user?: UserUpdateOneRequiredWithoutRoleUsersNestedInput
  }

  export type RoleUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUserCreateManyInput = {
    id?: number
    roleId: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUserUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type RolePermissionListRelationFilter = {
    every?: RolePermissionWhereInput
    some?: RolePermissionWhereInput
    none?: RolePermissionWhereInput
  }

  export type RolePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type VerificationCodeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
  }

  export type VerificationCodeAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type VerificationCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
  }

  export type VerificationCodeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
  }

  export type VerificationCodeSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type RoleUserListRelationFilter = {
    every?: RoleUserWhereInput
    some?: RoleUserWhereInput
    none?: RoleUserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type PermissionScalarRelationFilter = {
    is?: PermissionWhereInput
    isNot?: PermissionWhereInput
  }

  export type RolePermissionCountOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RolePermissionAvgOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type RolePermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RolePermissionMinOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RolePermissionSumOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IndividualProfessionalNullableScalarRelationFilter = {
    is?: IndividualProfessionalWhereInput | null
    isNot?: IndividualProfessionalWhereInput | null
  }

  export type ClientNullableScalarRelationFilter = {
    is?: ClientWhereInput | null
    isNot?: ClientWhereInput | null
  }

  export type SecurityCompanyNullableScalarRelationFilter = {
    is?: SecurityCompanyWhereInput | null
    isNot?: SecurityCompanyWhereInput | null
  }

  export type CourseProviderNullableScalarRelationFilter = {
    is?: CourseProviderWhereInput | null
    isNot?: CourseProviderWhereInput | null
  }

  export type CorporateClientNullableScalarRelationFilter = {
    is?: CorporateClientWhereInput | null
    isNot?: CorporateClientWhereInput | null
  }

  export type VerificationCodeNullableScalarRelationFilter = {
    is?: VerificationCodeWhereInput | null
    isNot?: VerificationCodeWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    screenName?: SortOrder
    phoneNumber?: SortOrder
    dateOfBirth?: SortOrder
    address?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    screenName?: SortOrder
    phoneNumber?: SortOrder
    dateOfBirth?: SortOrder
    address?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    screenName?: SortOrder
    phoneNumber?: SortOrder
    dateOfBirth?: SortOrder
    address?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IndividualProfessionalCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    profileData?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndividualProfessionalAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type IndividualProfessionalMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndividualProfessionalMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndividualProfessionalSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type ClientAdListRelationFilter = {
    every?: ClientAdWhereInput
    some?: ClientAdWhereInput
    none?: ClientAdWhereInput
  }

  export type ClientAdOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ServiceAdListRelationFilter = {
    every?: ServiceAdWhereInput
    some?: ServiceAdWhereInput
    none?: ServiceAdWhereInput
  }

  export type ServiceAdOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SecurityCompanyCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    registrationNumber?: SortOrder
    address?: SortOrder
    postCode?: SortOrder
    contactPerson?: SortOrder
    jobTitle?: SortOrder
    phoneNumber?: SortOrder
    website?: SortOrder
    servicesRequirements?: SortOrder
    securityServicesOfferings?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecurityCompanyAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type SecurityCompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    registrationNumber?: SortOrder
    address?: SortOrder
    postCode?: SortOrder
    contactPerson?: SortOrder
    jobTitle?: SortOrder
    phoneNumber?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecurityCompanyMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    registrationNumber?: SortOrder
    address?: SortOrder
    postCode?: SortOrder
    contactPerson?: SortOrder
    jobTitle?: SortOrder
    phoneNumber?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecurityCompanySumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type CourseAdListRelationFilter = {
    every?: CourseAdWhereInput
    some?: CourseAdWhereInput
    none?: CourseAdWhereInput
  }

  export type CourseAdOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseProviderCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    registrationNumber?: SortOrder
    address?: SortOrder
    postCode?: SortOrder
    contactPerson?: SortOrder
    jobTitle?: SortOrder
    phoneNumber?: SortOrder
    website?: SortOrder
    servicesRequirements?: SortOrder
    securityServicesOfferings?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseProviderAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type CourseProviderMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    registrationNumber?: SortOrder
    address?: SortOrder
    postCode?: SortOrder
    contactPerson?: SortOrder
    jobTitle?: SortOrder
    phoneNumber?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseProviderMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    registrationNumber?: SortOrder
    address?: SortOrder
    postCode?: SortOrder
    contactPerson?: SortOrder
    jobTitle?: SortOrder
    phoneNumber?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseProviderSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type CorporateAdListRelationFilter = {
    every?: CorporateAdWhereInput
    some?: CorporateAdWhereInput
    none?: CorporateAdWhereInput
  }

  export type CorporateAdOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CorporateClientCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    registrationNumber?: SortOrder
    address?: SortOrder
    postCode?: SortOrder
    industryType?: SortOrder
    contactPerson?: SortOrder
    jobTitle?: SortOrder
    phoneNumber?: SortOrder
    website?: SortOrder
    serviceRequirements?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CorporateClientAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type CorporateClientMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    registrationNumber?: SortOrder
    address?: SortOrder
    postCode?: SortOrder
    industryType?: SortOrder
    contactPerson?: SortOrder
    jobTitle?: SortOrder
    phoneNumber?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CorporateClientMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    registrationNumber?: SortOrder
    address?: SortOrder
    postCode?: SortOrder
    industryType?: SortOrder
    contactPerson?: SortOrder
    jobTitle?: SortOrder
    phoneNumber?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CorporateClientSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type CorporateClientScalarRelationFilter = {
    is?: CorporateClientWhereInput
    isNot?: CorporateClientWhereInput
  }

  export type CorporateAdCountOrderByAggregateInput = {
    id?: SortOrder
    corporateClientId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CorporateAdAvgOrderByAggregateInput = {
    id?: SortOrder
    corporateClientId?: SortOrder
  }

  export type CorporateAdMaxOrderByAggregateInput = {
    id?: SortOrder
    corporateClientId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CorporateAdMinOrderByAggregateInput = {
    id?: SortOrder
    corporateClientId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CorporateAdSumOrderByAggregateInput = {
    id?: SortOrder
    corporateClientId?: SortOrder
  }

  export type CourseProviderScalarRelationFilter = {
    is?: CourseProviderWhereInput
    isNot?: CourseProviderWhereInput
  }

  export type CourseAdCountOrderByAggregateInput = {
    id?: SortOrder
    courseProviderId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseAdAvgOrderByAggregateInput = {
    id?: SortOrder
    courseProviderId?: SortOrder
  }

  export type CourseAdMaxOrderByAggregateInput = {
    id?: SortOrder
    courseProviderId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseAdMinOrderByAggregateInput = {
    id?: SortOrder
    courseProviderId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseAdSumOrderByAggregateInput = {
    id?: SortOrder
    courseProviderId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SecurityCompanyScalarRelationFilter = {
    is?: SecurityCompanyWhereInput
    isNot?: SecurityCompanyWhereInput
  }

  export type ServiceAdCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    jobTitle?: SortOrder
    jobType?: SortOrder
    industryCategory?: SortOrder
    region?: SortOrder
    postcode?: SortOrder
    salaryRate?: SortOrder
    salaryType?: SortOrder
    jobDescription?: SortOrder
    requiredExperience?: SortOrder
    requiredLicences?: SortOrder
    shiftAndHours?: SortOrder
    startDate?: SortOrder
    deadline?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceAdAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    salaryRate?: SortOrder
  }

  export type ServiceAdMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    jobTitle?: SortOrder
    jobType?: SortOrder
    industryCategory?: SortOrder
    region?: SortOrder
    postcode?: SortOrder
    salaryRate?: SortOrder
    salaryType?: SortOrder
    jobDescription?: SortOrder
    requiredExperience?: SortOrder
    requiredLicences?: SortOrder
    shiftAndHours?: SortOrder
    startDate?: SortOrder
    deadline?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceAdMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    jobTitle?: SortOrder
    jobType?: SortOrder
    industryCategory?: SortOrder
    region?: SortOrder
    postcode?: SortOrder
    salaryRate?: SortOrder
    salaryType?: SortOrder
    jobDescription?: SortOrder
    requiredExperience?: SortOrder
    requiredLicences?: SortOrder
    shiftAndHours?: SortOrder
    startDate?: SortOrder
    deadline?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceAdSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    salaryRate?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ClientScalarRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type ClientAdCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientAdAvgOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
  }

  export type ClientAdMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientAdMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientAdSumOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
  }

  export type RoleUserCountOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleUserAvgOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    userId?: SortOrder
  }

  export type RoleUserMaxOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleUserMinOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleUserSumOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    userId?: SortOrder
  }

  export type RolePermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type RolePermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutVerificationCodeInput = {
    create?: XOR<UserCreateWithoutVerificationCodeInput, UserUncheckedCreateWithoutVerificationCodeInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerificationCodeInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutVerificationCodeNestedInput = {
    create?: XOR<UserCreateWithoutVerificationCodeInput, UserUncheckedCreateWithoutVerificationCodeInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerificationCodeInput
    upsert?: UserUpsertWithoutVerificationCodeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVerificationCodeInput, UserUpdateWithoutVerificationCodeInput>, UserUncheckedUpdateWithoutVerificationCodeInput>
  }

  export type RolePermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RoleUserCreateNestedManyWithoutRoleInput = {
    create?: XOR<RoleUserCreateWithoutRoleInput, RoleUserUncheckedCreateWithoutRoleInput> | RoleUserCreateWithoutRoleInput[] | RoleUserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RoleUserCreateOrConnectWithoutRoleInput | RoleUserCreateOrConnectWithoutRoleInput[]
    createMany?: RoleUserCreateManyRoleInputEnvelope
    connect?: RoleUserWhereUniqueInput | RoleUserWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RoleUserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<RoleUserCreateWithoutRoleInput, RoleUserUncheckedCreateWithoutRoleInput> | RoleUserCreateWithoutRoleInput[] | RoleUserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RoleUserCreateOrConnectWithoutRoleInput | RoleUserCreateOrConnectWithoutRoleInput[]
    createMany?: RoleUserCreateManyRoleInputEnvelope
    connect?: RoleUserWhereUniqueInput | RoleUserWhereUniqueInput[]
  }

  export type RolePermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RoleUserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RoleUserCreateWithoutRoleInput, RoleUserUncheckedCreateWithoutRoleInput> | RoleUserCreateWithoutRoleInput[] | RoleUserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RoleUserCreateOrConnectWithoutRoleInput | RoleUserCreateOrConnectWithoutRoleInput[]
    upsert?: RoleUserUpsertWithWhereUniqueWithoutRoleInput | RoleUserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RoleUserCreateManyRoleInputEnvelope
    set?: RoleUserWhereUniqueInput | RoleUserWhereUniqueInput[]
    disconnect?: RoleUserWhereUniqueInput | RoleUserWhereUniqueInput[]
    delete?: RoleUserWhereUniqueInput | RoleUserWhereUniqueInput[]
    connect?: RoleUserWhereUniqueInput | RoleUserWhereUniqueInput[]
    update?: RoleUserUpdateWithWhereUniqueWithoutRoleInput | RoleUserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RoleUserUpdateManyWithWhereWithoutRoleInput | RoleUserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RoleUserScalarWhereInput | RoleUserScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RoleUserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RoleUserCreateWithoutRoleInput, RoleUserUncheckedCreateWithoutRoleInput> | RoleUserCreateWithoutRoleInput[] | RoleUserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RoleUserCreateOrConnectWithoutRoleInput | RoleUserCreateOrConnectWithoutRoleInput[]
    upsert?: RoleUserUpsertWithWhereUniqueWithoutRoleInput | RoleUserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RoleUserCreateManyRoleInputEnvelope
    set?: RoleUserWhereUniqueInput | RoleUserWhereUniqueInput[]
    disconnect?: RoleUserWhereUniqueInput | RoleUserWhereUniqueInput[]
    delete?: RoleUserWhereUniqueInput | RoleUserWhereUniqueInput[]
    connect?: RoleUserWhereUniqueInput | RoleUserWhereUniqueInput[]
    update?: RoleUserUpdateWithWhereUniqueWithoutRoleInput | RoleUserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RoleUserUpdateManyWithWhereWithoutRoleInput | RoleUserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RoleUserScalarWhereInput | RoleUserScalarWhereInput[]
  }

  export type RoleCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput
    connect?: RoleWhereUniqueInput
  }

  export type PermissionCreateNestedOneWithoutRolesInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput
    connect?: PermissionWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput
    upsert?: RoleUpsertWithoutPermissionsInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutPermissionsInput, RoleUpdateWithoutPermissionsInput>, RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type PermissionUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput
    upsert?: PermissionUpsertWithoutRolesInput
    connect?: PermissionWhereUniqueInput
    update?: XOR<XOR<PermissionUpdateToOneWithWhereWithoutRolesInput, PermissionUpdateWithoutRolesInput>, PermissionUncheckedUpdateWithoutRolesInput>
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type RoleUserCreateNestedManyWithoutUserInput = {
    create?: XOR<RoleUserCreateWithoutUserInput, RoleUserUncheckedCreateWithoutUserInput> | RoleUserCreateWithoutUserInput[] | RoleUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoleUserCreateOrConnectWithoutUserInput | RoleUserCreateOrConnectWithoutUserInput[]
    createMany?: RoleUserCreateManyUserInputEnvelope
    connect?: RoleUserWhereUniqueInput | RoleUserWhereUniqueInput[]
  }

  export type IndividualProfessionalCreateNestedOneWithoutUserInput = {
    create?: XOR<IndividualProfessionalCreateWithoutUserInput, IndividualProfessionalUncheckedCreateWithoutUserInput>
    connectOrCreate?: IndividualProfessionalCreateOrConnectWithoutUserInput
    connect?: IndividualProfessionalWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutUserInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput
    connect?: ClientWhereUniqueInput
  }

  export type SecurityCompanyCreateNestedOneWithoutUserInput = {
    create?: XOR<SecurityCompanyCreateWithoutUserInput, SecurityCompanyUncheckedCreateWithoutUserInput>
    connectOrCreate?: SecurityCompanyCreateOrConnectWithoutUserInput
    connect?: SecurityCompanyWhereUniqueInput
  }

  export type CourseProviderCreateNestedOneWithoutUserInput = {
    create?: XOR<CourseProviderCreateWithoutUserInput, CourseProviderUncheckedCreateWithoutUserInput>
    connectOrCreate?: CourseProviderCreateOrConnectWithoutUserInput
    connect?: CourseProviderWhereUniqueInput
  }

  export type CorporateClientCreateNestedOneWithoutUserInput = {
    create?: XOR<CorporateClientCreateWithoutUserInput, CorporateClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: CorporateClientCreateOrConnectWithoutUserInput
    connect?: CorporateClientWhereUniqueInput
  }

  export type VerificationCodeCreateNestedOneWithoutUserInput = {
    create?: XOR<VerificationCodeCreateWithoutUserInput, VerificationCodeUncheckedCreateWithoutUserInput>
    connectOrCreate?: VerificationCodeCreateOrConnectWithoutUserInput
    connect?: VerificationCodeWhereUniqueInput
  }

  export type RoleUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RoleUserCreateWithoutUserInput, RoleUserUncheckedCreateWithoutUserInput> | RoleUserCreateWithoutUserInput[] | RoleUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoleUserCreateOrConnectWithoutUserInput | RoleUserCreateOrConnectWithoutUserInput[]
    createMany?: RoleUserCreateManyUserInputEnvelope
    connect?: RoleUserWhereUniqueInput | RoleUserWhereUniqueInput[]
  }

  export type IndividualProfessionalUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<IndividualProfessionalCreateWithoutUserInput, IndividualProfessionalUncheckedCreateWithoutUserInput>
    connectOrCreate?: IndividualProfessionalCreateOrConnectWithoutUserInput
    connect?: IndividualProfessionalWhereUniqueInput
  }

  export type ClientUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput
    connect?: ClientWhereUniqueInput
  }

  export type SecurityCompanyUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<SecurityCompanyCreateWithoutUserInput, SecurityCompanyUncheckedCreateWithoutUserInput>
    connectOrCreate?: SecurityCompanyCreateOrConnectWithoutUserInput
    connect?: SecurityCompanyWhereUniqueInput
  }

  export type CourseProviderUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<CourseProviderCreateWithoutUserInput, CourseProviderUncheckedCreateWithoutUserInput>
    connectOrCreate?: CourseProviderCreateOrConnectWithoutUserInput
    connect?: CourseProviderWhereUniqueInput
  }

  export type CorporateClientUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<CorporateClientCreateWithoutUserInput, CorporateClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: CorporateClientCreateOrConnectWithoutUserInput
    connect?: CorporateClientWhereUniqueInput
  }

  export type VerificationCodeUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<VerificationCodeCreateWithoutUserInput, VerificationCodeUncheckedCreateWithoutUserInput>
    connectOrCreate?: VerificationCodeCreateOrConnectWithoutUserInput
    connect?: VerificationCodeWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<RoleUserCreateWithoutUserInput, RoleUserUncheckedCreateWithoutUserInput> | RoleUserCreateWithoutUserInput[] | RoleUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoleUserCreateOrConnectWithoutUserInput | RoleUserCreateOrConnectWithoutUserInput[]
    upsert?: RoleUserUpsertWithWhereUniqueWithoutUserInput | RoleUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RoleUserCreateManyUserInputEnvelope
    set?: RoleUserWhereUniqueInput | RoleUserWhereUniqueInput[]
    disconnect?: RoleUserWhereUniqueInput | RoleUserWhereUniqueInput[]
    delete?: RoleUserWhereUniqueInput | RoleUserWhereUniqueInput[]
    connect?: RoleUserWhereUniqueInput | RoleUserWhereUniqueInput[]
    update?: RoleUserUpdateWithWhereUniqueWithoutUserInput | RoleUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RoleUserUpdateManyWithWhereWithoutUserInput | RoleUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RoleUserScalarWhereInput | RoleUserScalarWhereInput[]
  }

  export type IndividualProfessionalUpdateOneWithoutUserNestedInput = {
    create?: XOR<IndividualProfessionalCreateWithoutUserInput, IndividualProfessionalUncheckedCreateWithoutUserInput>
    connectOrCreate?: IndividualProfessionalCreateOrConnectWithoutUserInput
    upsert?: IndividualProfessionalUpsertWithoutUserInput
    disconnect?: IndividualProfessionalWhereInput | boolean
    delete?: IndividualProfessionalWhereInput | boolean
    connect?: IndividualProfessionalWhereUniqueInput
    update?: XOR<XOR<IndividualProfessionalUpdateToOneWithWhereWithoutUserInput, IndividualProfessionalUpdateWithoutUserInput>, IndividualProfessionalUncheckedUpdateWithoutUserInput>
  }

  export type ClientUpdateOneWithoutUserNestedInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput
    upsert?: ClientUpsertWithoutUserInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutUserInput, ClientUpdateWithoutUserInput>, ClientUncheckedUpdateWithoutUserInput>
  }

  export type SecurityCompanyUpdateOneWithoutUserNestedInput = {
    create?: XOR<SecurityCompanyCreateWithoutUserInput, SecurityCompanyUncheckedCreateWithoutUserInput>
    connectOrCreate?: SecurityCompanyCreateOrConnectWithoutUserInput
    upsert?: SecurityCompanyUpsertWithoutUserInput
    disconnect?: SecurityCompanyWhereInput | boolean
    delete?: SecurityCompanyWhereInput | boolean
    connect?: SecurityCompanyWhereUniqueInput
    update?: XOR<XOR<SecurityCompanyUpdateToOneWithWhereWithoutUserInput, SecurityCompanyUpdateWithoutUserInput>, SecurityCompanyUncheckedUpdateWithoutUserInput>
  }

  export type CourseProviderUpdateOneWithoutUserNestedInput = {
    create?: XOR<CourseProviderCreateWithoutUserInput, CourseProviderUncheckedCreateWithoutUserInput>
    connectOrCreate?: CourseProviderCreateOrConnectWithoutUserInput
    upsert?: CourseProviderUpsertWithoutUserInput
    disconnect?: CourseProviderWhereInput | boolean
    delete?: CourseProviderWhereInput | boolean
    connect?: CourseProviderWhereUniqueInput
    update?: XOR<XOR<CourseProviderUpdateToOneWithWhereWithoutUserInput, CourseProviderUpdateWithoutUserInput>, CourseProviderUncheckedUpdateWithoutUserInput>
  }

  export type CorporateClientUpdateOneWithoutUserNestedInput = {
    create?: XOR<CorporateClientCreateWithoutUserInput, CorporateClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: CorporateClientCreateOrConnectWithoutUserInput
    upsert?: CorporateClientUpsertWithoutUserInput
    disconnect?: CorporateClientWhereInput | boolean
    delete?: CorporateClientWhereInput | boolean
    connect?: CorporateClientWhereUniqueInput
    update?: XOR<XOR<CorporateClientUpdateToOneWithWhereWithoutUserInput, CorporateClientUpdateWithoutUserInput>, CorporateClientUncheckedUpdateWithoutUserInput>
  }

  export type VerificationCodeUpdateOneWithoutUserNestedInput = {
    create?: XOR<VerificationCodeCreateWithoutUserInput, VerificationCodeUncheckedCreateWithoutUserInput>
    connectOrCreate?: VerificationCodeCreateOrConnectWithoutUserInput
    upsert?: VerificationCodeUpsertWithoutUserInput
    disconnect?: VerificationCodeWhereInput | boolean
    delete?: VerificationCodeWhereInput | boolean
    connect?: VerificationCodeWhereUniqueInput
    update?: XOR<XOR<VerificationCodeUpdateToOneWithWhereWithoutUserInput, VerificationCodeUpdateWithoutUserInput>, VerificationCodeUncheckedUpdateWithoutUserInput>
  }

  export type RoleUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RoleUserCreateWithoutUserInput, RoleUserUncheckedCreateWithoutUserInput> | RoleUserCreateWithoutUserInput[] | RoleUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoleUserCreateOrConnectWithoutUserInput | RoleUserCreateOrConnectWithoutUserInput[]
    upsert?: RoleUserUpsertWithWhereUniqueWithoutUserInput | RoleUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RoleUserCreateManyUserInputEnvelope
    set?: RoleUserWhereUniqueInput | RoleUserWhereUniqueInput[]
    disconnect?: RoleUserWhereUniqueInput | RoleUserWhereUniqueInput[]
    delete?: RoleUserWhereUniqueInput | RoleUserWhereUniqueInput[]
    connect?: RoleUserWhereUniqueInput | RoleUserWhereUniqueInput[]
    update?: RoleUserUpdateWithWhereUniqueWithoutUserInput | RoleUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RoleUserUpdateManyWithWhereWithoutUserInput | RoleUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RoleUserScalarWhereInput | RoleUserScalarWhereInput[]
  }

  export type IndividualProfessionalUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<IndividualProfessionalCreateWithoutUserInput, IndividualProfessionalUncheckedCreateWithoutUserInput>
    connectOrCreate?: IndividualProfessionalCreateOrConnectWithoutUserInput
    upsert?: IndividualProfessionalUpsertWithoutUserInput
    disconnect?: IndividualProfessionalWhereInput | boolean
    delete?: IndividualProfessionalWhereInput | boolean
    connect?: IndividualProfessionalWhereUniqueInput
    update?: XOR<XOR<IndividualProfessionalUpdateToOneWithWhereWithoutUserInput, IndividualProfessionalUpdateWithoutUserInput>, IndividualProfessionalUncheckedUpdateWithoutUserInput>
  }

  export type ClientUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput
    upsert?: ClientUpsertWithoutUserInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutUserInput, ClientUpdateWithoutUserInput>, ClientUncheckedUpdateWithoutUserInput>
  }

  export type SecurityCompanyUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<SecurityCompanyCreateWithoutUserInput, SecurityCompanyUncheckedCreateWithoutUserInput>
    connectOrCreate?: SecurityCompanyCreateOrConnectWithoutUserInput
    upsert?: SecurityCompanyUpsertWithoutUserInput
    disconnect?: SecurityCompanyWhereInput | boolean
    delete?: SecurityCompanyWhereInput | boolean
    connect?: SecurityCompanyWhereUniqueInput
    update?: XOR<XOR<SecurityCompanyUpdateToOneWithWhereWithoutUserInput, SecurityCompanyUpdateWithoutUserInput>, SecurityCompanyUncheckedUpdateWithoutUserInput>
  }

  export type CourseProviderUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<CourseProviderCreateWithoutUserInput, CourseProviderUncheckedCreateWithoutUserInput>
    connectOrCreate?: CourseProviderCreateOrConnectWithoutUserInput
    upsert?: CourseProviderUpsertWithoutUserInput
    disconnect?: CourseProviderWhereInput | boolean
    delete?: CourseProviderWhereInput | boolean
    connect?: CourseProviderWhereUniqueInput
    update?: XOR<XOR<CourseProviderUpdateToOneWithWhereWithoutUserInput, CourseProviderUpdateWithoutUserInput>, CourseProviderUncheckedUpdateWithoutUserInput>
  }

  export type CorporateClientUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<CorporateClientCreateWithoutUserInput, CorporateClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: CorporateClientCreateOrConnectWithoutUserInput
    upsert?: CorporateClientUpsertWithoutUserInput
    disconnect?: CorporateClientWhereInput | boolean
    delete?: CorporateClientWhereInput | boolean
    connect?: CorporateClientWhereUniqueInput
    update?: XOR<XOR<CorporateClientUpdateToOneWithWhereWithoutUserInput, CorporateClientUpdateWithoutUserInput>, CorporateClientUncheckedUpdateWithoutUserInput>
  }

  export type VerificationCodeUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<VerificationCodeCreateWithoutUserInput, VerificationCodeUncheckedCreateWithoutUserInput>
    connectOrCreate?: VerificationCodeCreateOrConnectWithoutUserInput
    upsert?: VerificationCodeUpsertWithoutUserInput
    disconnect?: VerificationCodeWhereInput | boolean
    delete?: VerificationCodeWhereInput | boolean
    connect?: VerificationCodeWhereUniqueInput
    update?: XOR<XOR<VerificationCodeUpdateToOneWithWhereWithoutUserInput, VerificationCodeUpdateWithoutUserInput>, VerificationCodeUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutIndividualProfessionalInput = {
    create?: XOR<UserCreateWithoutIndividualProfessionalInput, UserUncheckedCreateWithoutIndividualProfessionalInput>
    connectOrCreate?: UserCreateOrConnectWithoutIndividualProfessionalInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutIndividualProfessionalNestedInput = {
    create?: XOR<UserCreateWithoutIndividualProfessionalInput, UserUncheckedCreateWithoutIndividualProfessionalInput>
    connectOrCreate?: UserCreateOrConnectWithoutIndividualProfessionalInput
    upsert?: UserUpsertWithoutIndividualProfessionalInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIndividualProfessionalInput, UserUpdateWithoutIndividualProfessionalInput>, UserUncheckedUpdateWithoutIndividualProfessionalInput>
  }

  export type UserCreateNestedOneWithoutClientInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientInput
    connect?: UserWhereUniqueInput
  }

  export type ClientAdCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientAdCreateWithoutClientInput, ClientAdUncheckedCreateWithoutClientInput> | ClientAdCreateWithoutClientInput[] | ClientAdUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientAdCreateOrConnectWithoutClientInput | ClientAdCreateOrConnectWithoutClientInput[]
    createMany?: ClientAdCreateManyClientInputEnvelope
    connect?: ClientAdWhereUniqueInput | ClientAdWhereUniqueInput[]
  }

  export type ClientAdUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientAdCreateWithoutClientInput, ClientAdUncheckedCreateWithoutClientInput> | ClientAdCreateWithoutClientInput[] | ClientAdUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientAdCreateOrConnectWithoutClientInput | ClientAdCreateOrConnectWithoutClientInput[]
    createMany?: ClientAdCreateManyClientInputEnvelope
    connect?: ClientAdWhereUniqueInput | ClientAdWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutClientNestedInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientInput
    upsert?: UserUpsertWithoutClientInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClientInput, UserUpdateWithoutClientInput>, UserUncheckedUpdateWithoutClientInput>
  }

  export type ClientAdUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientAdCreateWithoutClientInput, ClientAdUncheckedCreateWithoutClientInput> | ClientAdCreateWithoutClientInput[] | ClientAdUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientAdCreateOrConnectWithoutClientInput | ClientAdCreateOrConnectWithoutClientInput[]
    upsert?: ClientAdUpsertWithWhereUniqueWithoutClientInput | ClientAdUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientAdCreateManyClientInputEnvelope
    set?: ClientAdWhereUniqueInput | ClientAdWhereUniqueInput[]
    disconnect?: ClientAdWhereUniqueInput | ClientAdWhereUniqueInput[]
    delete?: ClientAdWhereUniqueInput | ClientAdWhereUniqueInput[]
    connect?: ClientAdWhereUniqueInput | ClientAdWhereUniqueInput[]
    update?: ClientAdUpdateWithWhereUniqueWithoutClientInput | ClientAdUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientAdUpdateManyWithWhereWithoutClientInput | ClientAdUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientAdScalarWhereInput | ClientAdScalarWhereInput[]
  }

  export type ClientAdUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientAdCreateWithoutClientInput, ClientAdUncheckedCreateWithoutClientInput> | ClientAdCreateWithoutClientInput[] | ClientAdUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientAdCreateOrConnectWithoutClientInput | ClientAdCreateOrConnectWithoutClientInput[]
    upsert?: ClientAdUpsertWithWhereUniqueWithoutClientInput | ClientAdUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientAdCreateManyClientInputEnvelope
    set?: ClientAdWhereUniqueInput | ClientAdWhereUniqueInput[]
    disconnect?: ClientAdWhereUniqueInput | ClientAdWhereUniqueInput[]
    delete?: ClientAdWhereUniqueInput | ClientAdWhereUniqueInput[]
    connect?: ClientAdWhereUniqueInput | ClientAdWhereUniqueInput[]
    update?: ClientAdUpdateWithWhereUniqueWithoutClientInput | ClientAdUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientAdUpdateManyWithWhereWithoutClientInput | ClientAdUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientAdScalarWhereInput | ClientAdScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSecurityCompanyInput = {
    create?: XOR<UserCreateWithoutSecurityCompanyInput, UserUncheckedCreateWithoutSecurityCompanyInput>
    connectOrCreate?: UserCreateOrConnectWithoutSecurityCompanyInput
    connect?: UserWhereUniqueInput
  }

  export type ServiceAdCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ServiceAdCreateWithoutCompanyInput, ServiceAdUncheckedCreateWithoutCompanyInput> | ServiceAdCreateWithoutCompanyInput[] | ServiceAdUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ServiceAdCreateOrConnectWithoutCompanyInput | ServiceAdCreateOrConnectWithoutCompanyInput[]
    createMany?: ServiceAdCreateManyCompanyInputEnvelope
    connect?: ServiceAdWhereUniqueInput | ServiceAdWhereUniqueInput[]
  }

  export type ServiceAdUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ServiceAdCreateWithoutCompanyInput, ServiceAdUncheckedCreateWithoutCompanyInput> | ServiceAdCreateWithoutCompanyInput[] | ServiceAdUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ServiceAdCreateOrConnectWithoutCompanyInput | ServiceAdCreateOrConnectWithoutCompanyInput[]
    createMany?: ServiceAdCreateManyCompanyInputEnvelope
    connect?: ServiceAdWhereUniqueInput | ServiceAdWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutSecurityCompanyNestedInput = {
    create?: XOR<UserCreateWithoutSecurityCompanyInput, UserUncheckedCreateWithoutSecurityCompanyInput>
    connectOrCreate?: UserCreateOrConnectWithoutSecurityCompanyInput
    upsert?: UserUpsertWithoutSecurityCompanyInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSecurityCompanyInput, UserUpdateWithoutSecurityCompanyInput>, UserUncheckedUpdateWithoutSecurityCompanyInput>
  }

  export type ServiceAdUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ServiceAdCreateWithoutCompanyInput, ServiceAdUncheckedCreateWithoutCompanyInput> | ServiceAdCreateWithoutCompanyInput[] | ServiceAdUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ServiceAdCreateOrConnectWithoutCompanyInput | ServiceAdCreateOrConnectWithoutCompanyInput[]
    upsert?: ServiceAdUpsertWithWhereUniqueWithoutCompanyInput | ServiceAdUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ServiceAdCreateManyCompanyInputEnvelope
    set?: ServiceAdWhereUniqueInput | ServiceAdWhereUniqueInput[]
    disconnect?: ServiceAdWhereUniqueInput | ServiceAdWhereUniqueInput[]
    delete?: ServiceAdWhereUniqueInput | ServiceAdWhereUniqueInput[]
    connect?: ServiceAdWhereUniqueInput | ServiceAdWhereUniqueInput[]
    update?: ServiceAdUpdateWithWhereUniqueWithoutCompanyInput | ServiceAdUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ServiceAdUpdateManyWithWhereWithoutCompanyInput | ServiceAdUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ServiceAdScalarWhereInput | ServiceAdScalarWhereInput[]
  }

  export type ServiceAdUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ServiceAdCreateWithoutCompanyInput, ServiceAdUncheckedCreateWithoutCompanyInput> | ServiceAdCreateWithoutCompanyInput[] | ServiceAdUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ServiceAdCreateOrConnectWithoutCompanyInput | ServiceAdCreateOrConnectWithoutCompanyInput[]
    upsert?: ServiceAdUpsertWithWhereUniqueWithoutCompanyInput | ServiceAdUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ServiceAdCreateManyCompanyInputEnvelope
    set?: ServiceAdWhereUniqueInput | ServiceAdWhereUniqueInput[]
    disconnect?: ServiceAdWhereUniqueInput | ServiceAdWhereUniqueInput[]
    delete?: ServiceAdWhereUniqueInput | ServiceAdWhereUniqueInput[]
    connect?: ServiceAdWhereUniqueInput | ServiceAdWhereUniqueInput[]
    update?: ServiceAdUpdateWithWhereUniqueWithoutCompanyInput | ServiceAdUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ServiceAdUpdateManyWithWhereWithoutCompanyInput | ServiceAdUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ServiceAdScalarWhereInput | ServiceAdScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCourseProviderInput = {
    create?: XOR<UserCreateWithoutCourseProviderInput, UserUncheckedCreateWithoutCourseProviderInput>
    connectOrCreate?: UserCreateOrConnectWithoutCourseProviderInput
    connect?: UserWhereUniqueInput
  }

  export type CourseAdCreateNestedManyWithoutCourseProviderInput = {
    create?: XOR<CourseAdCreateWithoutCourseProviderInput, CourseAdUncheckedCreateWithoutCourseProviderInput> | CourseAdCreateWithoutCourseProviderInput[] | CourseAdUncheckedCreateWithoutCourseProviderInput[]
    connectOrCreate?: CourseAdCreateOrConnectWithoutCourseProviderInput | CourseAdCreateOrConnectWithoutCourseProviderInput[]
    createMany?: CourseAdCreateManyCourseProviderInputEnvelope
    connect?: CourseAdWhereUniqueInput | CourseAdWhereUniqueInput[]
  }

  export type CourseAdUncheckedCreateNestedManyWithoutCourseProviderInput = {
    create?: XOR<CourseAdCreateWithoutCourseProviderInput, CourseAdUncheckedCreateWithoutCourseProviderInput> | CourseAdCreateWithoutCourseProviderInput[] | CourseAdUncheckedCreateWithoutCourseProviderInput[]
    connectOrCreate?: CourseAdCreateOrConnectWithoutCourseProviderInput | CourseAdCreateOrConnectWithoutCourseProviderInput[]
    createMany?: CourseAdCreateManyCourseProviderInputEnvelope
    connect?: CourseAdWhereUniqueInput | CourseAdWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCourseProviderNestedInput = {
    create?: XOR<UserCreateWithoutCourseProviderInput, UserUncheckedCreateWithoutCourseProviderInput>
    connectOrCreate?: UserCreateOrConnectWithoutCourseProviderInput
    upsert?: UserUpsertWithoutCourseProviderInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCourseProviderInput, UserUpdateWithoutCourseProviderInput>, UserUncheckedUpdateWithoutCourseProviderInput>
  }

  export type CourseAdUpdateManyWithoutCourseProviderNestedInput = {
    create?: XOR<CourseAdCreateWithoutCourseProviderInput, CourseAdUncheckedCreateWithoutCourseProviderInput> | CourseAdCreateWithoutCourseProviderInput[] | CourseAdUncheckedCreateWithoutCourseProviderInput[]
    connectOrCreate?: CourseAdCreateOrConnectWithoutCourseProviderInput | CourseAdCreateOrConnectWithoutCourseProviderInput[]
    upsert?: CourseAdUpsertWithWhereUniqueWithoutCourseProviderInput | CourseAdUpsertWithWhereUniqueWithoutCourseProviderInput[]
    createMany?: CourseAdCreateManyCourseProviderInputEnvelope
    set?: CourseAdWhereUniqueInput | CourseAdWhereUniqueInput[]
    disconnect?: CourseAdWhereUniqueInput | CourseAdWhereUniqueInput[]
    delete?: CourseAdWhereUniqueInput | CourseAdWhereUniqueInput[]
    connect?: CourseAdWhereUniqueInput | CourseAdWhereUniqueInput[]
    update?: CourseAdUpdateWithWhereUniqueWithoutCourseProviderInput | CourseAdUpdateWithWhereUniqueWithoutCourseProviderInput[]
    updateMany?: CourseAdUpdateManyWithWhereWithoutCourseProviderInput | CourseAdUpdateManyWithWhereWithoutCourseProviderInput[]
    deleteMany?: CourseAdScalarWhereInput | CourseAdScalarWhereInput[]
  }

  export type CourseAdUncheckedUpdateManyWithoutCourseProviderNestedInput = {
    create?: XOR<CourseAdCreateWithoutCourseProviderInput, CourseAdUncheckedCreateWithoutCourseProviderInput> | CourseAdCreateWithoutCourseProviderInput[] | CourseAdUncheckedCreateWithoutCourseProviderInput[]
    connectOrCreate?: CourseAdCreateOrConnectWithoutCourseProviderInput | CourseAdCreateOrConnectWithoutCourseProviderInput[]
    upsert?: CourseAdUpsertWithWhereUniqueWithoutCourseProviderInput | CourseAdUpsertWithWhereUniqueWithoutCourseProviderInput[]
    createMany?: CourseAdCreateManyCourseProviderInputEnvelope
    set?: CourseAdWhereUniqueInput | CourseAdWhereUniqueInput[]
    disconnect?: CourseAdWhereUniqueInput | CourseAdWhereUniqueInput[]
    delete?: CourseAdWhereUniqueInput | CourseAdWhereUniqueInput[]
    connect?: CourseAdWhereUniqueInput | CourseAdWhereUniqueInput[]
    update?: CourseAdUpdateWithWhereUniqueWithoutCourseProviderInput | CourseAdUpdateWithWhereUniqueWithoutCourseProviderInput[]
    updateMany?: CourseAdUpdateManyWithWhereWithoutCourseProviderInput | CourseAdUpdateManyWithWhereWithoutCourseProviderInput[]
    deleteMany?: CourseAdScalarWhereInput | CourseAdScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCorporateClientInput = {
    create?: XOR<UserCreateWithoutCorporateClientInput, UserUncheckedCreateWithoutCorporateClientInput>
    connectOrCreate?: UserCreateOrConnectWithoutCorporateClientInput
    connect?: UserWhereUniqueInput
  }

  export type CorporateAdCreateNestedManyWithoutCorporateClientInput = {
    create?: XOR<CorporateAdCreateWithoutCorporateClientInput, CorporateAdUncheckedCreateWithoutCorporateClientInput> | CorporateAdCreateWithoutCorporateClientInput[] | CorporateAdUncheckedCreateWithoutCorporateClientInput[]
    connectOrCreate?: CorporateAdCreateOrConnectWithoutCorporateClientInput | CorporateAdCreateOrConnectWithoutCorporateClientInput[]
    createMany?: CorporateAdCreateManyCorporateClientInputEnvelope
    connect?: CorporateAdWhereUniqueInput | CorporateAdWhereUniqueInput[]
  }

  export type CorporateAdUncheckedCreateNestedManyWithoutCorporateClientInput = {
    create?: XOR<CorporateAdCreateWithoutCorporateClientInput, CorporateAdUncheckedCreateWithoutCorporateClientInput> | CorporateAdCreateWithoutCorporateClientInput[] | CorporateAdUncheckedCreateWithoutCorporateClientInput[]
    connectOrCreate?: CorporateAdCreateOrConnectWithoutCorporateClientInput | CorporateAdCreateOrConnectWithoutCorporateClientInput[]
    createMany?: CorporateAdCreateManyCorporateClientInputEnvelope
    connect?: CorporateAdWhereUniqueInput | CorporateAdWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCorporateClientNestedInput = {
    create?: XOR<UserCreateWithoutCorporateClientInput, UserUncheckedCreateWithoutCorporateClientInput>
    connectOrCreate?: UserCreateOrConnectWithoutCorporateClientInput
    upsert?: UserUpsertWithoutCorporateClientInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCorporateClientInput, UserUpdateWithoutCorporateClientInput>, UserUncheckedUpdateWithoutCorporateClientInput>
  }

  export type CorporateAdUpdateManyWithoutCorporateClientNestedInput = {
    create?: XOR<CorporateAdCreateWithoutCorporateClientInput, CorporateAdUncheckedCreateWithoutCorporateClientInput> | CorporateAdCreateWithoutCorporateClientInput[] | CorporateAdUncheckedCreateWithoutCorporateClientInput[]
    connectOrCreate?: CorporateAdCreateOrConnectWithoutCorporateClientInput | CorporateAdCreateOrConnectWithoutCorporateClientInput[]
    upsert?: CorporateAdUpsertWithWhereUniqueWithoutCorporateClientInput | CorporateAdUpsertWithWhereUniqueWithoutCorporateClientInput[]
    createMany?: CorporateAdCreateManyCorporateClientInputEnvelope
    set?: CorporateAdWhereUniqueInput | CorporateAdWhereUniqueInput[]
    disconnect?: CorporateAdWhereUniqueInput | CorporateAdWhereUniqueInput[]
    delete?: CorporateAdWhereUniqueInput | CorporateAdWhereUniqueInput[]
    connect?: CorporateAdWhereUniqueInput | CorporateAdWhereUniqueInput[]
    update?: CorporateAdUpdateWithWhereUniqueWithoutCorporateClientInput | CorporateAdUpdateWithWhereUniqueWithoutCorporateClientInput[]
    updateMany?: CorporateAdUpdateManyWithWhereWithoutCorporateClientInput | CorporateAdUpdateManyWithWhereWithoutCorporateClientInput[]
    deleteMany?: CorporateAdScalarWhereInput | CorporateAdScalarWhereInput[]
  }

  export type CorporateAdUncheckedUpdateManyWithoutCorporateClientNestedInput = {
    create?: XOR<CorporateAdCreateWithoutCorporateClientInput, CorporateAdUncheckedCreateWithoutCorporateClientInput> | CorporateAdCreateWithoutCorporateClientInput[] | CorporateAdUncheckedCreateWithoutCorporateClientInput[]
    connectOrCreate?: CorporateAdCreateOrConnectWithoutCorporateClientInput | CorporateAdCreateOrConnectWithoutCorporateClientInput[]
    upsert?: CorporateAdUpsertWithWhereUniqueWithoutCorporateClientInput | CorporateAdUpsertWithWhereUniqueWithoutCorporateClientInput[]
    createMany?: CorporateAdCreateManyCorporateClientInputEnvelope
    set?: CorporateAdWhereUniqueInput | CorporateAdWhereUniqueInput[]
    disconnect?: CorporateAdWhereUniqueInput | CorporateAdWhereUniqueInput[]
    delete?: CorporateAdWhereUniqueInput | CorporateAdWhereUniqueInput[]
    connect?: CorporateAdWhereUniqueInput | CorporateAdWhereUniqueInput[]
    update?: CorporateAdUpdateWithWhereUniqueWithoutCorporateClientInput | CorporateAdUpdateWithWhereUniqueWithoutCorporateClientInput[]
    updateMany?: CorporateAdUpdateManyWithWhereWithoutCorporateClientInput | CorporateAdUpdateManyWithWhereWithoutCorporateClientInput[]
    deleteMany?: CorporateAdScalarWhereInput | CorporateAdScalarWhereInput[]
  }

  export type CorporateClientCreateNestedOneWithoutCorporateAdsInput = {
    create?: XOR<CorporateClientCreateWithoutCorporateAdsInput, CorporateClientUncheckedCreateWithoutCorporateAdsInput>
    connectOrCreate?: CorporateClientCreateOrConnectWithoutCorporateAdsInput
    connect?: CorporateClientWhereUniqueInput
  }

  export type CorporateClientUpdateOneRequiredWithoutCorporateAdsNestedInput = {
    create?: XOR<CorporateClientCreateWithoutCorporateAdsInput, CorporateClientUncheckedCreateWithoutCorporateAdsInput>
    connectOrCreate?: CorporateClientCreateOrConnectWithoutCorporateAdsInput
    upsert?: CorporateClientUpsertWithoutCorporateAdsInput
    connect?: CorporateClientWhereUniqueInput
    update?: XOR<XOR<CorporateClientUpdateToOneWithWhereWithoutCorporateAdsInput, CorporateClientUpdateWithoutCorporateAdsInput>, CorporateClientUncheckedUpdateWithoutCorporateAdsInput>
  }

  export type CourseProviderCreateNestedOneWithoutCourseAdsInput = {
    create?: XOR<CourseProviderCreateWithoutCourseAdsInput, CourseProviderUncheckedCreateWithoutCourseAdsInput>
    connectOrCreate?: CourseProviderCreateOrConnectWithoutCourseAdsInput
    connect?: CourseProviderWhereUniqueInput
  }

  export type CourseProviderUpdateOneRequiredWithoutCourseAdsNestedInput = {
    create?: XOR<CourseProviderCreateWithoutCourseAdsInput, CourseProviderUncheckedCreateWithoutCourseAdsInput>
    connectOrCreate?: CourseProviderCreateOrConnectWithoutCourseAdsInput
    upsert?: CourseProviderUpsertWithoutCourseAdsInput
    connect?: CourseProviderWhereUniqueInput
    update?: XOR<XOR<CourseProviderUpdateToOneWithWhereWithoutCourseAdsInput, CourseProviderUpdateWithoutCourseAdsInput>, CourseProviderUncheckedUpdateWithoutCourseAdsInput>
  }

  export type SecurityCompanyCreateNestedOneWithoutServiceAdsInput = {
    create?: XOR<SecurityCompanyCreateWithoutServiceAdsInput, SecurityCompanyUncheckedCreateWithoutServiceAdsInput>
    connectOrCreate?: SecurityCompanyCreateOrConnectWithoutServiceAdsInput
    connect?: SecurityCompanyWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type SecurityCompanyUpdateOneRequiredWithoutServiceAdsNestedInput = {
    create?: XOR<SecurityCompanyCreateWithoutServiceAdsInput, SecurityCompanyUncheckedCreateWithoutServiceAdsInput>
    connectOrCreate?: SecurityCompanyCreateOrConnectWithoutServiceAdsInput
    upsert?: SecurityCompanyUpsertWithoutServiceAdsInput
    connect?: SecurityCompanyWhereUniqueInput
    update?: XOR<XOR<SecurityCompanyUpdateToOneWithWhereWithoutServiceAdsInput, SecurityCompanyUpdateWithoutServiceAdsInput>, SecurityCompanyUncheckedUpdateWithoutServiceAdsInput>
  }

  export type ClientCreateNestedOneWithoutAdsInput = {
    create?: XOR<ClientCreateWithoutAdsInput, ClientUncheckedCreateWithoutAdsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutAdsInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientUpdateOneRequiredWithoutAdsNestedInput = {
    create?: XOR<ClientCreateWithoutAdsInput, ClientUncheckedCreateWithoutAdsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutAdsInput
    upsert?: ClientUpsertWithoutAdsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutAdsInput, ClientUpdateWithoutAdsInput>, ClientUncheckedUpdateWithoutAdsInput>
  }

  export type RoleCreateNestedOneWithoutRoleUsersInput = {
    create?: XOR<RoleCreateWithoutRoleUsersInput, RoleUncheckedCreateWithoutRoleUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutRoleUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRoleUsersInput = {
    create?: XOR<UserCreateWithoutRoleUsersInput, UserUncheckedCreateWithoutRoleUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoleUsersInput
    connect?: UserWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutRoleUsersNestedInput = {
    create?: XOR<RoleCreateWithoutRoleUsersInput, RoleUncheckedCreateWithoutRoleUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutRoleUsersInput
    upsert?: RoleUpsertWithoutRoleUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutRoleUsersInput, RoleUpdateWithoutRoleUsersInput>, RoleUncheckedUpdateWithoutRoleUsersInput>
  }

  export type UserUpdateOneRequiredWithoutRoleUsersNestedInput = {
    create?: XOR<UserCreateWithoutRoleUsersInput, UserUncheckedCreateWithoutRoleUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoleUsersInput
    upsert?: UserUpsertWithoutRoleUsersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRoleUsersInput, UserUpdateWithoutRoleUsersInput>, UserUncheckedUpdateWithoutRoleUsersInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type RolePermissionCreateWithoutPermissionInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutPermissionsInput
  }

  export type RolePermissionUncheckedCreateWithoutPermissionInput = {
    id?: number
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolePermissionCreateOrConnectWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionCreateManyPermissionInputEnvelope = {
    data: RolePermissionCreateManyPermissionInput | RolePermissionCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type RolePermissionScalarWhereInput = {
    AND?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    OR?: RolePermissionScalarWhereInput[]
    NOT?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    id?: IntFilter<"RolePermission"> | number
    roleId?: IntFilter<"RolePermission"> | number
    permissionId?: IntFilter<"RolePermission"> | number
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    updatedAt?: DateTimeFilter<"RolePermission"> | Date | string
  }

  export type UserCreateWithoutVerificationCodeInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    screenName?: string | null
    phoneNumber: string
    dateOfBirth?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    roleUsers?: RoleUserCreateNestedManyWithoutUserInput
    individualProfessional?: IndividualProfessionalCreateNestedOneWithoutUserInput
    client?: ClientCreateNestedOneWithoutUserInput
    securityCompany?: SecurityCompanyCreateNestedOneWithoutUserInput
    courseProvider?: CourseProviderCreateNestedOneWithoutUserInput
    corporateClient?: CorporateClientCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVerificationCodeInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    screenName?: string | null
    phoneNumber: string
    dateOfBirth?: string | null
    address?: string | null
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    roleUsers?: RoleUserUncheckedCreateNestedManyWithoutUserInput
    individualProfessional?: IndividualProfessionalUncheckedCreateNestedOneWithoutUserInput
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    securityCompany?: SecurityCompanyUncheckedCreateNestedOneWithoutUserInput
    courseProvider?: CourseProviderUncheckedCreateNestedOneWithoutUserInput
    corporateClient?: CorporateClientUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVerificationCodeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVerificationCodeInput, UserUncheckedCreateWithoutVerificationCodeInput>
  }

  export type UserUpsertWithoutVerificationCodeInput = {
    update: XOR<UserUpdateWithoutVerificationCodeInput, UserUncheckedUpdateWithoutVerificationCodeInput>
    create: XOR<UserCreateWithoutVerificationCodeInput, UserUncheckedCreateWithoutVerificationCodeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVerificationCodeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVerificationCodeInput, UserUncheckedUpdateWithoutVerificationCodeInput>
  }

  export type UserUpdateWithoutVerificationCodeInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    roleUsers?: RoleUserUpdateManyWithoutUserNestedInput
    individualProfessional?: IndividualProfessionalUpdateOneWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUserNestedInput
    securityCompany?: SecurityCompanyUpdateOneWithoutUserNestedInput
    courseProvider?: CourseProviderUpdateOneWithoutUserNestedInput
    corporateClient?: CorporateClientUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVerificationCodeInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleUsers?: RoleUserUncheckedUpdateManyWithoutUserNestedInput
    individualProfessional?: IndividualProfessionalUncheckedUpdateOneWithoutUserNestedInput
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    securityCompany?: SecurityCompanyUncheckedUpdateOneWithoutUserNestedInput
    courseProvider?: CourseProviderUncheckedUpdateOneWithoutUserNestedInput
    corporateClient?: CorporateClientUncheckedUpdateOneWithoutUserNestedInput
  }

  export type RolePermissionCreateWithoutRoleInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    permission: PermissionCreateNestedOneWithoutRolesInput
  }

  export type RolePermissionUncheckedCreateWithoutRoleInput = {
    id?: number
    permissionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolePermissionCreateOrConnectWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionCreateManyRoleInputEnvelope = {
    data: RolePermissionCreateManyRoleInput | RolePermissionCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutRoleInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    screenName?: string | null
    phoneNumber: string
    dateOfBirth?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleUsers?: RoleUserCreateNestedManyWithoutUserInput
    individualProfessional?: IndividualProfessionalCreateNestedOneWithoutUserInput
    client?: ClientCreateNestedOneWithoutUserInput
    securityCompany?: SecurityCompanyCreateNestedOneWithoutUserInput
    courseProvider?: CourseProviderCreateNestedOneWithoutUserInput
    corporateClient?: CorporateClientCreateNestedOneWithoutUserInput
    VerificationCode?: VerificationCodeCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRoleInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    screenName?: string | null
    phoneNumber: string
    dateOfBirth?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleUsers?: RoleUserUncheckedCreateNestedManyWithoutUserInput
    individualProfessional?: IndividualProfessionalUncheckedCreateNestedOneWithoutUserInput
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    securityCompany?: SecurityCompanyUncheckedCreateNestedOneWithoutUserInput
    courseProvider?: CourseProviderUncheckedCreateNestedOneWithoutUserInput
    corporateClient?: CorporateClientUncheckedCreateNestedOneWithoutUserInput
    VerificationCode?: VerificationCodeUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateManyRoleInputEnvelope = {
    data: UserCreateManyRoleInput | UserCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type RoleUserCreateWithoutRoleInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRoleUsersInput
  }

  export type RoleUserUncheckedCreateWithoutRoleInput = {
    id?: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUserCreateOrConnectWithoutRoleInput = {
    where: RoleUserWhereUniqueInput
    create: XOR<RoleUserCreateWithoutRoleInput, RoleUserUncheckedCreateWithoutRoleInput>
  }

  export type RoleUserCreateManyRoleInputEnvelope = {
    data: RoleUserCreateManyRoleInput | RoleUserCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutRoleInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    screenName?: StringNullableFilter<"User"> | string | null
    phoneNumber?: StringFilter<"User"> | string
    dateOfBirth?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    roleId?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type RoleUserUpsertWithWhereUniqueWithoutRoleInput = {
    where: RoleUserWhereUniqueInput
    update: XOR<RoleUserUpdateWithoutRoleInput, RoleUserUncheckedUpdateWithoutRoleInput>
    create: XOR<RoleUserCreateWithoutRoleInput, RoleUserUncheckedCreateWithoutRoleInput>
  }

  export type RoleUserUpdateWithWhereUniqueWithoutRoleInput = {
    where: RoleUserWhereUniqueInput
    data: XOR<RoleUserUpdateWithoutRoleInput, RoleUserUncheckedUpdateWithoutRoleInput>
  }

  export type RoleUserUpdateManyWithWhereWithoutRoleInput = {
    where: RoleUserScalarWhereInput
    data: XOR<RoleUserUpdateManyMutationInput, RoleUserUncheckedUpdateManyWithoutRoleInput>
  }

  export type RoleUserScalarWhereInput = {
    AND?: RoleUserScalarWhereInput | RoleUserScalarWhereInput[]
    OR?: RoleUserScalarWhereInput[]
    NOT?: RoleUserScalarWhereInput | RoleUserScalarWhereInput[]
    id?: IntFilter<"RoleUser"> | number
    roleId?: IntFilter<"RoleUser"> | number
    userId?: IntFilter<"RoleUser"> | number
    createdAt?: DateTimeFilter<"RoleUser"> | Date | string
    updatedAt?: DateTimeFilter<"RoleUser"> | Date | string
  }

  export type RoleCreateWithoutPermissionsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutRoleInput
    roleUsers?: RoleUserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutPermissionsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
    roleUsers?: RoleUserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutPermissionsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
  }

  export type PermissionCreateWithoutRolesInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionUncheckedCreateWithoutRolesInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionCreateOrConnectWithoutRolesInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
  }

  export type RoleUpsertWithoutPermissionsInput = {
    update: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type RoleUpdateWithoutPermissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutRoleNestedInput
    roleUsers?: RoleUserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutPermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
    roleUsers?: RoleUserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type PermissionUpsertWithoutRolesInput = {
    update: XOR<PermissionUpdateWithoutRolesInput, PermissionUncheckedUpdateWithoutRolesInput>
    create: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    where?: PermissionWhereInput
  }

  export type PermissionUpdateToOneWithWhereWithoutRolesInput = {
    where?: PermissionWhereInput
    data: XOR<PermissionUpdateWithoutRolesInput, PermissionUncheckedUpdateWithoutRolesInput>
  }

  export type PermissionUpdateWithoutRolesInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateWithoutUsersInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionCreateNestedManyWithoutRoleInput
    roleUsers?: RoleUserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
    roleUsers?: RoleUserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type RoleUserCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutRoleUsersInput
  }

  export type RoleUserUncheckedCreateWithoutUserInput = {
    id?: number
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUserCreateOrConnectWithoutUserInput = {
    where: RoleUserWhereUniqueInput
    create: XOR<RoleUserCreateWithoutUserInput, RoleUserUncheckedCreateWithoutUserInput>
  }

  export type RoleUserCreateManyUserInputEnvelope = {
    data: RoleUserCreateManyUserInput | RoleUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type IndividualProfessionalCreateWithoutUserInput = {
    profileData: JsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndividualProfessionalUncheckedCreateWithoutUserInput = {
    id?: number
    profileData: JsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndividualProfessionalCreateOrConnectWithoutUserInput = {
    where: IndividualProfessionalWhereUniqueInput
    create: XOR<IndividualProfessionalCreateWithoutUserInput, IndividualProfessionalUncheckedCreateWithoutUserInput>
  }

  export type ClientCreateWithoutUserInput = {
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ads?: ClientAdCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutUserInput = {
    id?: number
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ads?: ClientAdUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutUserInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
  }

  export type SecurityCompanyCreateWithoutUserInput = {
    companyName: string
    registrationNumber: string
    address: string
    postCode: string
    contactPerson: string
    jobTitle: string
    phoneNumber: string
    website?: string | null
    servicesRequirements?: NullableJsonNullValueInput | InputJsonValue
    securityServicesOfferings?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceAds?: ServiceAdCreateNestedManyWithoutCompanyInput
  }

  export type SecurityCompanyUncheckedCreateWithoutUserInput = {
    id?: number
    companyName: string
    registrationNumber: string
    address: string
    postCode: string
    contactPerson: string
    jobTitle: string
    phoneNumber: string
    website?: string | null
    servicesRequirements?: NullableJsonNullValueInput | InputJsonValue
    securityServicesOfferings?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceAds?: ServiceAdUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type SecurityCompanyCreateOrConnectWithoutUserInput = {
    where: SecurityCompanyWhereUniqueInput
    create: XOR<SecurityCompanyCreateWithoutUserInput, SecurityCompanyUncheckedCreateWithoutUserInput>
  }

  export type CourseProviderCreateWithoutUserInput = {
    companyName: string
    registrationNumber: string
    address: string
    postCode: string
    contactPerson: string
    jobTitle: string
    phoneNumber: string
    website?: string | null
    servicesRequirements?: NullableJsonNullValueInput | InputJsonValue
    securityServicesOfferings?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    courseAds?: CourseAdCreateNestedManyWithoutCourseProviderInput
  }

  export type CourseProviderUncheckedCreateWithoutUserInput = {
    id?: number
    companyName: string
    registrationNumber: string
    address: string
    postCode: string
    contactPerson: string
    jobTitle: string
    phoneNumber: string
    website?: string | null
    servicesRequirements?: NullableJsonNullValueInput | InputJsonValue
    securityServicesOfferings?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    courseAds?: CourseAdUncheckedCreateNestedManyWithoutCourseProviderInput
  }

  export type CourseProviderCreateOrConnectWithoutUserInput = {
    where: CourseProviderWhereUniqueInput
    create: XOR<CourseProviderCreateWithoutUserInput, CourseProviderUncheckedCreateWithoutUserInput>
  }

  export type CorporateClientCreateWithoutUserInput = {
    companyName: string
    registrationNumber: string
    address: string
    postCode: string
    industryType: string
    contactPerson: string
    jobTitle: string
    phoneNumber: string
    website?: string | null
    serviceRequirements?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    corporateAds?: CorporateAdCreateNestedManyWithoutCorporateClientInput
  }

  export type CorporateClientUncheckedCreateWithoutUserInput = {
    id?: number
    companyName: string
    registrationNumber: string
    address: string
    postCode: string
    industryType: string
    contactPerson: string
    jobTitle: string
    phoneNumber: string
    website?: string | null
    serviceRequirements?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    corporateAds?: CorporateAdUncheckedCreateNestedManyWithoutCorporateClientInput
  }

  export type CorporateClientCreateOrConnectWithoutUserInput = {
    where: CorporateClientWhereUniqueInput
    create: XOR<CorporateClientCreateWithoutUserInput, CorporateClientUncheckedCreateWithoutUserInput>
  }

  export type VerificationCodeCreateWithoutUserInput = {
    code: string
    expiresAt: Date | string
  }

  export type VerificationCodeUncheckedCreateWithoutUserInput = {
    id?: number
    code: string
    expiresAt: Date | string
  }

  export type VerificationCodeCreateOrConnectWithoutUserInput = {
    where: VerificationCodeWhereUniqueInput
    create: XOR<VerificationCodeCreateWithoutUserInput, VerificationCodeUncheckedCreateWithoutUserInput>
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUpdateManyWithoutRoleNestedInput
    roleUsers?: RoleUserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
    roleUsers?: RoleUserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleUserUpsertWithWhereUniqueWithoutUserInput = {
    where: RoleUserWhereUniqueInput
    update: XOR<RoleUserUpdateWithoutUserInput, RoleUserUncheckedUpdateWithoutUserInput>
    create: XOR<RoleUserCreateWithoutUserInput, RoleUserUncheckedCreateWithoutUserInput>
  }

  export type RoleUserUpdateWithWhereUniqueWithoutUserInput = {
    where: RoleUserWhereUniqueInput
    data: XOR<RoleUserUpdateWithoutUserInput, RoleUserUncheckedUpdateWithoutUserInput>
  }

  export type RoleUserUpdateManyWithWhereWithoutUserInput = {
    where: RoleUserScalarWhereInput
    data: XOR<RoleUserUpdateManyMutationInput, RoleUserUncheckedUpdateManyWithoutUserInput>
  }

  export type IndividualProfessionalUpsertWithoutUserInput = {
    update: XOR<IndividualProfessionalUpdateWithoutUserInput, IndividualProfessionalUncheckedUpdateWithoutUserInput>
    create: XOR<IndividualProfessionalCreateWithoutUserInput, IndividualProfessionalUncheckedCreateWithoutUserInput>
    where?: IndividualProfessionalWhereInput
  }

  export type IndividualProfessionalUpdateToOneWithWhereWithoutUserInput = {
    where?: IndividualProfessionalWhereInput
    data: XOR<IndividualProfessionalUpdateWithoutUserInput, IndividualProfessionalUncheckedUpdateWithoutUserInput>
  }

  export type IndividualProfessionalUpdateWithoutUserInput = {
    profileData?: JsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndividualProfessionalUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    profileData?: JsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUpsertWithoutUserInput = {
    update: XOR<ClientUpdateWithoutUserInput, ClientUncheckedUpdateWithoutUserInput>
    create: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutUserInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutUserInput, ClientUncheckedUpdateWithoutUserInput>
  }

  export type ClientUpdateWithoutUserInput = {
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ads?: ClientAdUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ads?: ClientAdUncheckedUpdateManyWithoutClientNestedInput
  }

  export type SecurityCompanyUpsertWithoutUserInput = {
    update: XOR<SecurityCompanyUpdateWithoutUserInput, SecurityCompanyUncheckedUpdateWithoutUserInput>
    create: XOR<SecurityCompanyCreateWithoutUserInput, SecurityCompanyUncheckedCreateWithoutUserInput>
    where?: SecurityCompanyWhereInput
  }

  export type SecurityCompanyUpdateToOneWithWhereWithoutUserInput = {
    where?: SecurityCompanyWhereInput
    data: XOR<SecurityCompanyUpdateWithoutUserInput, SecurityCompanyUncheckedUpdateWithoutUserInput>
  }

  export type SecurityCompanyUpdateWithoutUserInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    servicesRequirements?: NullableJsonNullValueInput | InputJsonValue
    securityServicesOfferings?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceAds?: ServiceAdUpdateManyWithoutCompanyNestedInput
  }

  export type SecurityCompanyUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    servicesRequirements?: NullableJsonNullValueInput | InputJsonValue
    securityServicesOfferings?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceAds?: ServiceAdUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CourseProviderUpsertWithoutUserInput = {
    update: XOR<CourseProviderUpdateWithoutUserInput, CourseProviderUncheckedUpdateWithoutUserInput>
    create: XOR<CourseProviderCreateWithoutUserInput, CourseProviderUncheckedCreateWithoutUserInput>
    where?: CourseProviderWhereInput
  }

  export type CourseProviderUpdateToOneWithWhereWithoutUserInput = {
    where?: CourseProviderWhereInput
    data: XOR<CourseProviderUpdateWithoutUserInput, CourseProviderUncheckedUpdateWithoutUserInput>
  }

  export type CourseProviderUpdateWithoutUserInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    servicesRequirements?: NullableJsonNullValueInput | InputJsonValue
    securityServicesOfferings?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseAds?: CourseAdUpdateManyWithoutCourseProviderNestedInput
  }

  export type CourseProviderUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    servicesRequirements?: NullableJsonNullValueInput | InputJsonValue
    securityServicesOfferings?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseAds?: CourseAdUncheckedUpdateManyWithoutCourseProviderNestedInput
  }

  export type CorporateClientUpsertWithoutUserInput = {
    update: XOR<CorporateClientUpdateWithoutUserInput, CorporateClientUncheckedUpdateWithoutUserInput>
    create: XOR<CorporateClientCreateWithoutUserInput, CorporateClientUncheckedCreateWithoutUserInput>
    where?: CorporateClientWhereInput
  }

  export type CorporateClientUpdateToOneWithWhereWithoutUserInput = {
    where?: CorporateClientWhereInput
    data: XOR<CorporateClientUpdateWithoutUserInput, CorporateClientUncheckedUpdateWithoutUserInput>
  }

  export type CorporateClientUpdateWithoutUserInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    industryType?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    serviceRequirements?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    corporateAds?: CorporateAdUpdateManyWithoutCorporateClientNestedInput
  }

  export type CorporateClientUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    industryType?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    serviceRequirements?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    corporateAds?: CorporateAdUncheckedUpdateManyWithoutCorporateClientNestedInput
  }

  export type VerificationCodeUpsertWithoutUserInput = {
    update: XOR<VerificationCodeUpdateWithoutUserInput, VerificationCodeUncheckedUpdateWithoutUserInput>
    create: XOR<VerificationCodeCreateWithoutUserInput, VerificationCodeUncheckedCreateWithoutUserInput>
    where?: VerificationCodeWhereInput
  }

  export type VerificationCodeUpdateToOneWithWhereWithoutUserInput = {
    where?: VerificationCodeWhereInput
    data: XOR<VerificationCodeUpdateWithoutUserInput, VerificationCodeUncheckedUpdateWithoutUserInput>
  }

  export type VerificationCodeUpdateWithoutUserInput = {
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCodeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutIndividualProfessionalInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    screenName?: string | null
    phoneNumber: string
    dateOfBirth?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    roleUsers?: RoleUserCreateNestedManyWithoutUserInput
    client?: ClientCreateNestedOneWithoutUserInput
    securityCompany?: SecurityCompanyCreateNestedOneWithoutUserInput
    courseProvider?: CourseProviderCreateNestedOneWithoutUserInput
    corporateClient?: CorporateClientCreateNestedOneWithoutUserInput
    VerificationCode?: VerificationCodeCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutIndividualProfessionalInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    screenName?: string | null
    phoneNumber: string
    dateOfBirth?: string | null
    address?: string | null
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    roleUsers?: RoleUserUncheckedCreateNestedManyWithoutUserInput
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    securityCompany?: SecurityCompanyUncheckedCreateNestedOneWithoutUserInput
    courseProvider?: CourseProviderUncheckedCreateNestedOneWithoutUserInput
    corporateClient?: CorporateClientUncheckedCreateNestedOneWithoutUserInput
    VerificationCode?: VerificationCodeUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutIndividualProfessionalInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIndividualProfessionalInput, UserUncheckedCreateWithoutIndividualProfessionalInput>
  }

  export type UserUpsertWithoutIndividualProfessionalInput = {
    update: XOR<UserUpdateWithoutIndividualProfessionalInput, UserUncheckedUpdateWithoutIndividualProfessionalInput>
    create: XOR<UserCreateWithoutIndividualProfessionalInput, UserUncheckedCreateWithoutIndividualProfessionalInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIndividualProfessionalInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIndividualProfessionalInput, UserUncheckedUpdateWithoutIndividualProfessionalInput>
  }

  export type UserUpdateWithoutIndividualProfessionalInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    roleUsers?: RoleUserUpdateManyWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUserNestedInput
    securityCompany?: SecurityCompanyUpdateOneWithoutUserNestedInput
    courseProvider?: CourseProviderUpdateOneWithoutUserNestedInput
    corporateClient?: CorporateClientUpdateOneWithoutUserNestedInput
    VerificationCode?: VerificationCodeUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutIndividualProfessionalInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleUsers?: RoleUserUncheckedUpdateManyWithoutUserNestedInput
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    securityCompany?: SecurityCompanyUncheckedUpdateOneWithoutUserNestedInput
    courseProvider?: CourseProviderUncheckedUpdateOneWithoutUserNestedInput
    corporateClient?: CorporateClientUncheckedUpdateOneWithoutUserNestedInput
    VerificationCode?: VerificationCodeUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutClientInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    screenName?: string | null
    phoneNumber: string
    dateOfBirth?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    roleUsers?: RoleUserCreateNestedManyWithoutUserInput
    individualProfessional?: IndividualProfessionalCreateNestedOneWithoutUserInput
    securityCompany?: SecurityCompanyCreateNestedOneWithoutUserInput
    courseProvider?: CourseProviderCreateNestedOneWithoutUserInput
    corporateClient?: CorporateClientCreateNestedOneWithoutUserInput
    VerificationCode?: VerificationCodeCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClientInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    screenName?: string | null
    phoneNumber: string
    dateOfBirth?: string | null
    address?: string | null
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    roleUsers?: RoleUserUncheckedCreateNestedManyWithoutUserInput
    individualProfessional?: IndividualProfessionalUncheckedCreateNestedOneWithoutUserInput
    securityCompany?: SecurityCompanyUncheckedCreateNestedOneWithoutUserInput
    courseProvider?: CourseProviderUncheckedCreateNestedOneWithoutUserInput
    corporateClient?: CorporateClientUncheckedCreateNestedOneWithoutUserInput
    VerificationCode?: VerificationCodeUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClientInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
  }

  export type ClientAdCreateWithoutClientInput = {
    title: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientAdUncheckedCreateWithoutClientInput = {
    id?: number
    title: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientAdCreateOrConnectWithoutClientInput = {
    where: ClientAdWhereUniqueInput
    create: XOR<ClientAdCreateWithoutClientInput, ClientAdUncheckedCreateWithoutClientInput>
  }

  export type ClientAdCreateManyClientInputEnvelope = {
    data: ClientAdCreateManyClientInput | ClientAdCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutClientInput = {
    update: XOR<UserUpdateWithoutClientInput, UserUncheckedUpdateWithoutClientInput>
    create: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClientInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClientInput, UserUncheckedUpdateWithoutClientInput>
  }

  export type UserUpdateWithoutClientInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    roleUsers?: RoleUserUpdateManyWithoutUserNestedInput
    individualProfessional?: IndividualProfessionalUpdateOneWithoutUserNestedInput
    securityCompany?: SecurityCompanyUpdateOneWithoutUserNestedInput
    courseProvider?: CourseProviderUpdateOneWithoutUserNestedInput
    corporateClient?: CorporateClientUpdateOneWithoutUserNestedInput
    VerificationCode?: VerificationCodeUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleUsers?: RoleUserUncheckedUpdateManyWithoutUserNestedInput
    individualProfessional?: IndividualProfessionalUncheckedUpdateOneWithoutUserNestedInput
    securityCompany?: SecurityCompanyUncheckedUpdateOneWithoutUserNestedInput
    courseProvider?: CourseProviderUncheckedUpdateOneWithoutUserNestedInput
    corporateClient?: CorporateClientUncheckedUpdateOneWithoutUserNestedInput
    VerificationCode?: VerificationCodeUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ClientAdUpsertWithWhereUniqueWithoutClientInput = {
    where: ClientAdWhereUniqueInput
    update: XOR<ClientAdUpdateWithoutClientInput, ClientAdUncheckedUpdateWithoutClientInput>
    create: XOR<ClientAdCreateWithoutClientInput, ClientAdUncheckedCreateWithoutClientInput>
  }

  export type ClientAdUpdateWithWhereUniqueWithoutClientInput = {
    where: ClientAdWhereUniqueInput
    data: XOR<ClientAdUpdateWithoutClientInput, ClientAdUncheckedUpdateWithoutClientInput>
  }

  export type ClientAdUpdateManyWithWhereWithoutClientInput = {
    where: ClientAdScalarWhereInput
    data: XOR<ClientAdUpdateManyMutationInput, ClientAdUncheckedUpdateManyWithoutClientInput>
  }

  export type ClientAdScalarWhereInput = {
    AND?: ClientAdScalarWhereInput | ClientAdScalarWhereInput[]
    OR?: ClientAdScalarWhereInput[]
    NOT?: ClientAdScalarWhereInput | ClientAdScalarWhereInput[]
    id?: IntFilter<"ClientAd"> | number
    clientId?: IntFilter<"ClientAd"> | number
    title?: StringFilter<"ClientAd"> | string
    description?: StringFilter<"ClientAd"> | string
    createdAt?: DateTimeFilter<"ClientAd"> | Date | string
    updatedAt?: DateTimeFilter<"ClientAd"> | Date | string
  }

  export type UserCreateWithoutSecurityCompanyInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    screenName?: string | null
    phoneNumber: string
    dateOfBirth?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    roleUsers?: RoleUserCreateNestedManyWithoutUserInput
    individualProfessional?: IndividualProfessionalCreateNestedOneWithoutUserInput
    client?: ClientCreateNestedOneWithoutUserInput
    courseProvider?: CourseProviderCreateNestedOneWithoutUserInput
    corporateClient?: CorporateClientCreateNestedOneWithoutUserInput
    VerificationCode?: VerificationCodeCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSecurityCompanyInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    screenName?: string | null
    phoneNumber: string
    dateOfBirth?: string | null
    address?: string | null
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    roleUsers?: RoleUserUncheckedCreateNestedManyWithoutUserInput
    individualProfessional?: IndividualProfessionalUncheckedCreateNestedOneWithoutUserInput
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    courseProvider?: CourseProviderUncheckedCreateNestedOneWithoutUserInput
    corporateClient?: CorporateClientUncheckedCreateNestedOneWithoutUserInput
    VerificationCode?: VerificationCodeUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSecurityCompanyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSecurityCompanyInput, UserUncheckedCreateWithoutSecurityCompanyInput>
  }

  export type ServiceAdCreateWithoutCompanyInput = {
    jobTitle: string
    jobType: string
    industryCategory: string
    region: string
    postcode: string
    salaryRate: number
    salaryType: string
    jobDescription: string
    requiredExperience: string
    requiredLicences?: string | null
    shiftAndHours?: string | null
    startDate?: Date | string | null
    deadline?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceAdUncheckedCreateWithoutCompanyInput = {
    id?: number
    jobTitle: string
    jobType: string
    industryCategory: string
    region: string
    postcode: string
    salaryRate: number
    salaryType: string
    jobDescription: string
    requiredExperience: string
    requiredLicences?: string | null
    shiftAndHours?: string | null
    startDate?: Date | string | null
    deadline?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceAdCreateOrConnectWithoutCompanyInput = {
    where: ServiceAdWhereUniqueInput
    create: XOR<ServiceAdCreateWithoutCompanyInput, ServiceAdUncheckedCreateWithoutCompanyInput>
  }

  export type ServiceAdCreateManyCompanyInputEnvelope = {
    data: ServiceAdCreateManyCompanyInput | ServiceAdCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSecurityCompanyInput = {
    update: XOR<UserUpdateWithoutSecurityCompanyInput, UserUncheckedUpdateWithoutSecurityCompanyInput>
    create: XOR<UserCreateWithoutSecurityCompanyInput, UserUncheckedCreateWithoutSecurityCompanyInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSecurityCompanyInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSecurityCompanyInput, UserUncheckedUpdateWithoutSecurityCompanyInput>
  }

  export type UserUpdateWithoutSecurityCompanyInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    roleUsers?: RoleUserUpdateManyWithoutUserNestedInput
    individualProfessional?: IndividualProfessionalUpdateOneWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUserNestedInput
    courseProvider?: CourseProviderUpdateOneWithoutUserNestedInput
    corporateClient?: CorporateClientUpdateOneWithoutUserNestedInput
    VerificationCode?: VerificationCodeUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSecurityCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleUsers?: RoleUserUncheckedUpdateManyWithoutUserNestedInput
    individualProfessional?: IndividualProfessionalUncheckedUpdateOneWithoutUserNestedInput
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    courseProvider?: CourseProviderUncheckedUpdateOneWithoutUserNestedInput
    corporateClient?: CorporateClientUncheckedUpdateOneWithoutUserNestedInput
    VerificationCode?: VerificationCodeUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ServiceAdUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ServiceAdWhereUniqueInput
    update: XOR<ServiceAdUpdateWithoutCompanyInput, ServiceAdUncheckedUpdateWithoutCompanyInput>
    create: XOR<ServiceAdCreateWithoutCompanyInput, ServiceAdUncheckedCreateWithoutCompanyInput>
  }

  export type ServiceAdUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ServiceAdWhereUniqueInput
    data: XOR<ServiceAdUpdateWithoutCompanyInput, ServiceAdUncheckedUpdateWithoutCompanyInput>
  }

  export type ServiceAdUpdateManyWithWhereWithoutCompanyInput = {
    where: ServiceAdScalarWhereInput
    data: XOR<ServiceAdUpdateManyMutationInput, ServiceAdUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ServiceAdScalarWhereInput = {
    AND?: ServiceAdScalarWhereInput | ServiceAdScalarWhereInput[]
    OR?: ServiceAdScalarWhereInput[]
    NOT?: ServiceAdScalarWhereInput | ServiceAdScalarWhereInput[]
    id?: IntFilter<"ServiceAd"> | number
    companyId?: IntFilter<"ServiceAd"> | number
    jobTitle?: StringFilter<"ServiceAd"> | string
    jobType?: StringFilter<"ServiceAd"> | string
    industryCategory?: StringFilter<"ServiceAd"> | string
    region?: StringFilter<"ServiceAd"> | string
    postcode?: StringFilter<"ServiceAd"> | string
    salaryRate?: FloatFilter<"ServiceAd"> | number
    salaryType?: StringFilter<"ServiceAd"> | string
    jobDescription?: StringFilter<"ServiceAd"> | string
    requiredExperience?: StringFilter<"ServiceAd"> | string
    requiredLicences?: StringNullableFilter<"ServiceAd"> | string | null
    shiftAndHours?: StringNullableFilter<"ServiceAd"> | string | null
    startDate?: DateTimeNullableFilter<"ServiceAd"> | Date | string | null
    deadline?: DateTimeNullableFilter<"ServiceAd"> | Date | string | null
    createdAt?: DateTimeFilter<"ServiceAd"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceAd"> | Date | string
  }

  export type UserCreateWithoutCourseProviderInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    screenName?: string | null
    phoneNumber: string
    dateOfBirth?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    roleUsers?: RoleUserCreateNestedManyWithoutUserInput
    individualProfessional?: IndividualProfessionalCreateNestedOneWithoutUserInput
    client?: ClientCreateNestedOneWithoutUserInput
    securityCompany?: SecurityCompanyCreateNestedOneWithoutUserInput
    corporateClient?: CorporateClientCreateNestedOneWithoutUserInput
    VerificationCode?: VerificationCodeCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCourseProviderInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    screenName?: string | null
    phoneNumber: string
    dateOfBirth?: string | null
    address?: string | null
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    roleUsers?: RoleUserUncheckedCreateNestedManyWithoutUserInput
    individualProfessional?: IndividualProfessionalUncheckedCreateNestedOneWithoutUserInput
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    securityCompany?: SecurityCompanyUncheckedCreateNestedOneWithoutUserInput
    corporateClient?: CorporateClientUncheckedCreateNestedOneWithoutUserInput
    VerificationCode?: VerificationCodeUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCourseProviderInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCourseProviderInput, UserUncheckedCreateWithoutCourseProviderInput>
  }

  export type CourseAdCreateWithoutCourseProviderInput = {
    title: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseAdUncheckedCreateWithoutCourseProviderInput = {
    id?: number
    title: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseAdCreateOrConnectWithoutCourseProviderInput = {
    where: CourseAdWhereUniqueInput
    create: XOR<CourseAdCreateWithoutCourseProviderInput, CourseAdUncheckedCreateWithoutCourseProviderInput>
  }

  export type CourseAdCreateManyCourseProviderInputEnvelope = {
    data: CourseAdCreateManyCourseProviderInput | CourseAdCreateManyCourseProviderInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCourseProviderInput = {
    update: XOR<UserUpdateWithoutCourseProviderInput, UserUncheckedUpdateWithoutCourseProviderInput>
    create: XOR<UserCreateWithoutCourseProviderInput, UserUncheckedCreateWithoutCourseProviderInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCourseProviderInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCourseProviderInput, UserUncheckedUpdateWithoutCourseProviderInput>
  }

  export type UserUpdateWithoutCourseProviderInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    roleUsers?: RoleUserUpdateManyWithoutUserNestedInput
    individualProfessional?: IndividualProfessionalUpdateOneWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUserNestedInput
    securityCompany?: SecurityCompanyUpdateOneWithoutUserNestedInput
    corporateClient?: CorporateClientUpdateOneWithoutUserNestedInput
    VerificationCode?: VerificationCodeUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCourseProviderInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleUsers?: RoleUserUncheckedUpdateManyWithoutUserNestedInput
    individualProfessional?: IndividualProfessionalUncheckedUpdateOneWithoutUserNestedInput
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    securityCompany?: SecurityCompanyUncheckedUpdateOneWithoutUserNestedInput
    corporateClient?: CorporateClientUncheckedUpdateOneWithoutUserNestedInput
    VerificationCode?: VerificationCodeUncheckedUpdateOneWithoutUserNestedInput
  }

  export type CourseAdUpsertWithWhereUniqueWithoutCourseProviderInput = {
    where: CourseAdWhereUniqueInput
    update: XOR<CourseAdUpdateWithoutCourseProviderInput, CourseAdUncheckedUpdateWithoutCourseProviderInput>
    create: XOR<CourseAdCreateWithoutCourseProviderInput, CourseAdUncheckedCreateWithoutCourseProviderInput>
  }

  export type CourseAdUpdateWithWhereUniqueWithoutCourseProviderInput = {
    where: CourseAdWhereUniqueInput
    data: XOR<CourseAdUpdateWithoutCourseProviderInput, CourseAdUncheckedUpdateWithoutCourseProviderInput>
  }

  export type CourseAdUpdateManyWithWhereWithoutCourseProviderInput = {
    where: CourseAdScalarWhereInput
    data: XOR<CourseAdUpdateManyMutationInput, CourseAdUncheckedUpdateManyWithoutCourseProviderInput>
  }

  export type CourseAdScalarWhereInput = {
    AND?: CourseAdScalarWhereInput | CourseAdScalarWhereInput[]
    OR?: CourseAdScalarWhereInput[]
    NOT?: CourseAdScalarWhereInput | CourseAdScalarWhereInput[]
    id?: IntFilter<"CourseAd"> | number
    courseProviderId?: IntFilter<"CourseAd"> | number
    title?: StringFilter<"CourseAd"> | string
    description?: StringFilter<"CourseAd"> | string
    createdAt?: DateTimeFilter<"CourseAd"> | Date | string
    updatedAt?: DateTimeFilter<"CourseAd"> | Date | string
  }

  export type UserCreateWithoutCorporateClientInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    screenName?: string | null
    phoneNumber: string
    dateOfBirth?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    roleUsers?: RoleUserCreateNestedManyWithoutUserInput
    individualProfessional?: IndividualProfessionalCreateNestedOneWithoutUserInput
    client?: ClientCreateNestedOneWithoutUserInput
    securityCompany?: SecurityCompanyCreateNestedOneWithoutUserInput
    courseProvider?: CourseProviderCreateNestedOneWithoutUserInput
    VerificationCode?: VerificationCodeCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCorporateClientInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    screenName?: string | null
    phoneNumber: string
    dateOfBirth?: string | null
    address?: string | null
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    roleUsers?: RoleUserUncheckedCreateNestedManyWithoutUserInput
    individualProfessional?: IndividualProfessionalUncheckedCreateNestedOneWithoutUserInput
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    securityCompany?: SecurityCompanyUncheckedCreateNestedOneWithoutUserInput
    courseProvider?: CourseProviderUncheckedCreateNestedOneWithoutUserInput
    VerificationCode?: VerificationCodeUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCorporateClientInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCorporateClientInput, UserUncheckedCreateWithoutCorporateClientInput>
  }

  export type CorporateAdCreateWithoutCorporateClientInput = {
    title: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorporateAdUncheckedCreateWithoutCorporateClientInput = {
    id?: number
    title: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorporateAdCreateOrConnectWithoutCorporateClientInput = {
    where: CorporateAdWhereUniqueInput
    create: XOR<CorporateAdCreateWithoutCorporateClientInput, CorporateAdUncheckedCreateWithoutCorporateClientInput>
  }

  export type CorporateAdCreateManyCorporateClientInputEnvelope = {
    data: CorporateAdCreateManyCorporateClientInput | CorporateAdCreateManyCorporateClientInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCorporateClientInput = {
    update: XOR<UserUpdateWithoutCorporateClientInput, UserUncheckedUpdateWithoutCorporateClientInput>
    create: XOR<UserCreateWithoutCorporateClientInput, UserUncheckedCreateWithoutCorporateClientInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCorporateClientInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCorporateClientInput, UserUncheckedUpdateWithoutCorporateClientInput>
  }

  export type UserUpdateWithoutCorporateClientInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    roleUsers?: RoleUserUpdateManyWithoutUserNestedInput
    individualProfessional?: IndividualProfessionalUpdateOneWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUserNestedInput
    securityCompany?: SecurityCompanyUpdateOneWithoutUserNestedInput
    courseProvider?: CourseProviderUpdateOneWithoutUserNestedInput
    VerificationCode?: VerificationCodeUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCorporateClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleUsers?: RoleUserUncheckedUpdateManyWithoutUserNestedInput
    individualProfessional?: IndividualProfessionalUncheckedUpdateOneWithoutUserNestedInput
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    securityCompany?: SecurityCompanyUncheckedUpdateOneWithoutUserNestedInput
    courseProvider?: CourseProviderUncheckedUpdateOneWithoutUserNestedInput
    VerificationCode?: VerificationCodeUncheckedUpdateOneWithoutUserNestedInput
  }

  export type CorporateAdUpsertWithWhereUniqueWithoutCorporateClientInput = {
    where: CorporateAdWhereUniqueInput
    update: XOR<CorporateAdUpdateWithoutCorporateClientInput, CorporateAdUncheckedUpdateWithoutCorporateClientInput>
    create: XOR<CorporateAdCreateWithoutCorporateClientInput, CorporateAdUncheckedCreateWithoutCorporateClientInput>
  }

  export type CorporateAdUpdateWithWhereUniqueWithoutCorporateClientInput = {
    where: CorporateAdWhereUniqueInput
    data: XOR<CorporateAdUpdateWithoutCorporateClientInput, CorporateAdUncheckedUpdateWithoutCorporateClientInput>
  }

  export type CorporateAdUpdateManyWithWhereWithoutCorporateClientInput = {
    where: CorporateAdScalarWhereInput
    data: XOR<CorporateAdUpdateManyMutationInput, CorporateAdUncheckedUpdateManyWithoutCorporateClientInput>
  }

  export type CorporateAdScalarWhereInput = {
    AND?: CorporateAdScalarWhereInput | CorporateAdScalarWhereInput[]
    OR?: CorporateAdScalarWhereInput[]
    NOT?: CorporateAdScalarWhereInput | CorporateAdScalarWhereInput[]
    id?: IntFilter<"CorporateAd"> | number
    corporateClientId?: IntFilter<"CorporateAd"> | number
    title?: StringFilter<"CorporateAd"> | string
    description?: StringFilter<"CorporateAd"> | string
    createdAt?: DateTimeFilter<"CorporateAd"> | Date | string
    updatedAt?: DateTimeFilter<"CorporateAd"> | Date | string
  }

  export type CorporateClientCreateWithoutCorporateAdsInput = {
    companyName: string
    registrationNumber: string
    address: string
    postCode: string
    industryType: string
    contactPerson: string
    jobTitle: string
    phoneNumber: string
    website?: string | null
    serviceRequirements?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCorporateClientInput
  }

  export type CorporateClientUncheckedCreateWithoutCorporateAdsInput = {
    id?: number
    userId: number
    companyName: string
    registrationNumber: string
    address: string
    postCode: string
    industryType: string
    contactPerson: string
    jobTitle: string
    phoneNumber: string
    website?: string | null
    serviceRequirements?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorporateClientCreateOrConnectWithoutCorporateAdsInput = {
    where: CorporateClientWhereUniqueInput
    create: XOR<CorporateClientCreateWithoutCorporateAdsInput, CorporateClientUncheckedCreateWithoutCorporateAdsInput>
  }

  export type CorporateClientUpsertWithoutCorporateAdsInput = {
    update: XOR<CorporateClientUpdateWithoutCorporateAdsInput, CorporateClientUncheckedUpdateWithoutCorporateAdsInput>
    create: XOR<CorporateClientCreateWithoutCorporateAdsInput, CorporateClientUncheckedCreateWithoutCorporateAdsInput>
    where?: CorporateClientWhereInput
  }

  export type CorporateClientUpdateToOneWithWhereWithoutCorporateAdsInput = {
    where?: CorporateClientWhereInput
    data: XOR<CorporateClientUpdateWithoutCorporateAdsInput, CorporateClientUncheckedUpdateWithoutCorporateAdsInput>
  }

  export type CorporateClientUpdateWithoutCorporateAdsInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    industryType?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    serviceRequirements?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCorporateClientNestedInput
  }

  export type CorporateClientUncheckedUpdateWithoutCorporateAdsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    industryType?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    serviceRequirements?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseProviderCreateWithoutCourseAdsInput = {
    companyName: string
    registrationNumber: string
    address: string
    postCode: string
    contactPerson: string
    jobTitle: string
    phoneNumber: string
    website?: string | null
    servicesRequirements?: NullableJsonNullValueInput | InputJsonValue
    securityServicesOfferings?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCourseProviderInput
  }

  export type CourseProviderUncheckedCreateWithoutCourseAdsInput = {
    id?: number
    userId: number
    companyName: string
    registrationNumber: string
    address: string
    postCode: string
    contactPerson: string
    jobTitle: string
    phoneNumber: string
    website?: string | null
    servicesRequirements?: NullableJsonNullValueInput | InputJsonValue
    securityServicesOfferings?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseProviderCreateOrConnectWithoutCourseAdsInput = {
    where: CourseProviderWhereUniqueInput
    create: XOR<CourseProviderCreateWithoutCourseAdsInput, CourseProviderUncheckedCreateWithoutCourseAdsInput>
  }

  export type CourseProviderUpsertWithoutCourseAdsInput = {
    update: XOR<CourseProviderUpdateWithoutCourseAdsInput, CourseProviderUncheckedUpdateWithoutCourseAdsInput>
    create: XOR<CourseProviderCreateWithoutCourseAdsInput, CourseProviderUncheckedCreateWithoutCourseAdsInput>
    where?: CourseProviderWhereInput
  }

  export type CourseProviderUpdateToOneWithWhereWithoutCourseAdsInput = {
    where?: CourseProviderWhereInput
    data: XOR<CourseProviderUpdateWithoutCourseAdsInput, CourseProviderUncheckedUpdateWithoutCourseAdsInput>
  }

  export type CourseProviderUpdateWithoutCourseAdsInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    servicesRequirements?: NullableJsonNullValueInput | InputJsonValue
    securityServicesOfferings?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCourseProviderNestedInput
  }

  export type CourseProviderUncheckedUpdateWithoutCourseAdsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    servicesRequirements?: NullableJsonNullValueInput | InputJsonValue
    securityServicesOfferings?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityCompanyCreateWithoutServiceAdsInput = {
    companyName: string
    registrationNumber: string
    address: string
    postCode: string
    contactPerson: string
    jobTitle: string
    phoneNumber: string
    website?: string | null
    servicesRequirements?: NullableJsonNullValueInput | InputJsonValue
    securityServicesOfferings?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSecurityCompanyInput
  }

  export type SecurityCompanyUncheckedCreateWithoutServiceAdsInput = {
    id?: number
    userId: number
    companyName: string
    registrationNumber: string
    address: string
    postCode: string
    contactPerson: string
    jobTitle: string
    phoneNumber: string
    website?: string | null
    servicesRequirements?: NullableJsonNullValueInput | InputJsonValue
    securityServicesOfferings?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecurityCompanyCreateOrConnectWithoutServiceAdsInput = {
    where: SecurityCompanyWhereUniqueInput
    create: XOR<SecurityCompanyCreateWithoutServiceAdsInput, SecurityCompanyUncheckedCreateWithoutServiceAdsInput>
  }

  export type SecurityCompanyUpsertWithoutServiceAdsInput = {
    update: XOR<SecurityCompanyUpdateWithoutServiceAdsInput, SecurityCompanyUncheckedUpdateWithoutServiceAdsInput>
    create: XOR<SecurityCompanyCreateWithoutServiceAdsInput, SecurityCompanyUncheckedCreateWithoutServiceAdsInput>
    where?: SecurityCompanyWhereInput
  }

  export type SecurityCompanyUpdateToOneWithWhereWithoutServiceAdsInput = {
    where?: SecurityCompanyWhereInput
    data: XOR<SecurityCompanyUpdateWithoutServiceAdsInput, SecurityCompanyUncheckedUpdateWithoutServiceAdsInput>
  }

  export type SecurityCompanyUpdateWithoutServiceAdsInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    servicesRequirements?: NullableJsonNullValueInput | InputJsonValue
    securityServicesOfferings?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSecurityCompanyNestedInput
  }

  export type SecurityCompanyUncheckedUpdateWithoutServiceAdsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    servicesRequirements?: NullableJsonNullValueInput | InputJsonValue
    securityServicesOfferings?: NullableJsonNullValueInput | InputJsonValue
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateWithoutAdsInput = {
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutAdsInput = {
    id?: number
    userId: number
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientCreateOrConnectWithoutAdsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutAdsInput, ClientUncheckedCreateWithoutAdsInput>
  }

  export type ClientUpsertWithoutAdsInput = {
    update: XOR<ClientUpdateWithoutAdsInput, ClientUncheckedUpdateWithoutAdsInput>
    create: XOR<ClientCreateWithoutAdsInput, ClientUncheckedCreateWithoutAdsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutAdsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutAdsInput, ClientUncheckedUpdateWithoutAdsInput>
  }

  export type ClientUpdateWithoutAdsInput = {
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutAdsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateWithoutRoleUsersInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionCreateNestedManyWithoutRoleInput
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutRoleUsersInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutRoleUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutRoleUsersInput, RoleUncheckedCreateWithoutRoleUsersInput>
  }

  export type UserCreateWithoutRoleUsersInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    screenName?: string | null
    phoneNumber: string
    dateOfBirth?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    individualProfessional?: IndividualProfessionalCreateNestedOneWithoutUserInput
    client?: ClientCreateNestedOneWithoutUserInput
    securityCompany?: SecurityCompanyCreateNestedOneWithoutUserInput
    courseProvider?: CourseProviderCreateNestedOneWithoutUserInput
    corporateClient?: CorporateClientCreateNestedOneWithoutUserInput
    VerificationCode?: VerificationCodeCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRoleUsersInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    screenName?: string | null
    phoneNumber: string
    dateOfBirth?: string | null
    address?: string | null
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    individualProfessional?: IndividualProfessionalUncheckedCreateNestedOneWithoutUserInput
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    securityCompany?: SecurityCompanyUncheckedCreateNestedOneWithoutUserInput
    courseProvider?: CourseProviderUncheckedCreateNestedOneWithoutUserInput
    corporateClient?: CorporateClientUncheckedCreateNestedOneWithoutUserInput
    VerificationCode?: VerificationCodeUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRoleUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleUsersInput, UserUncheckedCreateWithoutRoleUsersInput>
  }

  export type RoleUpsertWithoutRoleUsersInput = {
    update: XOR<RoleUpdateWithoutRoleUsersInput, RoleUncheckedUpdateWithoutRoleUsersInput>
    create: XOR<RoleCreateWithoutRoleUsersInput, RoleUncheckedCreateWithoutRoleUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutRoleUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutRoleUsersInput, RoleUncheckedUpdateWithoutRoleUsersInput>
  }

  export type RoleUpdateWithoutRoleUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUpdateManyWithoutRoleNestedInput
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutRoleUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type UserUpsertWithoutRoleUsersInput = {
    update: XOR<UserUpdateWithoutRoleUsersInput, UserUncheckedUpdateWithoutRoleUsersInput>
    create: XOR<UserCreateWithoutRoleUsersInput, UserUncheckedCreateWithoutRoleUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRoleUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRoleUsersInput, UserUncheckedUpdateWithoutRoleUsersInput>
  }

  export type UserUpdateWithoutRoleUsersInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    individualProfessional?: IndividualProfessionalUpdateOneWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUserNestedInput
    securityCompany?: SecurityCompanyUpdateOneWithoutUserNestedInput
    courseProvider?: CourseProviderUpdateOneWithoutUserNestedInput
    corporateClient?: CorporateClientUpdateOneWithoutUserNestedInput
    VerificationCode?: VerificationCodeUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    individualProfessional?: IndividualProfessionalUncheckedUpdateOneWithoutUserNestedInput
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    securityCompany?: SecurityCompanyUncheckedUpdateOneWithoutUserNestedInput
    courseProvider?: CourseProviderUncheckedUpdateOneWithoutUserNestedInput
    corporateClient?: CorporateClientUncheckedUpdateOneWithoutUserNestedInput
    VerificationCode?: VerificationCodeUncheckedUpdateOneWithoutUserNestedInput
  }

  export type RolePermissionCreateManyPermissionInput = {
    id?: number
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolePermissionUpdateWithoutPermissionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutPermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyRoleInput = {
    id?: number
    permissionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyRoleInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    screenName?: string | null
    phoneNumber: string
    dateOfBirth?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUserCreateManyRoleInput = {
    id?: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolePermissionUpdateWithoutRoleInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permission?: PermissionUpdateOneRequiredWithoutRolesNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutRoleInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleUsers?: RoleUserUpdateManyWithoutUserNestedInput
    individualProfessional?: IndividualProfessionalUpdateOneWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUserNestedInput
    securityCompany?: SecurityCompanyUpdateOneWithoutUserNestedInput
    courseProvider?: CourseProviderUpdateOneWithoutUserNestedInput
    corporateClient?: CorporateClientUpdateOneWithoutUserNestedInput
    VerificationCode?: VerificationCodeUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleUsers?: RoleUserUncheckedUpdateManyWithoutUserNestedInput
    individualProfessional?: IndividualProfessionalUncheckedUpdateOneWithoutUserNestedInput
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    securityCompany?: SecurityCompanyUncheckedUpdateOneWithoutUserNestedInput
    courseProvider?: CourseProviderUncheckedUpdateOneWithoutUserNestedInput
    corporateClient?: CorporateClientUncheckedUpdateOneWithoutUserNestedInput
    VerificationCode?: VerificationCodeUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUserUpdateWithoutRoleInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRoleUsersNestedInput
  }

  export type RoleUserUncheckedUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUserUncheckedUpdateManyWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUserCreateManyUserInput = {
    id?: number
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUserUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutRoleUsersNestedInput
  }

  export type RoleUserUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUserUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientAdCreateManyClientInput = {
    id?: number
    title: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientAdUpdateWithoutClientInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientAdUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientAdUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAdCreateManyCompanyInput = {
    id?: number
    jobTitle: string
    jobType: string
    industryCategory: string
    region: string
    postcode: string
    salaryRate: number
    salaryType: string
    jobDescription: string
    requiredExperience: string
    requiredLicences?: string | null
    shiftAndHours?: string | null
    startDate?: Date | string | null
    deadline?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceAdUpdateWithoutCompanyInput = {
    jobTitle?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    industryCategory?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    postcode?: StringFieldUpdateOperationsInput | string
    salaryRate?: FloatFieldUpdateOperationsInput | number
    salaryType?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    requiredExperience?: StringFieldUpdateOperationsInput | string
    requiredLicences?: NullableStringFieldUpdateOperationsInput | string | null
    shiftAndHours?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAdUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobTitle?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    industryCategory?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    postcode?: StringFieldUpdateOperationsInput | string
    salaryRate?: FloatFieldUpdateOperationsInput | number
    salaryType?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    requiredExperience?: StringFieldUpdateOperationsInput | string
    requiredLicences?: NullableStringFieldUpdateOperationsInput | string | null
    shiftAndHours?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAdUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobTitle?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    industryCategory?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    postcode?: StringFieldUpdateOperationsInput | string
    salaryRate?: FloatFieldUpdateOperationsInput | number
    salaryType?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    requiredExperience?: StringFieldUpdateOperationsInput | string
    requiredLicences?: NullableStringFieldUpdateOperationsInput | string | null
    shiftAndHours?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseAdCreateManyCourseProviderInput = {
    id?: number
    title: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseAdUpdateWithoutCourseProviderInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseAdUncheckedUpdateWithoutCourseProviderInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseAdUncheckedUpdateManyWithoutCourseProviderInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorporateAdCreateManyCorporateClientInput = {
    id?: number
    title: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorporateAdUpdateWithoutCorporateClientInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorporateAdUncheckedUpdateWithoutCorporateClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorporateAdUncheckedUpdateManyWithoutCorporateClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}